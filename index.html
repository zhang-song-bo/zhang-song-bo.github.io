<!DOCTYPE html>
<html lang="en">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="John Doe" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">



<link rel="stylesheet" href="/css/style.css">



    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Hexo</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        <li>Friends</li>
                        
                        
                        <li>About Me</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                            <li><a href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E8%AE%B0/">生活随记</a></li>
                        
                            <li><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li>
                        
                            <li><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li>
                        
                            <li><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACGAN/" rel="tag">ACGAN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BERT/" rel="tag">BERT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CycleGAN/" rel="tag">CycleGAN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DCGAN/" rel="tag">DCGAN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GAN/" rel="tag">GAN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLM/" rel="tag">LLM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLM-Evaluation/" rel="tag">LLM Evaluation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LoRA/" rel="tag">LoRA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Multi-Agent/" rel="tag">Multi-Agent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NLP/" rel="tag">NLP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVM/" rel="tag">SVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TF-IDF/" rel="tag">TF-IDF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Transformer/" rel="tag">Transformer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WGAN/" rel="tag">WGAN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WGAN-GP/" rel="tag">WGAN-GP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/agent/" rel="tag">agent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/multi-agent/" rel="tag">multi-agent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/" rel="tag">优化技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E5%8F%96/" rel="tag">关键词提取</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD/" rel="tag">具身智能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/" rel="tag">分类模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/" rel="tag">分类算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%83%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/" rel="tag">图像风格迁移</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E8%B0%83/" rel="tag">微调</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A8%E7%90%86%E4%BC%98%E5%8C%96/" rel="tag">推理优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" rel="tag">支持向量机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/" rel="tag">文本分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9E%8B/" rel="tag">模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%8B%9F%E4%BA%BA%E7%B1%BB%E8%A1%8C%E4%B8%BA/" rel="tag">模拟人类行为</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" rel="tag">线性回归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/" rel="tag">逻辑回归</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/about/">关于我</a></li>
                
                    <li><a href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E8%AE%B0/">生活随记</a></li>
                
                    <li><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li>
                
                    <li><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li>
                
                    <li><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-队列-栈" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/06/04/%E9%98%9F%E5%88%97-%E6%A0%88/" class="article-date">
      <time datetime="2025-06-04T07:21:05.000Z" itemprop="datePublished">2025-06-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/06/04/%E9%98%9F%E5%88%97-%E6%A0%88/">队列/栈</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>栈（Stack）和队列（Queue）是两种非常重要且常用的线性数据结构。它们都限制了数据的插入和删除方式，使得它们在特定场景下表现出独特的优势。</p>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈是一种“后进先出”（Last In, First Out - LIFO）的数据结构。你可以把它想象成一叠盘子，你最后放上去的盘子，总是最先被拿走。</p>
<h4 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h4><ul>
<li><strong>栈顶（Top）</strong>: 栈中允许插入和删除元素的一端。</li>
<li><strong>栈底（Bottom）</strong>: 栈中不允许插入和删除元素的另一端。</li>
<li><strong>压栈&#x2F;入栈（Push）</strong>: 向栈中添加元素的操作。</li>
<li><strong>弹栈&#x2F;出栈（Pop）</strong>: 从栈中移除元素的操作。</li>
</ul>
<h4 id="C-语言中栈的实现"><a href="#C-语言中栈的实现" class="headerlink" title="C 语言中栈的实现"></a>C 语言中栈的实现</h4><p>栈可以使用数组或链表来实现。这里我们主要介绍基于<strong>链表</strong>的实现，因为它在动态大小方面更灵活。</p>
<h5 id="栈节点定义"><a href="#栈节点定义" class="headerlink" title="栈节点定义"></a>栈节点定义</h5><p>由于栈的特性，我们只需要单向链表的节点结构即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 包含 malloc 和 free 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义栈节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; StackNode;</span><br></pre></td></tr></table></figure>

<h5 id="栈的初始化"><a href="#栈的初始化" class="headerlink" title="栈的初始化"></a>栈的初始化</h5><p>栈的初始化就是将栈顶指针设为 <code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空栈（栈顶指针）</span></span><br><span class="line">StackNode* <span class="title function_">initStack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 空栈的栈顶指向NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="压栈-入栈操作-Push"><a href="#压栈-入栈操作-Push" class="headerlink" title="压栈&#x2F;入栈操作 (Push)"></a>压栈&#x2F;入栈操作 (Push)</h5><p>新元素总是插入到栈顶。这与链表的头部插入操作类似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压栈操作：向栈中添加元素</span></span><br><span class="line">StackNode* <span class="title function_">push</span><span class="params">(StackNode* top, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    StackNode* newNode = (StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode)); <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value; <span class="comment">// 设置数据</span></span><br><span class="line">    newNode-&gt;next = top;   <span class="comment">// 新节点的next指向原来的栈顶</span></span><br><span class="line">    <span class="keyword">return</span> newNode;        <span class="comment">// 返回新节点作为新的栈顶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="弹栈-出栈操作-Pop"><a href="#弹栈-出栈操作-Pop" class="headerlink" title="弹栈&#x2F;出栈操作 (Pop)"></a>弹栈&#x2F;出栈操作 (Pop)</h5><p>从栈顶移除元素。这与链表的头部删除操作类似，需要处理栈空的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹栈操作：从栈中移除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(StackNode** top)</span> &#123; <span class="comment">// 注意这里使用二级指针，因为需要修改top的值</span></span><br><span class="line">    <span class="keyword">if</span> (*top == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空，无法弹栈！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// 或者返回一个错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    StackNode* temp = *top;     <span class="comment">// 临时保存当前栈顶</span></span><br><span class="line">    <span class="type">int</span> poppedValue = temp-&gt;data; <span class="comment">// 获取栈顶数据</span></span><br><span class="line">    *top = (*top)-&gt;next;       <span class="comment">// 栈顶下移</span></span><br><span class="line">    <span class="built_in">free</span>(temp);                <span class="comment">// 释放原栈顶内存</span></span><br><span class="line">    <span class="keyword">return</span> poppedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查看栈顶元素-Peek-Top"><a href="#查看栈顶元素-Peek-Top" class="headerlink" title="查看栈顶元素 (Peek&#x2F;Top)"></a>查看栈顶元素 (Peek&#x2F;Top)</h5><p>不移除元素，只返回栈顶元素的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看栈顶元素（不移除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空，无法查看栈顶元素！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="判断栈是否为空-isEmpty"><a href="#判断栈是否为空-isEmpty" class="headerlink" title="判断栈是否为空 (isEmpty)"></a>判断栈是否为空 (isEmpty)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isStackEmpty</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历栈并打印数据"><a href="#遍历栈并打印数据" class="headerlink" title="遍历栈并打印数据"></a>遍历栈并打印数据</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印栈所有节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    StackNode* current = top;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈内容（从栈顶到栈底）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放栈内存"><a href="#释放栈内存" class="headerlink" title="释放栈内存"></a>释放栈内存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放栈所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeStack</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    StackNode* current = top;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        StackNode* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整栈示例代码"><a href="#完整栈示例代码" class="headerlink" title="完整栈示例代码"></a>完整栈示例代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义栈节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空栈（栈顶指针）</span></span><br><span class="line">StackNode* <span class="title function_">initStack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压栈操作：向栈中添加元素</span></span><br><span class="line">StackNode* <span class="title function_">push</span><span class="params">(StackNode* top, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    StackNode* newNode = (StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = top;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹栈操作：从栈中移除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(StackNode** top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*top == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空，无法弹栈！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode* temp = *top;</span><br><span class="line">    <span class="type">int</span> poppedValue = temp-&gt;data;</span><br><span class="line">    *top = (*top)-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> poppedValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看栈顶元素（不移除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空，无法查看栈顶元素！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isStackEmpty</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印栈所有节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    StackNode* current = top;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈内容（从栈顶到栈底）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放栈所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeStack</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    StackNode* current = top;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        StackNode* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    StackNode* myStack = initStack(); <span class="comment">// 初始化空栈</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 栈操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈是否为空：%s\n&quot;</span>, isStackEmpty(myStack) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">    myStack = push(myStack, <span class="number">10</span>);</span><br><span class="line">    printStack(myStack);</span><br><span class="line"></span><br><span class="line">    myStack = push(myStack, <span class="number">20</span>);</span><br><span class="line">    printStack(myStack);</span><br><span class="line"></span><br><span class="line">    myStack = push(myStack, <span class="number">30</span>);</span><br><span class="line">    printStack(myStack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈顶元素：%d\n&quot;</span>, peek(myStack));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹栈元素：%d\n&quot;</span>, pop(&amp;myStack));</span><br><span class="line">    printStack(myStack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹栈元素：%d\n&quot;</span>, pop(&amp;myStack));</span><br><span class="line">    printStack(myStack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈是否为空：%s\n&quot;</span>, isStackEmpty(myStack) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹栈元素：%d\n&quot;</span>, pop(&amp;myStack));</span><br><span class="line">    printStack(myStack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈是否为空：%s\n&quot;</span>, isStackEmpty(myStack) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试在空栈上弹栈或查看栈顶</span></span><br><span class="line">    <span class="comment">// pop(&amp;myStack); // 会导致程序退出</span></span><br><span class="line">    <span class="comment">// peek(myStack); // 会导致程序退出</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 内存释放 ------\n&quot;</span>);</span><br><span class="line">    myStack = push(myStack, <span class="number">5</span>);</span><br><span class="line">    myStack = push(myStack, <span class="number">15</span>);</span><br><span class="line">    printStack(myStack);</span><br><span class="line">    freeStack(myStack);</span><br><span class="line">    myStack = <span class="literal">NULL</span>; <span class="comment">// 释放后将栈顶指针设为NULL</span></span><br><span class="line">    </span><br><span class="line">    printStack(myStack); <span class="comment">// 尝试打印已释放的栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>队列是一种“先进先出”（First In, First Out - FIFO）的数据结构。你可以把它想象成排队等候的队伍，最先排队的人总是最先得到服务。</p>
<h4 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h4><ul>
<li><strong>队头（Front）</strong>: 队列中允许删除元素的一端。</li>
<li><strong>队尾（Rear）</strong>: 队列中允许插入元素的一端。</li>
<li><strong>入队（Enqueue）</strong>: 向队列中添加元素的操作。</li>
<li><strong>出队（Dequeue）</strong>: 从队列中移除元素的操作。</li>
</ul>
<h4 id="C-语言中队列的实现"><a href="#C-语言中队列的实现" class="headerlink" title="C 语言中队列的实现"></a>C 语言中队列的实现</h4><p>队列同样可以使用数组或链表来实现。这里我们主要介绍基于<strong>链表</strong>的实现，因为它能更好地处理队列的动态增长和收缩。</p>
<p>为了高效地进行入队（在队尾插入）和出队（在队头删除），我们通常会维护两个指针：一个指向队头（<code>front</code>），一个指向队尾（<code>rear</code>）。</p>
<h5 id="队列节点定义"><a href="#队列节点定义" class="headerlink" title="队列节点定义"></a>队列节点定义</h5><p>与栈类似，使用单向链表节点即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列结构体，包含队头和队尾指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    QueueNode *front; <span class="comment">// 队头指针</span></span><br><span class="line">    QueueNode *rear;  <span class="comment">// 队尾指针</span></span><br><span class="line">&#125; Queue;</span><br></pre></td></tr></table></figure>

<h5 id="队列的初始化"><a href="#队列的初始化" class="headerlink" title="队列的初始化"></a>队列的初始化</h5><p>初始化时，队头和队尾指针都指向 <code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空队列</span></span><br><span class="line">Queue* <span class="title function_">initQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="入队操作-Enqueue"><a href="#入队操作-Enqueue" class="headerlink" title="入队操作 (Enqueue)"></a>入队操作 (Enqueue)</h5><p>新元素总是添加到队尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队操作：向队列中添加元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* q, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    QueueNode* newNode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 新节点总是队列的最后一个，所以next为NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果队列为空</span></span><br><span class="line">        q-&gt;front = newNode; <span class="comment">// 新节点既是队头也是队尾</span></span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next = newNode; <span class="comment">// 原队尾的next指向新节点</span></span><br><span class="line">        q-&gt;rear = newNode;       <span class="comment">// 更新队尾为新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 入队。\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="出队操作-Dequeue"><a href="#出队操作-Dequeue" class="headerlink" title="出队操作 (Dequeue)"></a>出队操作 (Dequeue)</h5><p>从队头移除元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出队操作：从队列中移除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空，无法出队！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* temp = q-&gt;front; <span class="comment">// 临时保存队头</span></span><br><span class="line">    <span class="type">int</span> dequeuedValue = temp-&gt;data; <span class="comment">// 获取队头数据</span></span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next;   <span class="comment">// 队头下移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果队列出队后变为空</span></span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>;     <span class="comment">// 队尾也设为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp); <span class="comment">// 释放原队头内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 出队。\n&quot;</span>, dequeuedValue);</span><br><span class="line">    <span class="keyword">return</span> dequeuedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查看队头元素-Front"><a href="#查看队头元素-Front" class="headerlink" title="查看队头元素 (Front)"></a>查看队头元素 (Front)</h5><p>不移除元素，只返回队头元素的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队头元素（不移除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">front</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空，无法查看队头元素！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="判断队列是否为空-isEmpty"><a href="#判断队列是否为空-isEmpty" class="headerlink" title="判断队列是否为空 (isEmpty)"></a>判断队列是否为空 (isEmpty)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isQueueEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历队列并打印数据"><a href="#遍历队列并打印数据" class="headerlink" title="遍历队列并打印数据"></a>遍历队列并打印数据</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印队列所有节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    QueueNode* current = q-&gt;front;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列内容（从队头到队尾）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放队列内存"><a href="#释放队列内存" class="headerlink" title="释放队列内存"></a>释放队列内存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放队列所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    QueueNode* current = q-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        QueueNode* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">// 最后释放队列结构体本身</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整队列示例代码"><a href="#完整队列示例代码" class="headerlink" title="完整队列示例代码"></a>完整队列示例代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列结构体，包含队头和队尾指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    QueueNode *front; <span class="comment">// 队头指针</span></span><br><span class="line">    QueueNode *rear;  <span class="comment">// 队尾指针</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空队列</span></span><br><span class="line">Queue* <span class="title function_">initQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队操作：向队列中添加元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* q, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    QueueNode* newNode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果队列为空</span></span><br><span class="line">        q-&gt;front = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 入队。\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队操作：从队列中移除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空，无法出队！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* temp = q-&gt;front;</span><br><span class="line">    <span class="type">int</span> dequeuedValue = temp-&gt;data;</span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果队列出队后变为空</span></span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 出队。\n&quot;</span>, dequeuedValue);</span><br><span class="line">    <span class="keyword">return</span> dequeuedValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看队头元素（不移除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">front</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空，无法查看队头元素！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isQueueEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印队列所有节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    QueueNode* current = q-&gt;front;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列内容（从队头到队尾）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放队列所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    QueueNode* current = q-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        QueueNode* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* myQueue = initQueue(); <span class="comment">// 初始化空队列</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 队列操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列是否为空：%s\n&quot;</span>, isQueueEmpty(myQueue) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">    enqueue(myQueue, <span class="number">100</span>);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line"></span><br><span class="line">    enqueue(myQueue, <span class="number">200</span>);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line"></span><br><span class="line">    enqueue(myQueue, <span class="number">300</span>);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队头元素：%d\n&quot;</span>, front(myQueue));</span><br><span class="line">    dequeue(myQueue);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line"></span><br><span class="line">    dequeue(myQueue);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列是否为空：%s\n&quot;</span>, isQueueEmpty(myQueue) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队头元素：%d\n&quot;</span>, front(myQueue)); <span class="comment">// 此时队列只有一个元素</span></span><br><span class="line">    dequeue(myQueue);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列是否为空：%s\n&quot;</span>, isQueueEmpty(myQueue) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试在空队列上出队或查看队头</span></span><br><span class="line">    <span class="comment">// dequeue(myQueue); // 会导致程序退出</span></span><br><span class="line">    <span class="comment">// front(myQueue);   // 会导致程序退出</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 内存释放 ------\n&quot;</span>);</span><br><span class="line">    enqueue(myQueue, <span class="number">50</span>); <span class="comment">// 再次入队一些元素</span></span><br><span class="line">    enqueue(myQueue, <span class="number">60</span>);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line">    freeQueue(myQueue);</span><br><span class="line">    myQueue = <span class="literal">NULL</span>; <span class="comment">// 释放后将队列指针设为NULL</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试打印已释放的队列</span></span><br><span class="line">    <span class="comment">// printQueue(myQueue); // 会导致段错误，因为q已是NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-十字链表" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/" class="article-date">
      <time datetime="2025-05-30T12:54:56.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/">十字链表</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="稀疏矩阵的优雅表示：深入理解“十字链表”"><a href="#稀疏矩阵的优雅表示：深入理解“十字链表”" class="headerlink" title="稀疏矩阵的优雅表示：深入理解“十字链表”"></a>稀疏矩阵的优雅表示：深入理解“十字链表”</h2><h3 id="1-为什么需要十字链表？"><a href="#1-为什么需要十字链表？" class="headerlink" title="1. 为什么需要十字链表？"></a>1. 为什么需要十字链表？</h3><p>考虑一个 1000×1000 的矩阵，如果它只有 100 个非零元素，却要占用 1000×1000×sizeof(int) 字节的内存（假设整型）。这无疑是巨大的浪费。为了解决这个问题，我们需要只存储非零元素。</p>
<p>传统的稀疏矩阵存储方式还有：</p>
<ul>
<li><strong>三元组表（Triplet Form）：</strong> 存储非零元素的 (行，列，值) 三元组，但查找和修改某个元素不方便。</li>
<li><strong>行主序链表：</strong> 每行一个链表，存储该行的非零元素。</li>
<li><strong>列主序链表：</strong> 每列一个链表，存储该列的非零元素。</li>
</ul>
<p>三元组表不利于矩阵的加法、乘法等操作；行主序链表在按列访问时效率低下，反之亦然。<strong>十字链表</strong>则巧妙地解决了这些问题，它允许我们既能按行遍历，也能按列遍历非零元素。</p>
<h3 id="2-十字链表的核心思想与节点结构"><a href="#2-十字链表的核心思想与节点结构" class="headerlink" title="2. 十字链表的核心思想与节点结构"></a>2. 十字链表的核心思想与节点结构</h3><p>十字链表的核心思想是：<strong>每个非零元素都存储在一个节点中，并且这个节点同时连接着它所在行的下一个非零元素和它所在列的下一个非零元素。</strong></p>
<p>它通过在矩阵的行和列方向上分别构建链表，将行链表和列链表“交叉”起来，从而形成一个十字形结构。</p>
<p><strong>十字链表的基本组成部分：</strong></p>
<ol>
<li><strong>行&#x2F;列头节点（Row&#x2F;Column Head Node）：</strong> 用于管理每一行或每一列的非零元素链表。它们通常构成一个头节点数组（或链表），其中每个头节点都包含指向该行&#x2F;列第一个非零元素的指针。<ul>
<li>为了统一表示，我们通常也会把行&#x2F;列头节点看作是特殊类型的节点。</li>
</ul>
</li>
<li><strong>元素节点（Element Node）：</strong> 存储非零元素的信息，并包含四个指针：<ul>
<li><code>row</code>: 非零元素所在的行索引。</li>
<li><code>col</code>: 非零元素所在的列索引。</li>
<li><code>value</code>: 非零元素的值。</li>
<li><code>right</code>: 指向同一行中下一个非零元素的指针。</li>
<li><code>down</code>: 指向同一列中下一个非零元素的指针。</li>
</ul>
</li>
</ol>
<p><strong>节点结构体定义：</strong></p>
<p>为了简化，我们可以将所有节点统一为一种类型，并使用一个标志位来区分是头节点还是元素节点，或者更常见地，使用两种不同的结构体，或者在一个统一的结构体中只在元素节点中存储 <code>value</code>。这里我们采用一种更灵活的定义，它可以表示普通元素节点，也可以表示行&#x2F;列头节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义稀疏矩阵的节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> row;       <span class="comment">// 行索引</span></span><br><span class="line">    <span class="type">int</span> col;       <span class="comment">// 列索引</span></span><br><span class="line">    <span class="type">int</span> value;     <span class="comment">// 存储的非零元素值（仅对元素节点有效）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">right</span>;</span> <span class="comment">// 指向同一行下一个非零元素的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">down</span>;</span>  <span class="comment">// 指向同一列下一个非零元素的指针</span></span><br><span class="line">&#125; OLNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义稀疏矩阵的十字链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CrossList</span> &#123;</span></span><br><span class="line">    OLNode** row_heads;   <span class="comment">// 行头节点数组</span></span><br><span class="line">    OLNode** col_heads;   <span class="comment">// 列头节点数组</span></span><br><span class="line">    <span class="type">int</span> rows;             <span class="comment">// 矩阵的行数</span></span><br><span class="line">    <span class="type">int</span> cols;             <span class="comment">// 矩阵的列数</span></span><br><span class="line">    <span class="type">int</span> num_elements;     <span class="comment">// 非零元素的数量</span></span><br><span class="line">&#125; CrossList;</span><br></pre></td></tr></table></figure>

<h3 id="3-十字链表的基本操作"><a href="#3-十字链表的基本操作" class="headerlink" title="3. 十字链表的基本操作"></a>3. 十字链表的基本操作</h3><h4 id="3-1-初始化十字链表"><a href="#3-1-初始化十字链表" class="headerlink" title="3.1 初始化十字链表"></a>3.1 初始化十字链表</h4><p>创建矩阵结构，并初始化行头节点数组和列头节点数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空的十字链表</span></span><br><span class="line">CrossList* <span class="title function_">initCrossList</span><span class="params">(<span class="type">int</span> m_rows, <span class="type">int</span> m_cols)</span> &#123;</span><br><span class="line">    CrossList* matrix = (CrossList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CrossList));</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    matrix-&gt;rows = m_rows;</span><br><span class="line">    matrix-&gt;cols = m_cols;</span><br><span class="line">    matrix-&gt;num_elements = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配行头节点数组</span></span><br><span class="line">    matrix-&gt;row_heads = (OLNode**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode*) * m_rows);</span><br><span class="line">    <span class="keyword">if</span> (matrix-&gt;row_heads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_rows; i++) &#123;</span><br><span class="line">        matrix-&gt;row_heads[i] = <span class="literal">NULL</span>; <span class="comment">// 初始化行链表为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配列头节点数组</span></span><br><span class="line">    matrix-&gt;col_heads = (OLNode**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode*) * m_cols);</span><br><span class="line">    <span class="keyword">if</span> (matrix-&gt;col_heads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_cols; i++) &#123;</span><br><span class="line">        matrix-&gt;col_heads[i] = <span class="literal">NULL</span>; <span class="comment">// 初始化列链表为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-插入非零元素"><a href="#3-2-插入非零元素" class="headerlink" title="3.2 插入非零元素"></a>3.2 插入非零元素</h4><p>插入是十字链表的核心操作。每插入一个元素，都需要将其正确地插入到其对应行的链表和列的链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一个非零元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertElement</span><span class="params">(CrossList* matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= matrix-&gt;rows || col &lt; <span class="number">0</span> || col &gt;= matrix-&gt;cols) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入失败：索引越界。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123; <span class="comment">// 零元素不存储</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OLNode* newNode = (OLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;row = row;</span><br><span class="line">    newNode-&gt;col = col;</span><br><span class="line">    newNode-&gt;value = value;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 插入到行链表</span></span><br><span class="line">    <span class="comment">// 找到该行中，比新节点列索引小的最后一个节点，或找到该行链表头</span></span><br><span class="line">    OLNode* p_row = matrix-&gt;row_heads[row];</span><br><span class="line">    <span class="keyword">if</span> (p_row == <span class="literal">NULL</span> || p_row-&gt;col &gt; col) &#123; <span class="comment">// 当前行无节点或新节点应作为第一个</span></span><br><span class="line">        newNode-&gt;right = p_row;</span><br><span class="line">        matrix-&gt;row_heads[row] = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p_row-&gt;right != <span class="literal">NULL</span> &amp;&amp; p_row-&gt;right-&gt;col &lt; col) &#123;</span><br><span class="line">            p_row = p_row-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理重复元素：如果已存在相同位置的元素，则更新值</span></span><br><span class="line">        <span class="keyword">if</span> (p_row-&gt;right != <span class="literal">NULL</span> &amp;&amp; p_row-&gt;right-&gt;col == col) &#123;</span><br><span class="line">            p_row-&gt;right-&gt;value = value; <span class="comment">// 更新值</span></span><br><span class="line">            <span class="built_in">free</span>(newNode); <span class="comment">// 新节点不再需要</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入到正确位置</span></span><br><span class="line">        newNode-&gt;right = p_row-&gt;right;</span><br><span class="line">        p_row-&gt;right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 插入到列链表 (与行链表类似)</span></span><br><span class="line">    OLNode* p_col = matrix-&gt;col_heads[col];</span><br><span class="line">    <span class="keyword">if</span> (p_col == <span class="literal">NULL</span> || p_col-&gt;row &gt; row) &#123; <span class="comment">// 当前列无节点或新节点应作为第一个</span></span><br><span class="line">        newNode-&gt;down = p_col;</span><br><span class="line">        matrix-&gt;col_heads[col] = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p_col-&gt;down != <span class="literal">NULL</span> &amp;&amp; p_col-&gt;down-&gt;row &lt; row) &#123;</span><br><span class="line">            p_col = p_col-&gt;down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意：这里不用处理重复元素了，因为行链表已经处理过了</span></span><br><span class="line">        newNode-&gt;down = p_col-&gt;down;</span><br><span class="line">        p_col-&gt;down = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix-&gt;num_elements++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-打印矩阵（遍历）"><a href="#3-3-打印矩阵（遍历）" class="headerlink" title="3.3 打印矩阵（遍历）"></a>3.3 打印矩阵（遍历）</h4><p>十字链表可以方便地按行或按列遍历非零元素，甚至可以还原出完整的矩阵。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印矩阵（按行遍历非零元素）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMatrixByRow</span><span class="params">(CrossList* matrix)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按行打印稀疏矩阵的非零元素 (row, col, value):\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix-&gt;rows; i++) &#123;</span><br><span class="line">        OLNode* current = matrix-&gt;row_heads[i];</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d, %d) &quot;</span>, current-&gt;row, current-&gt;col, current-&gt;value);</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印矩阵（还原完整矩阵）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printFullMatrix</span><span class="params">(CrossList* matrix)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;完整矩阵：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix-&gt;rows; i++) &#123;</span><br><span class="line">        OLNode* current_row_node = matrix-&gt;row_heads[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix-&gt;cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current_row_node != <span class="literal">NULL</span> &amp;&amp; current_row_node-&gt;col == j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current_row_node-&gt;value);</span><br><span class="line">                current_row_node = current_row_node-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>); <span class="comment">// 没有非零元素，打印0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-查找元素"><a href="#3-4-查找元素" class="headerlink" title="3.4 查找元素"></a>3.4 查找元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找某个位置的元素值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getElement</span><span class="params">(CrossList* matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= matrix-&gt;rows || col &lt; <span class="number">0</span> || col &gt;= matrix-&gt;cols) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败：索引越界。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 假定超出范围是0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OLNode* current = matrix-&gt;row_heads[row]; <span class="comment">// 从行头开始查找</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;col &lt; col) &#123;</span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;col == col) &#123;</span><br><span class="line">        <span class="keyword">return</span> current-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未找到，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-删除元素"><a href="#3-5-删除元素" class="headerlink" title="3.5 删除元素"></a>3.5 删除元素</h4><p>删除元素相对复杂，需要同时更新行链表和列链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除一个非零元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteElement</span><span class="params">(CrossList* matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= matrix-&gt;rows || col &lt; <span class="number">0</span> || col &gt;= matrix-&gt;cols) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败：索引越界。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OLNode* nodeToDelete = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 从行链表中删除</span></span><br><span class="line">    OLNode* prev_row = <span class="literal">NULL</span>;</span><br><span class="line">    OLNode* current_row = matrix-&gt;row_heads[row];</span><br><span class="line">    <span class="keyword">while</span> (current_row != <span class="literal">NULL</span> &amp;&amp; current_row-&gt;col &lt; col) &#123;</span><br><span class="line">        prev_row = current_row;</span><br><span class="line">        current_row = current_row-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current_row != <span class="literal">NULL</span> &amp;&amp; current_row-&gt;col == col) &#123;</span><br><span class="line">        nodeToDelete = current_row; <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev_row == <span class="literal">NULL</span>) &#123; <span class="comment">// 删除的是行头</span></span><br><span class="line">            matrix-&gt;row_heads[row] = current_row-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev_row-&gt;right = current_row-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到 (%d, %d) 处的非零元素。\n&quot;</span>, row, col);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 未找到，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从列链表中删除</span></span><br><span class="line">    OLNode* prev_col = <span class="literal">NULL</span>;</span><br><span class="line">    OLNode* current_col = matrix-&gt;col_heads[col];</span><br><span class="line">    <span class="keyword">while</span> (current_col != <span class="literal">NULL</span> &amp;&amp; current_col-&gt;row &lt; row) &#123;</span><br><span class="line">        prev_col = current_col;</span><br><span class="line">        current_col = current_col-&gt;down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 current_col 应该就是 nodeToDelete (因为行和列都指向同一个节点)</span></span><br><span class="line">    <span class="keyword">if</span> (current_col != <span class="literal">NULL</span> &amp;&amp; current_col-&gt;row == row &amp;&amp; current_col-&gt;col == col) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev_col == <span class="literal">NULL</span>) &#123; <span class="comment">// 删除的是列头</span></span><br><span class="line">            matrix-&gt;col_heads[col] = current_col-&gt;down;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev_col-&gt;down = current_col-&gt;down;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(nodeToDelete); <span class="comment">// 释放节点内存</span></span><br><span class="line">    matrix-&gt;num_elements--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功删除元素 (%d, %d)。\n&quot;</span>, row, col);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-6-释放内存"><a href="#3-6-释放内存" class="headerlink" title="3.6 释放内存"></a>3.6 释放内存</h4><p>释放所有元素节点和头节点数组的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放十字链表占用的所有内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeCrossList</span><span class="params">(CrossList* matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有元素节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix-&gt;rows; i++) &#123;</span><br><span class="line">        OLNode* current = matrix-&gt;row_heads[i];</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            OLNode* temp = current;</span><br><span class="line">            current = current-&gt;right; <span class="comment">// 先移动到下一个，因为当前节点可能被其他行/列引用</span></span><br><span class="line">            <span class="comment">// 如果是双向链表，需要判断是否已经被释放过</span></span><br><span class="line">            <span class="comment">// 对于十字链表，一个节点只被释放一次。我们按行释放即可。</span></span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放行头和列头数组本身</span></span><br><span class="line">    <span class="built_in">free</span>(matrix-&gt;row_heads);</span><br><span class="line">    <span class="built_in">free</span>(matrix-&gt;col_heads);</span><br><span class="line">    <span class="built_in">free</span>(matrix);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十字链表内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-完整示例代码"><a href="#4-完整示例代码" class="headerlink" title="4. 完整示例代码"></a>4. 完整示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义稀疏矩阵的节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> row;       <span class="comment">// 行索引</span></span><br><span class="line">    <span class="type">int</span> col;       <span class="comment">// 列索引</span></span><br><span class="line">    <span class="type">int</span> value;     <span class="comment">// 存储的非零元素值</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">right</span>;</span> <span class="comment">// 指向同一行下一个非零元素的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">down</span>;</span>  <span class="comment">// 指向同一列下一个非零元素的指针</span></span><br><span class="line">&#125; OLNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义稀疏矩阵的十字链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CrossList</span> &#123;</span></span><br><span class="line">    OLNode** row_heads;   <span class="comment">// 行头节点数组</span></span><br><span class="line">    OLNode** col_heads;   <span class="comment">// 列头节点数组</span></span><br><span class="line">    <span class="type">int</span> rows;             <span class="comment">// 矩阵的行数</span></span><br><span class="line">    <span class="type">int</span> cols;             <span class="comment">// 矩阵的列数</span></span><br><span class="line">    <span class="type">int</span> num_elements;     <span class="comment">// 非零元素的数量</span></span><br><span class="line">&#125; CrossList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空的十字链表</span></span><br><span class="line">CrossList* <span class="title function_">initCrossList</span><span class="params">(<span class="type">int</span> m_rows, <span class="type">int</span> m_cols)</span> &#123;</span><br><span class="line">    CrossList* matrix = (CrossList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CrossList));</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    matrix-&gt;rows = m_rows;</span><br><span class="line">    matrix-&gt;cols = m_cols;</span><br><span class="line">    matrix-&gt;num_elements = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    matrix-&gt;row_heads = (OLNode**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode*) * m_rows);</span><br><span class="line">    <span class="keyword">if</span> (matrix-&gt;row_heads == <span class="literal">NULL</span>) &#123; <span class="comment">/* handle error */</span> &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_rows; i++) &#123;</span><br><span class="line">        matrix-&gt;row_heads[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix-&gt;col_heads = (OLNode**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode*) * m_cols);</span><br><span class="line">    <span class="keyword">if</span> (matrix-&gt;col_heads == <span class="literal">NULL</span>) &#123; <span class="comment">/* handle error */</span> &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_cols; i++) &#123;</span><br><span class="line">        matrix-&gt;col_heads[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个非零元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertElement</span><span class="params">(CrossList* matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= matrix-&gt;rows || col &lt; <span class="number">0</span> || col &gt;= matrix-&gt;cols) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入失败：索引越界 (%d, %d)。\n&quot;</span>, row, col);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果插入0，则尝试删除该位置的现有元素 (如果存在)</span></span><br><span class="line">        <span class="comment">// 简化起见，这里假设用户不会插入0，如果需要，可以调用 deleteElement</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OLNode* newNode = (OLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;row = row;</span><br><span class="line">    newNode-&gt;col = col;</span><br><span class="line">    newNode-&gt;value = value;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 插入到行链表 (保持按列索引升序)</span></span><br><span class="line">    OLNode* p_row = matrix-&gt;row_heads[row];</span><br><span class="line">    OLNode* prev_row = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p_row != <span class="literal">NULL</span> &amp;&amp; p_row-&gt;col &lt; col) &#123;</span><br><span class="line">        prev_row = p_row;</span><br><span class="line">        p_row = p_row-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果该位置已存在元素，则更新其值并释放新节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_row != <span class="literal">NULL</span> &amp;&amp; p_row-&gt;col == col) &#123;</span><br><span class="line">        p_row-&gt;value = value; <span class="comment">// 更新值</span></span><br><span class="line">        <span class="built_in">free</span>(newNode);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点到行链表</span></span><br><span class="line">    <span class="keyword">if</span> (prev_row == <span class="literal">NULL</span>) &#123; <span class="comment">// 插入到行头</span></span><br><span class="line">        newNode-&gt;right = matrix-&gt;row_heads[row];</span><br><span class="line">        matrix-&gt;row_heads[row] = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode-&gt;right = prev_row-&gt;right;</span><br><span class="line">        prev_row-&gt;right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 插入到列链表 (保持按行索引升序)</span></span><br><span class="line">    OLNode* p_col = matrix-&gt;col_heads[col];</span><br><span class="line">    OLNode* prev_col = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p_col != <span class="literal">NULL</span> &amp;&amp; p_col-&gt;row &lt; row) &#123;</span><br><span class="line">        prev_col = p_col;</span><br><span class="line">        p_col = p_col-&gt;down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点到列链表</span></span><br><span class="line">    <span class="keyword">if</span> (prev_col == <span class="literal">NULL</span>) &#123; <span class="comment">// 插入到列头</span></span><br><span class="line">        newNode-&gt;down = matrix-&gt;col_heads[col];</span><br><span class="line">        matrix-&gt;col_heads[col] = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode-&gt;down = prev_col-&gt;down;</span><br><span class="line">        prev_col-&gt;down = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix-&gt;num_elements++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某个位置的元素值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getElement</span><span class="params">(CrossList* matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= matrix-&gt;rows || col &lt; <span class="number">0</span> || col &gt;= matrix-&gt;cols) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败：索引越界。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 假定超出范围是0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OLNode* current = matrix-&gt;row_heads[row]; <span class="comment">// 从行头开始查找</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;col &lt; col) &#123;</span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;col == col) &#123;</span><br><span class="line">        <span class="keyword">return</span> current-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未找到，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个非零元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteElement</span><span class="params">(CrossList* matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= matrix-&gt;rows || col &lt; <span class="number">0</span> || col &gt;= matrix-&gt;cols) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败：索引越界。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OLNode* nodeToDelete = <span class="literal">NULL</span>; <span class="comment">// 用于最终free的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从行链表中删除</span></span><br><span class="line">    OLNode* prev_row = <span class="literal">NULL</span>;</span><br><span class="line">    OLNode* current_row = matrix-&gt;row_heads[row];</span><br><span class="line">    <span class="keyword">while</span> (current_row != <span class="literal">NULL</span> &amp;&amp; current_row-&gt;col &lt; col) &#123;</span><br><span class="line">        prev_row = current_row;</span><br><span class="line">        current_row = current_row-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (current_row != <span class="literal">NULL</span> &amp;&amp; current_row-&gt;col == col) &#123;</span><br><span class="line">        nodeToDelete = current_row; </span><br><span class="line">        <span class="keyword">if</span> (prev_row == <span class="literal">NULL</span>) &#123; <span class="comment">// 删除的是行头</span></span><br><span class="line">            matrix-&gt;row_heads[row] = current_row-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev_row-&gt;right = current_row-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到 (%d, %d) 处的非零元素进行删除。\n&quot;</span>, row, col);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从列链表中删除 (寻找并跳过该节点)</span></span><br><span class="line">    OLNode* prev_col = <span class="literal">NULL</span>;</span><br><span class="line">    OLNode* current_col = matrix-&gt;col_heads[col];</span><br><span class="line">    <span class="keyword">while</span> (current_col != <span class="literal">NULL</span> &amp;&amp; current_col-&gt;row &lt; row) &#123;</span><br><span class="line">        prev_col = current_col;</span><br><span class="line">        current_col = current_col-&gt;down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 current_col 应该就是 nodeToDelete (因为行和列都指向同一个节点)</span></span><br><span class="line">    <span class="keyword">if</span> (current_col != <span class="literal">NULL</span> &amp;&amp; current_col-&gt;row == row &amp;&amp; current_col-&gt;col == col) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev_col == <span class="literal">NULL</span>) &#123; <span class="comment">// 删除的是列头</span></span><br><span class="line">            matrix-&gt;col_heads[col] = current_col-&gt;down;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev_col-&gt;down = current_col-&gt;down;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(nodeToDelete); <span class="comment">// 释放节点内存</span></span><br><span class="line">    matrix-&gt;num_elements--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功删除元素 (%d, %d)。\n&quot;</span>, row, col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印矩阵（还原完整矩阵）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printFullMatrix</span><span class="params">(CrossList* matrix)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n完整矩阵 (%d x %d):\n&quot;</span>, matrix-&gt;rows, matrix-&gt;cols);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix-&gt;rows; i++) &#123;</span><br><span class="line">        OLNode* current_row_node = matrix-&gt;row_heads[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix-&gt;cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current_row_node != <span class="literal">NULL</span> &amp;&amp; current_row_node-&gt;col == j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%3d &quot;</span>, current_row_node-&gt;value); <span class="comment">// 格式化输出</span></span><br><span class="line">                current_row_node = current_row_node-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%3d &quot;</span>, <span class="number">0</span>); <span class="comment">// 没有非零元素，打印0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放十字链表占用的所有内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeCrossList</span><span class="params">(CrossList* matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有元素节点</span></span><br><span class="line">    <span class="comment">// 只需要按行链表释放即可，因为每个节点只在某个行链表和某个列链表中出现一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix-&gt;rows; i++) &#123;</span><br><span class="line">        OLNode* current = matrix-&gt;row_heads[i];</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            OLNode* temp = current;</span><br><span class="line">            current = current-&gt;right; </span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放行头和列头数组本身</span></span><br><span class="line">    <span class="built_in">free</span>(matrix-&gt;row_heads);</span><br><span class="line">    <span class="built_in">free</span>(matrix-&gt;col_heads);</span><br><span class="line">    <span class="built_in">free</span>(matrix);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十字链表内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> rows = <span class="number">4</span>, cols = <span class="number">5</span>;</span><br><span class="line">    CrossList* sparseMatrix = initCrossList(rows, cols);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 插入元素 ------\n&quot;</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入重复位置元素 (更新):\n&quot;</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 更新 (0,1) 的值</span></span><br><span class="line"></span><br><span class="line">    printFullMatrix(sparseMatrix);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 查找元素 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 (0, 1): %d\n&quot;</span>, getElement(sparseMatrix, <span class="number">0</span>, <span class="number">1</span>)); <span class="comment">// Expected: 100</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 (1, 2): %d\n&quot;</span>, getElement(sparseMatrix, <span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// Expected: 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 (3, 4): %d\n&quot;</span>, getElement(sparseMatrix, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// Expected: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 删除元素 ------\n&quot;</span>);</span><br><span class="line">    deleteElement(sparseMatrix, <span class="number">0</span>, <span class="number">4</span>); <span class="comment">// 删除 (0,4)</span></span><br><span class="line">    printFullMatrix(sparseMatrix);</span><br><span class="line"></span><br><span class="line">    deleteElement(sparseMatrix, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 删除 (1,0)</span></span><br><span class="line">    printFullMatrix(sparseMatrix);</span><br><span class="line"></span><br><span class="line">    deleteElement(sparseMatrix, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 删除不存在的元素</span></span><br><span class="line">    printFullMatrix(sparseMatrix);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 内存释放 ------\n&quot;</span>);</span><br><span class="line">    freeCrossList(sparseMatrix);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-十字链表的优势与应用"><a href="#5-十字链表的优势与应用" class="headerlink" title="5. 十字链表的优势与应用"></a>5. 十字链表的优势与应用</h3><p><strong>优势：</strong></p>
<ul>
<li><strong>空间效率高：</strong> 只存储非零元素，对于稀疏矩阵来说，大大节省了内存空间。</li>
<li><strong>灵活的双向访问：</strong> 既可以高效地按行遍历非零元素，也可以高效地按列遍历非零元素。</li>
<li><strong>插入和删除相对方便：</strong> 相较于三元组表等，插入和删除非零元素（在已知位置时）更为方便，只需调整少数指针。</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>稀疏矩阵的存储和运算：</strong> 矩阵的加法、乘法等运算在十字链表上实现效率更高。</li>
<li><strong>图的邻接多重表表示：</strong> 图的一种特殊存储结构，每个边可以同时存在于两个顶点的邻接链表中，类似于十字链表的思想。</li>
<li><strong>数据挖掘和机器学习：</strong> 处理包含大量零值的矩阵数据，例如协同过滤中的用户-物品评分矩阵。</li>
</ul>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>十字链表是一种为稀疏矩阵量身定制的数据结构。它通过巧妙地将非零元素组织成行链表和列链表的交织结构，实现了空间上的高效利用和访问上的高度灵活性。虽然它的实现比普通链表复杂，但在处理大规模稀疏数据时，其优势显而易见。</p>
<p>理解十字链表的原理和实现，将为你在处理稀疏数据和更复杂的数据结构（如图）时提供强大的工具。</p>
<hr>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-堆" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/%E5%A0%86/" class="article-date">
      <time datetime="2025-05-30T12:52:47.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/%E5%A0%86/">堆</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="揭秘“堆”：高效的优先级队列与排序利器"><a href="#揭秘“堆”：高效的优先级队列与排序利器" class="headerlink" title="揭秘“堆”：高效的优先级队列与排序利器"></a>揭秘“堆”：高效的优先级队列与排序利器</h2><h3 id="1-什么是堆？"><a href="#1-什么是堆？" class="headerlink" title="1. 什么是堆？"></a>1. 什么是堆？</h3><p>堆是一种特殊的<strong>完全二叉树</strong>。它的主要特性是：</p>
<ol>
<li><strong>完全二叉树：</strong> 堆必须是一棵完全二叉树。这意味着除了最后一层，其他层都被完全填满，并且最后一层的节点都尽可能地靠左排列。这种结构使得堆可以用<strong>数组</strong>来高效地表示，无需使用指针，节省了内存空间。<ul>
<li>在一个完全二叉树中，如果一个节点的索引是 i：<ul>
<li>它的左子节点的索引是 2i+1。</li>
<li>它的右子节点的索引是 2i+2。</li>
<li>它的父节点的索引是 (i−1)&#x2F;2（整数除法）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>堆序性（Heap Property）：</strong> 堆中的每个节点都满足特定的顺序关系。根据这个关系，堆可以分为两种：<ul>
<li><strong>最大堆（Max-Heap）：</strong> 每个父节点的值都<strong>大于或等于</strong>其子节点的值。因此，根节点是整个堆中的最大值。</li>
<li><strong>最小堆（Min-Heap）：</strong> 每个父节点的值都<strong>小于或等于</strong>其子节点的值。因此，根节点是整个堆中的最小值。</li>
</ul>
</li>
</ol>
<p>本文后续将以<strong>最小堆</strong>为例进行讲解和实现。</p>
<p><strong>为何用数组表示？</strong></p>
<p>完全二叉树的这种特性使得它的节点可以紧密地存储在一个数组中，而不会有任何空隙。通过简单的数学计算，我们就能找到任何一个节点的父节点或子节点，从而避免了传统树结构中因指针操作带来的额外开销和复杂性。</p>
<h3 id="2-堆的基本操作"><a href="#2-堆的基本操作" class="headerlink" title="2. 堆的基本操作"></a>2. 堆的基本操作</h3><p>堆的核心操作包括：<strong>插入（Insert）</strong> 和 <strong>删除根节点（Extract Min&#x2F;Max）</strong>。这两个操作都通过维护堆的“堆序性”来实现。</p>
<h4 id="2-1-插入操作（Insert）"><a href="#2-1-插入操作（Insert）" class="headerlink" title="2.1 插入操作（Insert）"></a>2.1 插入操作（Insert）</h4><p>向堆中插入一个新元素时，为了保持堆的完全二叉树结构和堆序性，我们通常这样做：</p>
<ol>
<li>将新元素添加到堆的<strong>末尾</strong>（数组的最后一个位置），以保持完全二叉树的特性。</li>
<li>然后，进行**“上浮”（Heapify-up &#x2F; Sift-up &#x2F; Bubble-up）** 操作：将新元素与其父节点进行比较。如果新元素比父节点小（最小堆）或大（最大堆），则交换它们的位置。这个过程重复进行，直到新元素到达正确的位置（满足堆序性）或者到达根节点。</li>
</ol>
<p>这个上浮过程的时间复杂度是 O(logn)，因为每次比较和交换都会使元素向上移动一层。</p>
<h4 id="2-2-删除根节点（Extract-Min-Max）"><a href="#2-2-删除根节点（Extract-Min-Max）" class="headerlink" title="2.2 删除根节点（Extract Min&#x2F;Max）"></a>2.2 删除根节点（Extract Min&#x2F;Max）</h4><p>删除堆中的根节点（例如，从最小堆中取出最小值）是另一个核心操作：</p>
<ol>
<li>取出根节点的值。</li>
<li>为了保持完全二叉树的结构，将堆中的<strong>最后一个元素</strong>移动到根节点的位置。</li>
<li>然后，进行**“下沉”（Heapify-down &#x2F; Sift-down &#x2F; Bubble-down）** 操作：将新根元素与其子节点进行比较。如果它比子节点大（最小堆）或小（最大堆），则与合适的子节点（最小堆选较小的子节点，最大堆选较大的子节点）交换位置。这个过程重复进行，直到元素到达正确的位置（满足堆序性）或者到达叶子节点。</li>
</ol>
<p>这个下沉过程的时间复杂度也是 O(logn)，因为它每次比较和交换都会使元素向下移动一层。</p>
<hr>
<h3 id="3-C-语言实现最小堆"><a href="#3-C-语言实现最小堆" class="headerlink" title="3. C 语言实现最小堆"></a>3. C 语言实现最小堆</h3><p>我们用一个数组来表示堆，并实现其核心操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span> <span class="comment">// for INT_MAX</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_HEAP_SIZE 100 <span class="comment">// 定义堆的最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MinHeap</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>* arr;       <span class="comment">// 存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> capacity;  <span class="comment">// 堆的最大容量</span></span><br><span class="line">    <span class="type">int</span> size;      <span class="comment">// 堆当前元素的数量</span></span><br><span class="line">&#125; MinHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个最小堆</span></span><br><span class="line">MinHeap* <span class="title function_">createMinHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    MinHeap* heap = (MinHeap*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinHeap));</span><br><span class="line">    <span class="keyword">if</span> (heap == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;capacity = capacity;</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * capacity);</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取左子节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取右子节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上浮操作：维护堆的最小堆序性</span></span><br><span class="line"><span class="comment">// 当一个元素被插入到堆的末尾时，需要向上调整它的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapifyUp</span><span class="params">(MinHeap* heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> parentIndex = getParentIndex(index);</span><br><span class="line">    <span class="comment">// 如果当前节点不是根节点，且比父节点小</span></span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; heap-&gt;arr[parentIndex] &gt; heap-&gt;arr[index]) &#123;</span><br><span class="line">        swap(&amp;heap-&gt;arr[index], &amp;heap-&gt;arr[parentIndex]);</span><br><span class="line">        index = parentIndex;</span><br><span class="line">        parentIndex = getParentIndex(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下沉操作：维护堆的最小堆序性</span></span><br><span class="line"><span class="comment">// 当根节点被删除或元素被修改时，需要向下调整它的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapifyDown</span><span class="params">(MinHeap* heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> smallest = index;</span><br><span class="line">    <span class="type">int</span> leftChild = getLeftChildIndex(index);</span><br><span class="line">    <span class="type">int</span> rightChild = getRightChildIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点存在且比当前最小的小</span></span><br><span class="line">    <span class="keyword">if</span> (leftChild &lt; heap-&gt;size &amp;&amp; heap-&gt;arr[leftChild] &lt; heap-&gt;arr[smallest]) &#123;</span><br><span class="line">        smallest = leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点存在且比当前最小的小</span></span><br><span class="line">    <span class="keyword">if</span> (rightChild &lt; heap-&gt;size &amp;&amp; heap-&gt;arr[rightChild] &lt; heap-&gt;arr[smallest]) &#123;</span><br><span class="line">        smallest = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最小的不是当前节点，则交换并继续向下沉</span></span><br><span class="line">    <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">        swap(&amp;heap-&gt;arr[index], &amp;heap-&gt;arr[smallest]);</span><br><span class="line">        heapifyDown(heap, smallest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素到最小堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertMinHeap</span><span class="params">(MinHeap* heap, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size == heap-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆已满，无法插入！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新元素添加到数组末尾</span></span><br><span class="line">    heap-&gt;arr[heap-&gt;size] = value;</span><br><span class="line">    heap-&gt;size++;</span><br><span class="line">    <span class="comment">// 进行上浮操作</span></span><br><span class="line">    heapifyUp(heap, heap-&gt;size - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入 %d 成功。\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取最小元素（根节点）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">extractMin</span><span class="params">(MinHeap* heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆为空，无法提取！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> INT_MAX; <span class="comment">// 返回一个表示错误的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size == <span class="number">1</span>) &#123; <span class="comment">// 只有一个元素</span></span><br><span class="line">        heap-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> heap-&gt;arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存根节点的值</span></span><br><span class="line">    <span class="type">int</span> root = heap-&gt;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 将最后一个元素移动到根节点</span></span><br><span class="line">    heap-&gt;arr[<span class="number">0</span>] = heap-&gt;arr[heap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    heap-&gt;size--;</span><br><span class="line">    <span class="comment">// 进行下沉操作</span></span><br><span class="line">    heapifyDown(heap, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取堆的最小元素（不删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMin</span><span class="params">(MinHeap* heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆为空。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印堆的数组表示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHeap</span><span class="params">(MinHeap* heap)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;堆的数组表示: [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap-&gt;size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, heap-&gt;arr[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; heap-&gt;size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放堆内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeMinHeap</span><span class="params">(MinHeap* heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(heap-&gt;arr);</span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;堆内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MinHeap* myHeap = createMinHeap(MAX_HEAP_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 插入元素 ------\n&quot;</span>);</span><br><span class="line">    insertMinHeap(myHeap, <span class="number">3</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [3]</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">2</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3]</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">15</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3, 15]</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">5</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3, 5, 15]</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">4</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3, 4, 15, 5] (实际为[2, 3, 4, 15, 5]或[2, 5, 4, 15, 3]等，取决于具体路径，但都满足最小堆序性)</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">45</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3, 4, 45, 5, 15]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 提取最小元素 ------\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> minVal = extractMin(myHeap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;提取最小元素: %d\n&quot;</span>, minVal); <span class="comment">// Expected: 2</span></span><br><span class="line">    printHeap(myHeap); <span class="comment">// [3, 5, 4, 45, 15] (根节点变为3，并重新调整)</span></span><br><span class="line"></span><br><span class="line">    minVal = extractMin(myHeap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;提取最小元素: %d\n&quot;</span>, minVal); <span class="comment">// Expected: 3</span></span><br><span class="line">    printHeap(myHeap); <span class="comment">// [4, 5, 15, 45]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 获取最小元素 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前最小元素 (不删除): %d\n&quot;</span>, getMin(myHeap)); <span class="comment">// Expected: 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 释放内存 ------\n&quot;</span>);</span><br><span class="line">    freeMinHeap(myHeap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-堆的应用场景"><a href="#4-堆的应用场景" class="headerlink" title="4. 堆的应用场景"></a>4. 堆的应用场景</h3><p>堆因其高效的插入和删除根节点操作，在许多场景下都非常有用：</p>
<ul>
<li><strong>优先级队列（Priority Queue）：</strong> 这是堆最经典的应用。当需要频繁地获取或处理最高&#x2F;最低优先级的元素时（例如，操作系统的任务调度、事件模拟、图算法中的 Dijkstra 算法和 Prim 算法），堆是最佳选择。</li>
<li><strong>堆排序（Heapsort）：</strong> 一种高效的排序算法，时间复杂度为 O(nlogn)。它通过将待排序元素构建成一个堆，然后重复提取根节点来实现排序。</li>
<li><strong>Top K 问题：</strong> 在大量数据中查找最大&#x2F;最小的 K 个元素。例如，找出成绩最高的 10 个学生，或者找出流量最大的 10 个 IP 地址。可以使用大小为 K 的小顶堆或大顶堆来高效解决。</li>
<li><strong>在线中位数查找：</strong> 结合两个堆（一个最大堆和一个最小堆）可以高效地维护数据流的中位数。</li>
<li><strong>数据压缩（霍夫曼编码）：</strong> 霍夫曼树的构建过程就使用了优先级队列（堆）。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-kmp" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/kmp/" class="article-date">
      <time datetime="2025-05-30T12:50:56.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/kmp/">kmp</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="KMP-算法：字符串匹配的艺术"><a href="#KMP-算法：字符串匹配的艺术" class="headerlink" title="KMP 算法：字符串匹配的艺术"></a>KMP 算法：字符串匹配的艺术</h2><h3 id="1-为什么需要-KMP？暴力匹配的痛点"><a href="#1-为什么需要-KMP？暴力匹配的痛点" class="headerlink" title="1. 为什么需要 KMP？暴力匹配的痛点"></a>1. 为什么需要 KMP？暴力匹配的痛点</h3><p>让我们先回顾一下<strong>暴力匹配</strong>（Brute Force）是如何工作的。假设主串 <code>text = &quot;ABABCABABAB&quot;</code>，模式串 <code>pattern = &quot;ABAB&quot;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">text:    A B A B C A B A B A B</span><br><span class="line">pattern: A B A B</span><br><span class="line">         ^</span><br><span class="line">         (匹配A)</span><br><span class="line"></span><br><span class="line">text:    A B A B C A B A B A B</span><br><span class="line">pattern: A B A B</span><br><span class="line">           ^</span><br><span class="line">           (匹配B)</span><br><span class="line"></span><br><span class="line">text:    A B A B C A B A B A B</span><br><span class="line">pattern: A B A B</span><br><span class="line">             ^</span><br><span class="line">             (匹配A)</span><br><span class="line"></span><br><span class="line">text:    A B A B C A B A B A B</span><br><span class="line">pattern: A B A B</span><br><span class="line">               ^</span><br><span class="line">               (匹配B)</span><br><span class="line"></span><br><span class="line">text:    A B A B C A B A B A B</span><br><span class="line">pattern: A B A B</span><br><span class="line">                 ^</span><br><span class="line">                 (匹配C 与 B 不匹配，模式串整体后移一位，从头开始比较)</span><br><span class="line"></span><br><span class="line">text:    A B A B C A B A B A B</span><br><span class="line">pattern:   A B A B</span><br><span class="line">           ^</span><br><span class="line">           (重新从头开始比较)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当发生不匹配时，暴力匹配会将模式串整体向后移动一位，并重新从模式串的第一个字符开始与主串当前位置的字符进行比较。在最坏情况下（例如 <code>text = &quot;AAAAAAAAB&quot;</code>, <code>pattern = &quot;AAAB&quot;</code>），暴力匹配会进行大量的重复比较，导致时间复杂度高达 O(mn)。</p>
<p>观察上述过程，我们发现一个问题：当 <code>pattern[j]</code> 与 <code>text[i]</code> 不匹配时，我们已经知道 <code>text[i-j ... i-1]</code> 和 <code>pattern[0 ... j-1]</code> 是匹配的。暴力匹配却直接抛弃了这些已匹配的信息，从头再来。KMP 算法正是利用了这些已匹配的信息，避免了主串指针 <code>i</code> 的回溯，从而提高了效率。</p>
<h3 id="2-KMP-算法的核心思想：利用“前缀”和“后缀”"><a href="#2-KMP-算法的核心思想：利用“前缀”和“后缀”" class="headerlink" title="2. KMP 算法的核心思想：利用“前缀”和“后缀”"></a>2. KMP 算法的核心思想：利用“前缀”和“后缀”</h3><p>KMP 算法的关键在于，当模式串与主串发生不匹配时，它不回溯主串的指针，而是根据模式串自身的特点，将模式串向右滑动尽可能远的距离。这个距离的计算依赖于模式串的**“最长公共前后缀”**信息。</p>
<p><strong>什么是“最长公共前后缀”？</strong></p>
<p>对于模式串的任意一个前缀 <code>pattern[0 ... j-1]</code>（即 <code>pattern</code> 的一个子串），我们想找到一个最长的<strong>真前缀</strong>（不包括整个子串本身）和最长的<strong>真后缀</strong>（不包括整个子串本身）是相同的。</p>
<p>例如，模式串 <code>pattern = &quot;ABABA&quot;</code>：</p>
<ul>
<li>当子串是 <code>&quot;A&quot;</code> 时：无公共前后缀。</li>
<li>当子串是 <code>&quot;AB&quot;</code> 时：无公共前后缀。</li>
<li>当子串是 <code>&quot;ABA&quot;</code> 时：前缀 <code>A</code>，后缀 <code>A</code>。最长公共前后缀长度为 1。</li>
<li>当子串是 <code>&quot;ABAB&quot;</code> 时：前缀 <code>A</code>，后缀 <code>B</code>。前缀 <code>AB</code>，后缀 <code>AB</code>。最长公共前后缀长度为 2。</li>
<li>当子串是 <code>&quot;ABABA&quot;</code> 时：前缀 <code>A</code>，后缀 <code>A</code>。前缀 <code>AB</code>，后缀 <code>BA</code>。前缀 <code>ABA</code>，后缀 <code>ABA</code>。最长公共前后缀长度为 3。</li>
</ul>
<p>KMP 算法预处理模式串，生成一个 <code>next</code> 数组（也常被称为 <code>lps</code> 数组，即 Longest Proper Prefix which is also Suffix），这个数组记录了模式串每个前缀的最长公共前后缀的长度。</p>
<h3 id="3-next-数组（或-lps-数组）的构建"><a href="#3-next-数组（或-lps-数组）的构建" class="headerlink" title="3. next 数组（或 lps 数组）的构建"></a>3. <code>next</code> 数组（或 <code>lps</code> 数组）的构建</h3><p>next[j] 表示 pattern[0 … j-1] 这个子串的最长公共前后缀的长度。</p>
<p>约定 next[0] &#x3D; -1 (或 next[0] &#x3D; 0，取决于实现细节)，表示模式串第一个字符失配时，模式串应整体后移一位。</p>
<p>以 <code>pattern = &quot;ABABCABAB&quot;</code> 为例，我们来手动构建 <code>next</code> 数组：</p>
<table>
<thead>
<tr>
<th><strong>索引 j</strong></th>
<th><strong>pattern[j]</strong></th>
<th><strong>pattern[0…j] (子串)</strong></th>
<th><strong>最长公共前后缀 (长度)</strong></th>
<th><strong>next[j+1] (模式串下一个位置的值)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>-</td>
<td>空串</td>
<td>-</td>
<td><code>next[0] = -1</code> (约定)</td>
</tr>
<tr>
<td>0</td>
<td><code>A</code></td>
<td><code>A</code></td>
<td>空串 (0)</td>
<td><code>next[1] = 0</code></td>
</tr>
<tr>
<td>1</td>
<td><code>B</code></td>
<td><code>AB</code></td>
<td>空串 (0)</td>
<td><code>next[2] = 0</code></td>
</tr>
<tr>
<td>2</td>
<td><code>A</code></td>
<td><code>ABA</code></td>
<td><code>A</code> (1)</td>
<td><code>next[3] = 1</code></td>
</tr>
<tr>
<td>3</td>
<td><code>B</code></td>
<td><code>ABAB</code></td>
<td><code>AB</code> (2)</td>
<td><code>next[4] = 2</code></td>
</tr>
<tr>
<td>4</td>
<td><code>C</code></td>
<td><code>ABABC</code></td>
<td>空串 (0)</td>
<td><code>next[5] = 0</code></td>
</tr>
<tr>
<td>5</td>
<td><code>A</code></td>
<td><code>ABabca</code></td>
<td><code>A</code> (1)</td>
<td><code>next[6] = 1</code></td>
</tr>
<tr>
<td>6</td>
<td><code>B</code></td>
<td><code>ABabcAB</code></td>
<td><code>AB</code> (2)</td>
<td><code>next[7] = 2</code></td>
</tr>
<tr>
<td>7</td>
<td><code>A</code></td>
<td><code>ABabcABA</code></td>
<td><code>ABA</code> (3)</td>
<td><code>next[8] = 3</code></td>
</tr>
<tr>
<td>8</td>
<td><code>B</code></td>
<td><code>ABabcABAB</code></td>
<td><code>ABAB</code> (4)</td>
<td><code>next[9] = 4</code></td>
</tr>
</tbody></table>
<p><strong>构建 <code>next</code> 数组的算法：</strong></p>
<p>我们可以使用动态规划的思想来构建 next 数组。</p>
<p>设 next[j] 已经计算好，我们来计算 next[j+1]。</p>
<p>next[j+1] 实际是 pattern[0…j] 这个子串的最长公共前后缀长度。</p>
<ul>
<li>用 <code>k</code> 表示当前已知的最长公共前后缀的长度。初始 <code>k=0</code>。</li>
<li>用 <code>j</code> 遍历模式串的索引。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建 next 数组 (next[i] 表示 pattern[0...i-1] 的最长公共前后缀长度)</span></span><br><span class="line"><span class="comment">// next[0] 通常设为 -1 (或 0)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">computeNextArray</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">int</span> m, <span class="type">int</span>* next)</span> &#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 或 next[0] = 0，取决于后续匹配逻辑</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;   <span class="comment">// k 表示当前已匹配的模式串前缀的长度</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;    <span class="comment">// j 遍历模式串的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m - <span class="number">1</span>) &#123; <span class="comment">// 遍历到 pattern 的倒数第二个字符</span></span><br><span class="line">        <span class="comment">// k == -1 (说明k回溯到-1，或者j=0时) 或 pattern[k] == pattern[j]</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || pattern[k] == pattern[j]) &#123;</span><br><span class="line">            k++; <span class="comment">// 匹配成功，前缀长度增加</span></span><br><span class="line">            j++; <span class="comment">// 模式串的当前字符后移</span></span><br><span class="line">            next[j] = k; <span class="comment">// 更新 next 数组</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配，回溯 k 到 next[k]</span></span><br><span class="line">            <span class="comment">// 这意味着我们尝试用模式串的更短的前缀来匹配</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： 这里的 next 数组定义是 next[j] 表示 pattern[0…j-1] 的最长公共前后缀的长度，即 pattern[j] 失配时，模式串应该移动到 pattern[next[j]] 处继续比较。</p>
<p>或者，更常见的定义是 next[i] 表示 pattern[0…i] 的最长公共前后缀的长度，那么失配时回溯到 next[j-1]。这里我们采用前者，方便后续匹配。</p>
<h3 id="4-KMP-匹配算法"><a href="#4-KMP-匹配算法" class="headerlink" title="4. KMP 匹配算法"></a>4. KMP 匹配算法</h3><p>有了 <code>next</code> 数组，KMP 匹配过程就变得高效了。</p>
<ul>
<li><code>i</code>：主串 <code>text</code> 的当前比较位置。</li>
<li><code>j</code>：模式串 <code>pattern</code> 的当前比较位置。</li>
</ul>
<p><strong>匹配过程：</strong></p>
<ol>
<li><p>当 <code>text[i]</code> 和 <code>pattern[j]</code> 匹配时，<code>i</code> 和 <code>j</code> 同时向后移动一位 (<code>i++</code>, <code>j++</code>)。</p>
</li>
<li><p>当 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text[i]</span><br></pre></td></tr></table></figure>

<p> 和 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern[j]</span><br></pre></td></tr></table></figure>

<p> 不匹配时：</p>
<ul>
<li>如果 <code>j &gt; 0</code>（即不是模式串的第一个字符失配），则将 <code>j</code> 更新为 <code>next[j]</code>。这表示我们将模式串向右滑动，使得 <code>pattern[0 ... next[j]-1]</code> 与 <code>text[i - next[j] ... i-1]</code> 保持对齐，然后从 <code>pattern[next[j]]</code> 处开始重新比较。主串指针 <code>i</code> <strong>不回溯</strong>。</li>
<li>如果 <code>j = 0</code>（即模式串的第一个字符就失配），则只将 <code>i</code> 向后移动一位 (<code>i++</code>)，<code>j</code> 保持为 0（模式串整体后移一位，从头开始比较）。</li>
</ul>
</li>
</ol>
<p>当 <code>j</code> 等于模式串的长度 <code>m</code> 时，表示找到了一个匹配。此时，<code>text</code> 中匹配的起始位置是 <code>i - m</code>。找到后，为了寻找下一个匹配，我们将 <code>j</code> 更新为 <code>next[j]</code> (即 <code>next[m]</code>)，然后继续匹配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP 字符串匹配算法</span></span><br><span class="line"><span class="comment">// 返回模式串在主串中第一次出现的起始索引，未找到则返回 -1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">const</span> <span class="type">char</span>* pattern)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>; <span class="comment">// 主串长度</span></span><br><span class="line">    <span class="keyword">while</span> (text[n] != <span class="string">&#x27;\0&#x27;</span>) n++;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>; <span class="comment">// 模式串长度</span></span><br><span class="line">    <span class="keyword">while</span> (pattern[m] != <span class="string">&#x27;\0&#x27;</span>) m++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 空模式串总是在0位置匹配</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 空主串无法匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* next = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 构建 next 数组</span></span><br><span class="line">    computeNextArray(pattern, m, next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. KMP 匹配过程</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 主串指针</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 模式串指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 当 pattern[j] 和 text[i] 匹配时，或 j 已经回溯到 -1 (模式串整体右移)</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || text[i] == pattern[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配，根据 next 数组移动模式串指针 j</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了一个匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">            <span class="keyword">return</span> i - m; <span class="comment">// 返回匹配的起始位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 未找到匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-完整-C-语言代码示例"><a href="#5-完整-C-语言代码示例" class="headerlink" title="5. 完整 C 语言代码示例"></a>5. 完整 C 语言代码示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// for strlen</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 next 数组 (next[j] 表示 pattern[0...j-1] 的最长公共前后缀长度)</span></span><br><span class="line"><span class="comment">// next[0] 设为 -1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">computeNextArray</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">int</span> m, <span class="type">int</span>* next)</span> &#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 哨兵值，表示模式串第一个字符失配时，主串指针 i 向右移，模式串从头开始</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;   <span class="comment">// k 表示当前已匹配的模式串前缀的长度</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;    <span class="comment">// j 遍历模式串的索引 (pattern[j] 是当前正在考察的字符)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m - <span class="number">1</span>) &#123; <span class="comment">// 遍历到 pattern 的倒数第二个字符</span></span><br><span class="line">        <span class="comment">// 如果 k == -1 (说明模式串已完全回溯，或者 j=0 时)</span></span><br><span class="line">        <span class="comment">// 或者当前考察的字符 pattern[j] 与模式串的第 k 个字符 pattern[k] 相同</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || pattern[k] == pattern[j]) &#123;</span><br><span class="line">            k++; <span class="comment">// 匹配成功，前缀长度 k 增加</span></span><br><span class="line">            j++; <span class="comment">// 模式串的当前字符 j 增加</span></span><br><span class="line">            next[j] = k; <span class="comment">// 更新 next 数组</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配，回溯 k 到 next[k]</span></span><br><span class="line">            <span class="comment">// 尝试用模式串的更短的前缀来匹配</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 字符串匹配算法</span></span><br><span class="line"><span class="comment">// 返回模式串在主串中第一次出现的起始索引，未找到则返回 -1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">const</span> <span class="type">char</span>* pattern)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 空模式串总是在0位置匹配</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 空主串无法匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* next = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 构建 next 数组</span></span><br><span class="line">    computeNextArray(pattern, m, next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. KMP 匹配过程</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 主串指针</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 模式串指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 当 pattern[j] 和 text[i] 匹配时，或 j 已经回溯到 -1 (模式串整体右移)</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || text[i] == pattern[j]) &#123;</span><br><span class="line">            i++; <span class="comment">// 主串指针前进</span></span><br><span class="line">            j++; <span class="comment">// 模式串指针前进</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配，根据 next 数组移动模式串指针 j</span></span><br><span class="line">            <span class="comment">// 主串指针 i 不回溯</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了一个匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">            <span class="keyword">return</span> i - m; <span class="comment">// 返回匹配的起始位置 (i 是匹配结束的后一个位置)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 未找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text1 = <span class="string">&quot;ABABCABABAB&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern1 = <span class="string">&quot;ABAB&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index1 = kmpSearch(text1, pattern1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在 \&quot;%s\&quot; 中查找 \&quot;%s\&quot;，第一次出现位置: %d\n&quot;</span>, text1, pattern1, index1); <span class="comment">// Expected: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text2 = <span class="string">&quot;ABCDEFGH&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern2 = <span class="string">&quot;FGH&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index2 = kmpSearch(text2, pattern2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在 \&quot;%s\&quot; 中查找 \&quot;%s\&quot;，第一次出现位置: %d\n&quot;</span>, text2, pattern2, index2); <span class="comment">// Expected: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text3 = <span class="string">&quot;AAAAAAAAB&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern3 = <span class="string">&quot;AAAB&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index3 = kmpSearch(text3, pattern3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在 \&quot;%s\&quot; 中查找 \&quot;%s\&quot;，第一次出现位置: %d\n&quot;</span>, text3, pattern3, index3); <span class="comment">// Expected: 4</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text4 = <span class="string">&quot;HELLO WORLD&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern4 = <span class="string">&quot;XYZ&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index4 = kmpSearch(text4, pattern4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在 \&quot;%s\&quot; 中查找 \&quot;%s\&quot;，第一次出现位置: %d\n&quot;</span>, text4, pattern4, index4); <span class="comment">// Expected: -1</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text5 = <span class="string">&quot;ABCBABCDABCD&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern5 = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index5 = kmpSearch(text5, pattern5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在 \&quot;%s\&quot; 中查找 \&quot;%s\&quot;，第一次出现位置: %d\n&quot;</span>, text5, pattern5, index5); <span class="comment">// Expected: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-KMP-算法的优势与复杂度分析"><a href="#6-KMP-算法的优势与复杂度分析" class="headerlink" title="6. KMP 算法的优势与复杂度分析"></a>6. KMP 算法的优势与复杂度分析</h3><ul>
<li><strong>时间复杂度：</strong><ul>
<li>构建 <code>next</code> 数组：O(m)，其中 m 是模式串的长度。</li>
<li>匹配过程：O(n)，其中 n 是主串的长度。主串指针 <code>i</code> 永不回溯，模式串指针 <code>j</code> 最多回溯 m 次（每次回溯都会导致 <code>j</code> 减小），但每次 <code>i</code> 和 <code>j</code> 至少有一个会前进，所以总操作次数是线性的。</li>
<li><strong>总时间复杂度：*<em>O(m+n)*</em></strong>。</li>
</ul>
</li>
<li><strong>空间复杂度：</strong><ul>
<li>O(m)，用于存储 <code>next</code> 数组。</li>
</ul>
</li>
</ul>
<p><strong>与暴力匹配相比，KMP 算法的优势在于：</strong> 它在模式串与主串发生不匹配时，能够利用已匹配的模式串前缀信息，避免主串指针的回溯，从而在最坏情况下也能保持线性时间复杂度。这使得它在处理长文本和重复模式的字符串匹配问题时表现出色。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-DP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/DP/" class="article-date">
      <time datetime="2025-05-30T12:33:08.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/DP/">DP</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="1-爬楼梯"><a href="#1-爬楼梯" class="headerlink" title="1. 爬楼梯"></a>1. 爬楼梯</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<ul>
<li><strong>DP 状态：</strong> <code>dp[i]</code> 表示爬到第 <code>i</code> 阶楼梯的方法数。</li>
<li><strong>状态转移方程：</strong> 爬到第 <code>i</code> 阶，可以从 <code>i-1</code> 阶爬 1 步上来，也可以从 <code>i-2</code> 阶爬 2 步上来。所以 <code>dp[i] = dp[i-1] + dp[i-2]</code>。</li>
<li><strong>初始状态：</strong> <code>dp[0] = 1</code> (到达第 0 阶，视为一种方法)，<code>dp[1] = 1</code> (到达第 1 阶，只有一种方法)。</li>
<li><strong>遍历顺序：</strong> 从 <code>i = 2</code> 到 <code>n</code> 递增。</li>
</ul>
<h4 id="2-最长公共子序列（Longest-Common-Subsequence-LCS）"><a href="#2-最长公共子序列（Longest-Common-Subsequence-LCS）" class="headerlink" title="2. 最长公共子序列（Longest Common Subsequence, LCS）"></a>2. 最长公共子序列（Longest Common Subsequence, LCS）</h4><p>给定两个字符串 S1 和 S2，找到这两个字符串的最长公共子序列的长度。子序列不要求连续。</p>
<ul>
<li><strong>DP 状态：</strong> <code>dp[i][j]</code> 表示字符串 S1 的前 i 个字符和字符串 S2 的前 j 个字符的最长公共子序列的长度。</li>
<li>状态转移方程：<ul>
<li>如果 S1[i−1]&#x3D;&#x3D;S2[j−1] （当前字符相等），那么 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li>
<li>如果 S1[i−1]!&#x3D;S2[j−1] （当前字符不相等），那么 <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code> (取两者中较大的)。</li>
</ul>
</li>
<li><strong>初始状态：</strong> <code>dp[0][j] = 0</code> (S1 为空)，<code>dp[i][0] = 0</code> (S2 为空)。</li>
<li><strong>遍历顺序：</strong> 外层循环 i 从 1 到 len(S1)，内层循环 j 从 1 到 len(S2)。</li>
</ul>
<h3 id="3-0-1-背包问题"><a href="#3-0-1-背包问题" class="headerlink" title="3. 0-1 背包问题"></a>3. 0-1 背包问题</h3><p><strong>特点：</strong> 每件物品<strong>只有一件</strong>，你只能选择<strong>放或不放</strong>（0 或 1）。</p>
<p><strong>场景：</strong> 你要打包旅行，每件衣服只有一件，你决定带哪几件。</p>
<p><strong>动态规划解法：</strong></p>
<ul>
<li><p><strong>DP 状态：</strong> <code>dp[i][j]</code> 表示在前 <code>i</code> 件物品中选择，背包容量为 <code>j</code> 时，能获得的最大价值。</p>
</li>
<li><p><strong>状态转移方程：</strong> 考虑第 <code>i</code> 件物品（假设其重量为 <code>w[i-1]</code>，价值为 <code>v[i-1]</code>）：</p>
<ol>
<li><strong>不选择第 <code>i</code> 件物品：</strong> 此时最大价值等于在前 <code>i-1</code> 件物品中选择，背包容量为 <code>j</code> 时的最大价值，即 <code>dp[i-1][j]</code>。</li>
<li><strong>选择第 <code>i</code> 件物品：</strong> 前提是背包容量 <code>j</code> 足够放下第 <code>i</code> 件物品（即 <code>j &gt;= w[i-1]</code>）。此时，剩余容量为 <code>j - w[i-1]</code>，我们需要在前 <code>i-1</code> 件物品中选择，获得 <code>dp[i-1][j - w[i-1]]</code> 的价值，再加上第 <code>i</code> 件物品的价值 <code>v[i-1]</code>。所以是 <code>dp[i-1][j - w[i-1]] + v[i-1]</code>。</li>
</ol>
<p>综上，当 <code>j &lt; w[i-1]</code> 时，<code>dp[i][j] = dp[i-1][j]</code>。 当 <code>j &gt;= w[i-1]</code> 时，<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i-1]] + v[i-1])</code>。</p>
</li>
<li><p><strong>初始状态：</strong> <code>dp[0][j] = 0</code> (没有物品时，价值为0)，<code>dp[i][0] = 0</code> (背包容量为0时，价值为0)。</p>
</li>
<li><p><strong>遍历顺序：</strong> 外层循环物品 <code>i</code> (从 1 到 <code>N</code>)，内层循环背包容量 <code>j</code> (从 1 到 <code>W</code>)。</p>
</li>
</ul>
<p><strong>空间优化（一维数组）：</strong></p>
<p>由于 <code>dp[i][j]</code> 只依赖于 <code>dp[i-1][...]</code>，我们可以将二维 <code>dp</code> 数组优化为一维 <code>dp</code> 数组。 <code>dp[j]</code> 此时表示背包容量为 <code>j</code> 时的最大价值。</p>
<ul>
<li><strong>状态转移：</strong> <code>dp[j] = max(dp[j], dp[j - w[i]] + v[i])</code></li>
<li><strong>遍历顺序：</strong> <strong>关键在于内层循环 <code>j</code> 必须从 <code>W</code> 到 <code>w[i]</code> 逆序遍历。</strong> 这是为了确保在计算 <code>dp[j]</code> 时，<code>dp[j - w[i]]</code> 还是上一层（即不包含当前物品 <code>i</code>）的值。如果正序遍历，<code>dp[j - w[i]]</code> 可能已经被当前物品 <code>i</code> 更新过，导致物品 <code>i</code> 被重复选择。</li>
</ul>
<p>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def knapsack_01(weights, values, capacity):</span><br><span class="line">    n = len(weights)</span><br><span class="line">    dp = [0] * (capacity + 1)</span><br><span class="line"></span><br><span class="line">    for i in range(n): # 遍历物品</span><br><span class="line">        for j in range(capacity, weights[i] - 1, -1): # 逆序遍历容量</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])</span><br><span class="line">            </span><br><span class="line">    return dp[capacity]</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line"># weights = [2, 1, 3]</span><br><span class="line"># values = [4, 2, 3]</span><br><span class="line"># capacity = 4</span><br><span class="line"># print(knapsack_01(weights, values, capacity)) # Output: 6 (选择物品0和物品1)</span><br></pre></td></tr></table></figure>

<h3 id="4-完全背包问题"><a href="#4-完全背包问题" class="headerlink" title="4. 完全背包问题"></a>4. 完全背包问题</h3><p><strong>特点：</strong> 每件物品有<strong>无限多件</strong>，你可以选择<strong>任意件数</strong>放入背包。</p>
<p><strong>场景：</strong> 你去超市购物，每种商品想买多少就买多少（只要钱够，购物车放得下）。</p>
<p><strong>动态规划解法：</strong></p>
<p>与 0-1 背包的关键区别在于，选择当前物品后，它<strong>仍然可以再次被选择</strong>。</p>
<ul>
<li><strong>DP 状态：</strong> <code>dp[j]</code> 表示背包容量为 <code>j</code> 时，能获得的最大价值。</li>
<li><strong>状态转移方程：</strong> <code>dp[j] = max(dp[j], dp[j - w[i]] + v[i])</code></li>
<li><strong>遍历顺序：</strong> 与 0-1 背包不同的是，<strong>内层循环 <code>j</code> 必须从 <code>w[i]</code> 到 <code>W</code> 正序遍历。</strong> 这是因为在计算 <code>dp[j]</code> 时，如果 <code>j - w[i]</code> 已经包含了当前物品 <code>i</code> 的选择，那么我们就可以继续选择物品 <code>i</code>。正序遍历确保了 <code>dp[j - w[i]]</code> 已经“考虑”过当前物品 <code>i</code> 的选择。</li>
</ul>
<p>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def complete_knapsack(weights, values, capacity):</span><br><span class="line">    n = len(weights)</span><br><span class="line">    dp = [0] * (capacity + 1)</span><br><span class="line"></span><br><span class="line">    for i in range(n): # 遍历物品</span><br><span class="line">        for j in range(weights[i], capacity + 1): # 正序遍历容量</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])</span><br><span class="line">            </span><br><span class="line">    return dp[capacity]</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line"># weights = [2, 1, 3]</span><br><span class="line"># values = [4, 2, 3]</span><br><span class="line"># capacity = 4</span><br><span class="line"># print(complete_knapsack(weights, values, capacity)) # Output: 8 (选择2次物品0，或4次物品1，或2次物品1+1次物品0)</span><br></pre></td></tr></table></figure>

<h3 id="5-多重背包问题"><a href="#5-多重背包问题" class="headerlink" title="5. 多重背包问题"></a>5. 多重背包问题</h3><p><strong>特点：</strong> 每件物品有<strong>固定的数量限制</strong>（例如，第 <code>i</code> 种物品有 <code>count[i]</code> 件）。</p>
<p><strong>场景：</strong> 你去批货，每种商品商家限量供应。</p>
<p><strong>动态规划解法：</strong></p>
<p>多重背包可以看作是 0-1 背包和完全背包的结合。最直接的思路是将其<strong>转化为 0-1 背包问题</strong>。</p>
<p><strong>转化思路：</strong></p>
<p>将每件物品 <code>i</code> 及其数量 <code>count[i]</code> 展开成 <code>count[i]</code> 个独立的 0-1 背包问题中的物品。 例如，物品 A 有 3 件，重量 <code>w_A</code>，价值 <code>v_A</code>。我们可以把它看作 3 个独立的物品：A1 (<code>w_A</code>, <code>v_A</code>), A2 (<code>w_A</code>, <code>v_A</code>), A3 (<code>w_A</code>, <code>v_A</code>)。然后应用 0-1 背包的解法。</p>
<p><strong>优化：二进制拆分</strong></p>
<p>如果物品数量非常大，上述直接展开的方法会导致物品总数剧增，降低效率。更高效的方法是<strong>二进制拆分</strong>。 将每件物品 <code>i</code> 的数量 <code>count[i]</code> 拆分成若干个<strong>幂次为 2</strong> 的物品组合。 例如，如果 <code>count[i] = 13</code>，我们可以拆分成：</p>
<ul>
<li>1 件物品 (价值 <code>1 * v[i]</code>, 重量 <code>1 * w[i]</code>)</li>
<li>2 件物品 (价值 <code>2 * v[i]</code>, 重量 <code>2 * w[i]</code>)</li>
<li>4 件物品 (价值 <code>4 * v[i]</code>, 重量 <code>4 * w[i]</code>)</li>
<li>8 件物品 (价值 <code>8 * v[i]</code>, 重量 <code>8 * w[i]</code>) – 1 + 2 + 4 + 8 &#x3D; 15 &gt; 13，所以最后一个是 <code>13 - (1+2+4) = 6</code> 件物品 (价值 <code>6 * v[i]</code>, 重量 <code>6 * w[i]</code>)。</li>
</ul>
<p>通过这种方式，任何 <code>count[i]</code> 件物品的选择都可以由这些二进制组合的物品来表示，而物品的总数大大减少。然后，对这些“新”物品应用 0-1 背包的解法。</p>
<p>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">def multiple_knapsack(weights, values, counts, capacity):</span><br><span class="line">    # 将多重背包问题转化为0-1背包问题</span><br><span class="line">    # 使用二进制拆分优化</span><br><span class="line">    </span><br><span class="line">    binary_weights = []</span><br><span class="line">    binary_values = []</span><br><span class="line"></span><br><span class="line">    for i in range(len(weights)):</span><br><span class="line">        w, v, c = weights[i], values[i], counts[i]</span><br><span class="line">        k = 1</span><br><span class="line">        while c &gt; 0:</span><br><span class="line">            num = min(k, c)</span><br><span class="line">            binary_weights.append(w * num)</span><br><span class="line">            binary_values.append(v * num)</span><br><span class="line">            c -= num</span><br><span class="line">            k *= 2 # 2的幂次</span><br><span class="line">    </span><br><span class="line">    # 转换为0-1背包问题求解</span><br><span class="line">    n_binary = len(binary_weights)</span><br><span class="line">    dp = [0] * (capacity + 1)</span><br><span class="line"></span><br><span class="line">    for i in range(n_binary):</span><br><span class="line">        for j in range(capacity, binary_weights[i] - 1, -1):</span><br><span class="line">            dp[j] = max(dp[j], dp[j - binary_weights[i]] + binary_values[i])</span><br><span class="line">            </span><br><span class="line">    return dp[capacity]</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line"># weights = [2, 3]</span><br><span class="line"># values = [3, 4]</span><br><span class="line"># counts = [2, 1] # 物品0有2件，物品1有1件</span><br><span class="line"># capacity = 5</span><br><span class="line"># print(multiple_knapsack(weights, values, counts, capacity)) # Output: 7 (选择2件物品0，或1件物品0+1件物品1)</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-图" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/%E5%9B%BE/" class="article-date">
      <time datetime="2025-05-30T12:05:28.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/%E5%9B%BE/">图</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="深入理解“图”"><a href="#深入理解“图”" class="headerlink" title="深入理解“图”"></a>深入理解“图”</h2><h3 id="1-什么是图？"><a href="#1-什么是图？" class="headerlink" title="1. 什么是图？"></a>1. 什么是图？</h3><p>图是由一组<strong>顶点（Vertex &#x2F; Node）</strong> 和连接这些顶点的<strong>边（Edge）</strong> 组成的。简单来说，图 G 可以表示为 G&#x3D;(V,E)，其中 V 是顶点的集合，而 E 是边的集合。</p>
<p><strong>形象比喻：</strong></p>
<ul>
<li><strong>社交网络：</strong> 每个人是一个顶点，朋友关系是连接他们之间的边。</li>
<li><strong>城市交通网络：</strong> 每个城市是一个顶点，连接城市的道路是边。</li>
<li><strong>互联网：</strong> 每个网页是一个顶点，网页之间的链接是边。</li>
</ul>
<h3 id="2-图的基本术语"><a href="#2-图的基本术语" class="headerlink" title="2. 图的基本术语"></a>2. 图的基本术语</h3><p>理解这些术语是掌握图的关键：</p>
<ul>
<li><p><strong>顶点（Vertex &#x2F; Node）：</strong> 图中的基本单元，代表了数据实体。例如，城市、人、网页。</p>
</li>
<li><p><strong>边（Edge）：</strong> 连接两个顶点的线，表示它们之间的关系。例如，道路、朋友关系、网页链接。</p>
</li>
<li><p><strong>邻接（Adjacent）：</strong> 如果两个顶点之间有一条边直接相连，则称它们是邻接的。</p>
</li>
<li><p>度（Degree）：</p>
<p> 对于无向图，一个顶点的度是与它相连的边的数量。</p>
<ul>
<li>对于有向图，分为入度（In-degree）和 出度（Out-degree）。<ul>
<li><strong>入度：</strong> 指向该顶点的边的数量。</li>
<li><strong>出度：</strong> 从该顶点出发的边的数量。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>路径（Path）：</strong> 从一个顶点到另一个顶点所经过的顶点序列（或边序列）。</p>
</li>
<li><p><strong>连通（Connected）：</strong> 在无向图中，如果从顶点 A 到顶点 B 存在一条路径，则称 A 和 B 是连通的。</p>
</li>
<li><p><strong>连通图（Connected Graph）：</strong> 如果图中任意两个顶点都是连通的，则称该图为连通图。</p>
</li>
<li><p><strong>回路&#x2F;环（Cycle）：</strong> 一条起始顶点和结束顶点相同的路径。</p>
</li>
<li><p><strong>权重&#x2F;权值（Weight）：</strong> 边上可以附加一个数值，表示某种成本、距离或强度。这种图称为<strong>带权图（Weighted Graph）</strong>。</p>
</li>
<li><p><strong>子图（Sub-graph）：</strong> 一个图 G′&#x3D;(V′,E′)，其中 V′⊆V 且 E′⊆E。</p>
</li>
</ul>
<h3 id="3-图的分类"><a href="#3-图的分类" class="headerlink" title="3. 图的分类"></a>3. 图的分类</h3><p>图可以根据其边的特性进行分类：</p>
<ul>
<li><strong>无向图（Undirected Graph）：</strong> 边没有方向。如果 A 到 B 有一条边，则意味着 B 到 A 也有相同的连接。例如，朋友关系。</li>
<li><strong>有向图（Directed Graph &#x2F; Digraph）：</strong> 边有方向。如果 A 到 B 有一条边，不代表 B 到 A 也有一条边。例如，单行道，或者 Twitter 上的关注关系（你关注别人，别人不一定关注你）。</li>
</ul>
<hr>
<h3 id="4-图在-C-语言中的表示方法"><a href="#4-图在-C-语言中的表示方法" class="headerlink" title="4. 图在 C 语言中的表示方法"></a>4. 图在 C 语言中的表示方法</h3><p>在 C 语言中，表示图通常有两种主要方式：<strong>邻接矩阵</strong> 和 <strong>邻接表</strong>。选择哪种方式取决于图的特性（顶点数、边数）和具体应用。</p>
<h4 id="4-1-邻接矩阵（Adjacency-Matrix）"><a href="#4-1-邻接矩阵（Adjacency-Matrix）" class="headerlink" title="4.1 邻接矩阵（Adjacency Matrix）"></a>4.1 邻接矩阵（Adjacency Matrix）</h4><p>邻接矩阵是一个 V×V 的二维数组（或矩阵），其中 V 是图中顶点的数量。</p>
<ul>
<li>如果顶点 i 和顶点 j 之间有边相连，则 <code>matrix[i][j] = 1</code> (或表示权重)。</li>
<li>如果无边相连，则 <code>matrix[i][j] = 0</code> (或表示无穷大)。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>优点：<ul>
<li>判断两顶点之间是否存在边非常快速（O(1)）。</li>
<li>实现简单直观。</li>
</ul>
</li>
<li>缺点：<ul>
<li>空间复杂度高：总是 O(V2)，即使图非常稀疏（边很少）。</li>
<li>遍历一个顶点的所有邻居需要 O(V) 的时间。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 顶点数量较少，或者图是稠密的（边很多）的情况。</li>
</ul>
<p><strong>C 语言示例（无向图，不带权）：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 100 <span class="comment">// 最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵表示图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphMatrix</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> numVertices;</span><br><span class="line">    <span class="type">int</span> adjMatrix[MAX_VERTICES][MAX_VERTICES];</span><br><span class="line">&#125; GraphMatrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化图（邻接矩阵）</span></span><br><span class="line">GraphMatrix* <span class="title function_">createGraphMatrix</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">    GraphMatrix* graph = (GraphMatrix*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphMatrix));</span><br><span class="line">    <span class="keyword">if</span> (graph == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    graph-&gt;numVertices = V;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">            graph-&gt;adjMatrix[i][j] = <span class="number">0</span>; <span class="comment">// 初始化为无边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加边（无向图）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdgeMatrix</span><span class="params">(GraphMatrix* graph, <span class="type">int</span> src, <span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (src &gt;= <span class="number">0</span> &amp;&amp; src &lt; graph-&gt;numVertices &amp;&amp; dest &gt;= <span class="number">0</span> &amp;&amp; dest &lt; graph-&gt;numVertices) &#123;</span><br><span class="line">        graph-&gt;adjMatrix[src][dest] = <span class="number">1</span>;</span><br><span class="line">        graph-&gt;adjMatrix[dest][src] = <span class="number">1</span>; <span class="comment">// 无向图，对称</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无效的顶点索引。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印邻接矩阵</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraphMatrix</span><span class="params">(GraphMatrix* graph)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;邻接矩阵：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;numVertices; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; graph-&gt;numVertices; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, graph-&gt;adjMatrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-邻接表（Adjacency-List）"><a href="#4-2-邻接表（Adjacency-List）" class="headerlink" title="4.2 邻接表（Adjacency List）"></a>4.2 邻接表（Adjacency List）</h4><p>邻接表是更常用的一种表示方法，特别适用于稀疏图。它是一个由<strong>链表（或动态数组）</strong> 组成的数组，数组的每个索引代表一个顶点，其对应的链表存储了所有与该顶点邻接的顶点。</p>
<p><strong>特点：</strong></p>
<ul>
<li>优点：<ul>
<li>空间复杂度低：O(V+E)，更适合稀疏图。</li>
<li>遍历一个顶点的所有邻居非常高效（O(degree)）。</li>
</ul>
</li>
<li>缺点：<ul>
<li>判断两顶点之间是否存在边需要遍历链表（最坏 O(degree)）。</li>
<li>实现相对复杂一点。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 顶点数量很大，或者图是稀疏的（边很少）的情况。</li>
</ul>
<p><strong>C 语言示例（无向图，不带权）：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表节点 (表示邻接顶点)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjListNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> dest;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AdjListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; AdjListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义邻接表数组中的每个头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjList</span> &#123;</span></span><br><span class="line">    AdjListNode *head;</span><br><span class="line">&#125; AdjList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表表示图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphList</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> numVertices;</span><br><span class="line">    AdjList* <span class="built_in">array</span>; <span class="comment">// 存储 AdjList 结构的数组</span></span><br><span class="line">&#125; GraphList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建邻接列表的新节点</span></span><br><span class="line">AdjListNode* <span class="title function_">newAdjListNode</span><span class="params">(<span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    AdjListNode* newNode = (AdjListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjListNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;dest = dest;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化图（邻接表）</span></span><br><span class="line">GraphList* <span class="title function_">createGraphList</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">    GraphList* graph = (GraphList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphList));</span><br><span class="line">    <span class="keyword">if</span> (graph == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    graph-&gt;numVertices = V;</span><br><span class="line"></span><br><span class="line">    graph-&gt;<span class="built_in">array</span> = (AdjList*)<span class="built_in">malloc</span>(V * <span class="keyword">sizeof</span>(AdjList));</span><br><span class="line">    <span class="keyword">if</span> (graph-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        graph-&gt;<span class="built_in">array</span>[i].head = <span class="literal">NULL</span>; <span class="comment">// 初始化所有链表头为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加边（无向图）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdgeList</span><span class="params">(GraphList* graph, <span class="type">int</span> src, <span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (src &gt;= <span class="number">0</span> &amp;&amp; src &lt; graph-&gt;numVertices &amp;&amp; dest &gt;= <span class="number">0</span> &amp;&amp; dest &lt; graph-&gt;numVertices) &#123;</span><br><span class="line">        <span class="comment">// 添加 dest 到 src 的链表</span></span><br><span class="line">        AdjListNode* newNode = newAdjListNode(dest);</span><br><span class="line">        newNode-&gt;next = graph-&gt;<span class="built_in">array</span>[src].head;</span><br><span class="line">        graph-&gt;<span class="built_in">array</span>[src].head = newNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 src 到 dest 的链表 (无向图)</span></span><br><span class="line">        newNode = newAdjListNode(src);</span><br><span class="line">        newNode-&gt;next = graph-&gt;<span class="built_in">array</span>[dest].head;</span><br><span class="line">        graph-&gt;<span class="built_in">array</span>[dest].head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无效的顶点索引。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印邻接表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraphList</span><span class="params">(GraphList* graph)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;邻接表：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; graph-&gt;numVertices; v++) &#123;</span><br><span class="line">        AdjListNode* current = graph-&gt;<span class="built_in">array</span>[v].head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顶点 %d 的邻居: &quot;</span>, v);</span><br><span class="line">        <span class="keyword">while</span> (current) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d &quot;</span>, current-&gt;dest);</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&gt; NULL\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放邻接表内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeGraphList</span><span class="params">(GraphList* graph)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;numVertices; i++) &#123;</span><br><span class="line">        AdjListNode* current = graph-&gt;<span class="built_in">array</span>[i].head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            AdjListNode* temp = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(graph-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(graph);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;图的内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-综合示例-main-函数"><a href="#4-3-综合示例-main-函数" class="headerlink" title="4.3 综合示例 main 函数"></a>4.3 综合示例 <code>main</code> 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 示例：邻接矩阵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--- 邻接矩阵示例 ---\n&quot;</span>);</span><br><span class="line">    GraphMatrix* g_matrix = createGraphMatrix(<span class="number">5</span>); <span class="comment">// 创建 5 个顶点的图</span></span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    printGraphMatrix(g_matrix);</span><br><span class="line">    <span class="built_in">free</span>(g_matrix); <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n--- 邻接表示例 ---\n&quot;</span>);</span><br><span class="line">    GraphList* g_list = createGraphList(<span class="number">5</span>); <span class="comment">// 创建 5 个顶点的图</span></span><br><span class="line">    addEdgeList(g_list, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    addEdgeList(g_list, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    addEdgeList(g_list, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    addEdgeList(g_list, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    addEdgeList(g_list, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    addEdgeList(g_list, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    addEdgeList(g_list, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    printGraphList(g_list);</span><br><span class="line">    freeGraphList(g_list); <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-图的遍历"><a href="#5-图的遍历" class="headerlink" title="5. 图的遍历"></a>5. 图的遍历</h3><p>理解图的表示后，如何访问图中的所有顶点和边是另一个核心问题。图的遍历主要有两种方法：</p>
<ul>
<li><strong>广度优先搜索（BFS）：</strong> 从一个顶点开始，逐层访问其所有邻居，然后是邻居的邻居，以此类推。通常使用<strong>队列</strong>实现。</li>
<li><strong>深度优先搜索（DFS）：</strong> 从一个顶点开始，尽可能深地探索其分支，直到无法继续深入，然后回溯。通常使用<strong>栈</strong>（或递归）实现。</li>
</ul>
<p>这两种遍历方法是解决许多图算法的基础，例如查找最短路径、判断连通性等。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
      <time datetime="2025-05-30T12:05:21.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h3><p><strong>树</strong>是一种非线性的数据结构，它由节点（Node）和边（Edge）组成，并且具有层级关系。每个节点可以有零个或多个子节点。</p>
<p>而<strong>二叉树（Binary Tree）</strong> 是一种特殊的树，它的每个节点最多只有<strong>两个</strong>子节点，分别称为<strong>左子节点（Left Child）</strong> 和 <strong>右子节点（Right Child）</strong>。</p>
<p><strong>基本概念：</strong></p>
<ul>
<li><strong>根节点（Root Node）：</strong> 树的顶端节点，没有父节点。</li>
<li><strong>父节点（Parent Node）：</strong> 拥有子节点的节点。</li>
<li><strong>子节点（Child Node）：</strong> 依附于父节点的节点。</li>
<li><strong>兄弟节点（Sibling Node）：</strong> 拥有同一个父节点的节点。</li>
<li><strong>叶子节点（Leaf Node）：</strong> 没有子节点的节点。</li>
<li><strong>路径（Path）：</strong> 从一个节点到另一个节点所经过的节点序列。</li>
<li><strong>深度（Depth）：</strong> 从根节点到某个节点的路径上的边数。根节点的深度为 0。</li>
<li><strong>高度（Height）：</strong> 从某个节点到其最远叶子节点的路径上的边数。叶子节点的高度为 0。树的高度是根节点的高度。</li>
<li><strong>层（Level）：</strong> 节点的深度加 1。根节点在第 1 层。</li>
</ul>
<h3 id="2-C-语言中的二叉树节点定义"><a href="#2-C-语言中的二叉树节点定义" class="headerlink" title="2. C 语言中的二叉树节点定义"></a>2. C 语言中的二叉树节点定义</h3><p>与链表类似，二叉树的节点也可以通过结构体来定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 包含 malloc 和 free</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;               <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span>  <span class="comment">// 指向左子节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span> <span class="comment">// 指向右子节点的指针</span></span><br><span class="line">&#125; TreeNode;</span><br></pre></td></tr></table></figure>

<h3 id="3-二叉树的类型"><a href="#3-二叉树的类型" class="headerlink" title="3. 二叉树的类型"></a>3. 二叉树的类型</h3><p>二叉树有很多种类型，理解它们有助于我们更好地应用：</p>
<ul>
<li><p><strong>满二叉树（Full Binary Tree）：</strong> 除了叶子节点外，所有节点都有两个子节点。</p>
</li>
<li><p><strong>完全二叉树（Complete Binary Tree）：</strong> 除了最后一层，其他层都被完全填满，并且最后一层的所有节点都尽可能地靠左排列。</p>
</li>
<li><p><strong>平衡二叉树（Balanced Binary Tree）：</strong> 左右子树的高度差不超过 1，并且左右子树都是平衡二叉树。常见的有 AVL 树和红黑树。</p>
</li>
<li><p>二叉搜索树（Binary Search Tree, BST）：</p>
<p> 对所有节点都满足以下条件：</p>
<ul>
<li>左子树中所有节点的值都小于当前节点的值。</li>
<li>右子树中所有节点的值都大于当前节点的值。</li>
<li>左右子树也都是二叉搜索树。</li>
</ul>
</li>
</ul>
<h3 id="4-二叉树的遍历方式"><a href="#4-二叉树的遍历方式" class="headerlink" title="4. 二叉树的遍历方式"></a>4. 二叉树的遍历方式</h3><p>遍历二叉树是指按照某种顺序访问树中的所有节点。二叉树的遍历是面试常考点，也是理解树结构的关键。主要有四种基本遍历方式：</p>
<h4 id="4-1-深度优先遍历（Depth-First-Search-DFS）"><a href="#4-1-深度优先遍历（Depth-First-Search-DFS）" class="headerlink" title="4.1 深度优先遍历（Depth-First Search, DFS）"></a>4.1 深度优先遍历（Depth-First Search, DFS）</h4><p>深度优先遍历沿着树的深度方向进行，直到无法继续深入，然后回溯。主要有三种：</p>
<ul>
<li><p><strong>前序遍历（Pre-order Traversal）：</strong> 访问顺序为：<strong>根节点 -&gt; 左子树 -&gt; 右子树</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);      <span class="comment">// 访问根节点</span></span><br><span class="line">    preOrderTraversal(root-&gt;left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    preOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历（In-order Traversal）： 访问顺序为：左子树 -&gt; 根节点 -&gt; 右子树。</p>
<p>对于二叉搜索树，中序遍历会得到一个有序的序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraversal(root-&gt;left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);      <span class="comment">// 访问根节点</span></span><br><span class="line">    inOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历（Post-order Traversal）： 访问顺序为：左子树 -&gt; 右子树 -&gt; 根节点。</p>
<p>通常用于在删除节点前先删除子节点，或计算表达式树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrderTraversal(root-&gt;left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    postOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);      <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-2-广度优先遍历（Breadth-First-Search-BFS）-层序遍历（Level-order-Traversal）"><a href="#4-2-广度优先遍历（Breadth-First-Search-BFS）-层序遍历（Level-order-Traversal）" class="headerlink" title="4.2 广度优先遍历（Breadth-First Search, BFS）&#x2F; 层序遍历（Level-order Traversal）"></a>4.2 广度优先遍历（Breadth-First Search, BFS）&#x2F; 层序遍历（Level-order Traversal）</h4><p>广度优先遍历逐层访问树的节点，从上到下，从左到右。通常需要借助队列（Queue）来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列结构（用于层序遍历）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    TreeNode* treeNode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    QueueNode* front;</span><br><span class="line">    QueueNode* rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line">Queue* <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* q, TreeNode* treeNode)</span> &#123;</span><br><span class="line">    QueueNode* newNode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    newNode-&gt;treeNode = treeNode;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;front = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* <span class="title function_">dequeue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* temp = q-&gt;front;</span><br><span class="line">    TreeNode* treeNode = temp-&gt;treeNode;</span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> treeNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isQueueEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历 (需要队列辅助)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue* q = createQueue();</span><br><span class="line">    enqueue(q, root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;层序遍历：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isQueueEmpty(q)) &#123;</span><br><span class="line">        TreeNode* current = dequeue(q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            enqueue(q, current-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            enqueue(q, current-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 释放队列内存（这里省略了详细的队列内存释放，实际应用中需要确保释放）</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-二叉搜索树（BST）的实现"><a href="#5-二叉搜索树（BST）的实现" class="headerlink" title="5. 二叉搜索树（BST）的实现"></a>5. 二叉搜索树（BST）的实现</h3><p>BST 是一种非常实用的二叉树，它能高效地进行查找、插入和删除操作。</p>
<h4 id="5-1-插入节点"><a href="#5-1-插入节点" class="headerlink" title="5.1 插入节点"></a>5.1 插入节点</h4><p>插入新节点时，从根节点开始比较，如果新节点的值小于当前节点，则进入左子树；如果大于当前节点，则进入右子树。直到找到一个空位置插入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入节点到二叉搜索树</span></span><br><span class="line">TreeNode* <span class="title function_">insertNode</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        TreeNode* newNode = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;data = value;</span><br><span class="line">        newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = insertNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;right = insertNode(root-&gt;right, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果值相等，通常不插入重复值，或者根据需求决定</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-查找节点"><a href="#5-2-查找节点" class="headerlink" title="5.2 查找节点"></a>5.2 查找节点</h4><p>查找节点与插入类似，通过比较值来决定向左还是向右查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在二叉搜索树中查找节点</span></span><br><span class="line">TreeNode* <span class="title function_">searchNode</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;data == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-删除节点"><a href="#5-3-删除节点" class="headerlink" title="5.3 删除节点"></a>5.3 删除节点</h4><p>删除节点是 BST 操作中最复杂的一个，需要处理以下几种情况：</p>
<ol>
<li><strong>待删除节点是叶子节点：</strong> 直接删除，并将其父节点对应的指针置为 <code>NULL</code>。</li>
<li><strong>待删除节点只有一个子节点：</strong> 用其子节点替换待删除节点。</li>
<li><strong>待删除节点有两个子节点：</strong> 找到其右子树中的最小节点（或左子树中的最大节点）来替换它，然后删除那个最小（或最大）节点。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找二叉搜索树中最小值的节点 (用于删除操作)</span></span><br><span class="line">TreeNode* <span class="title function_">findMinNode</span><span class="params">(TreeNode* node)</span> &#123;</span><br><span class="line">    TreeNode* current = node;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从二叉搜索树中删除节点</span></span><br><span class="line">TreeNode* <span class="title function_">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">        <span class="comment">// 情况1: 没有子节点或只有一个子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* temp = root-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* temp = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况2: 有两个子节点</span></span><br><span class="line">        TreeNode* temp = findMinNode(root-&gt;right); <span class="comment">// 找到右子树中最小的节点</span></span><br><span class="line">        root-&gt;data = temp-&gt;data; <span class="comment">// 将最小节点的数据复制到当前节点</span></span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, temp-&gt;data); <span class="comment">// 在右子树中删除那个最小节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-释放二叉树内存"><a href="#5-4-释放二叉树内存" class="headerlink" title="5.4 释放二叉树内存"></a>5.4 释放二叉树内存</h4><p>递归地释放所有节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放二叉树所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeTree</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    freeTree(root-&gt;left);</span><br><span class="line">    freeTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-完整示例代码"><a href="#6-完整示例代码" class="headerlink" title="6. 完整示例代码"></a>6. 完整示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列结构（用于层序遍历）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    TreeNode* treeNode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    QueueNode* front;</span><br><span class="line">    QueueNode* rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue辅助函数</span></span><br><span class="line">Queue* <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* q, TreeNode* treeNode)</span> &#123;</span><br><span class="line">    QueueNode* newNode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    newNode-&gt;treeNode = treeNode;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;front = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* <span class="title function_">dequeue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* temp = q-&gt;front;</span><br><span class="line">    TreeNode* treeNode = temp-&gt;treeNode;</span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> treeNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isQueueEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!isQueueEmpty(q)) &#123;</span><br><span class="line">        dequeue(q); <span class="comment">// 只是为了清空节点，TreeNode*已经被返回并处理了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新节点（辅助函数）</span></span><br><span class="line">TreeNode* <span class="title function_">createNewNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    TreeNode* newNode = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 二叉树遍历 ----</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">    preOrderTraversal(root-&gt;left);</span><br><span class="line">    preOrderTraversal(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrderTraversal(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">    inOrderTraversal(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrderTraversal(root-&gt;left);</span><br><span class="line">    postOrderTraversal(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue* q = createQueue();</span><br><span class="line">    enqueue(q, root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;层序遍历：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isQueueEmpty(q)) &#123;</span><br><span class="line">        TreeNode* current = dequeue(q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left != <span class="literal">NULL</span>) enqueue(q, current-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right != <span class="literal">NULL</span>) enqueue(q, current-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">// 释放队列本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 二叉搜索树操作 ----</span></span><br><span class="line">TreeNode* <span class="title function_">insertNode</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNewNode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = insertNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;right = insertNode(root-&gt;right, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* <span class="title function_">searchNode</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;data == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* <span class="title function_">findMinNode</span><span class="params">(TreeNode* node)</span> &#123;</span><br><span class="line">    TreeNode* current = node;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* <span class="title function_">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123; <span class="comment">// 没有左子或没有子节点</span></span><br><span class="line">            TreeNode* temp = root-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 只有左子</span></span><br><span class="line">            TreeNode* temp = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有两个子节点</span></span><br><span class="line">        TreeNode* temp = findMinNode(root-&gt;right); <span class="comment">// 找到右子树中最小的节点</span></span><br><span class="line">        root-&gt;data = temp-&gt;data;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放二叉树所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeTree</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    freeTree(root-&gt;left);</span><br><span class="line">    freeTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    TreeNode* root = <span class="literal">NULL</span>; <span class="comment">// 初始化空二叉搜索树</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 插入节点 ------\n&quot;</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">50</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">30</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">70</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">20</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">40</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">60</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 遍历操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">    preOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">    inOrderTraversal(root); <span class="comment">// 对于BST，中序遍历是升序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;后序遍历：&quot;</span>);</span><br><span class="line">    postOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    levelOrderTraversal(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 查找操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (searchNode(root, <span class="number">40</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了值为 40 的节点。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 40 的节点。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (searchNode(root, <span class="number">90</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了值为 90 的节点。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 90 的节点。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 删除操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除节点 20 (叶子节点):\n&quot;</span>);</span><br><span class="line">    root = deleteNode(root, <span class="number">20</span>);</span><br><span class="line">    levelOrderTraversal(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除节点 70 (有一个子节点):\n&quot;</span>);</span><br><span class="line">    root = deleteNode(root, <span class="number">70</span>); <span class="comment">// 80会上移</span></span><br><span class="line">    levelOrderTraversal(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除节点 50 (有两个子节点):\n&quot;</span>);</span><br><span class="line">    root = deleteNode(root, <span class="number">50</span>); <span class="comment">// 60会上移</span></span><br><span class="line">    levelOrderTraversal(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 内存释放 ------\n&quot;</span>);</span><br><span class="line">    freeTree(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二叉树内存已释放。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-链表" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/%E9%93%BE%E8%A1%A8/" class="article-date">
      <time datetime="2025-05-30T12:04:51.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/%E9%93%BE%E8%A1%A8/">链表</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="C-语言中的链表节点定义"><a href="#C-语言中的链表节点定义" class="headerlink" title="C 语言中的链表节点定义"></a>C 语言中的链表节点定义</h3><p>在 C 语言中，我们通常使用结构体（<code>struct</code>）来定义链表的节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 包含 malloc 和 free 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;          <span class="comment">// 数据域，这里以整型为例，也可以是其他类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域，指向下一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了方便，我们经常定义一个指向 Node 的指针类型</span></span><br><span class="line"><span class="comment">// typedef struct Node* LinkList; // 另一种定义方式</span></span><br></pre></td></tr></table></figure>

<h3 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><h4 id="1-创建新节点"><a href="#1-创建新节点" class="headerlink" title="1 创建新节点"></a>1 创建新节点</h4><p>创建新节点是链表操作的基础。我们需要使用 <code>malloc</code> 为新节点分配内存，并初始化其数据和指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新节点</span></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value; <span class="comment">// 设置数据</span></span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 新节点的next指针初始为NULL</span></span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-链表的初始化（创建空链表）"><a href="#2-链表的初始化（创建空链表）" class="headerlink" title="2 链表的初始化（创建空链表）"></a>2 链表的初始化（创建空链表）</h4><p>空链表通常用一个 <code>NULL</code> 指针表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空链表（头指针）</span></span><br><span class="line">Node* <span class="title function_">initLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 空链表的头指针指向NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-在链表头部插入节点"><a href="#3-在链表头部插入节点" class="headerlink" title="3 在链表头部插入节点"></a>3 在链表头部插入节点</h4><p>这是最简单的插入操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表头部插入节点</span></span><br><span class="line">Node* <span class="title function_">insertAtHead</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(value);</span><br><span class="line">    newNode-&gt;next = head; <span class="comment">// 新节点的next指向原来的头节点</span></span><br><span class="line">    <span class="keyword">return</span> newNode;        <span class="comment">// 返回新节点作为新的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-在链表尾部插入节点"><a href="#4-在链表尾部插入节点" class="headerlink" title="4 在链表尾部插入节点"></a>4 在链表尾部插入节点</h4><p>需要遍历链表找到尾节点，然后将其 <code>next</code> 指针指向新节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表尾部插入节点</span></span><br><span class="line">Node* <span class="title function_">insertAtTail</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(value);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果链表为空，新节点就是头节点</span></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 遍历到链表尾部</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = newNode; <span class="comment">// 尾节点的next指向新节点</span></span><br><span class="line">    <span class="keyword">return</span> head;             <span class="comment">// 返回原来的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-遍历链表并打印数据"><a href="#5-遍历链表并打印数据" class="headerlink" title="5 遍历链表并打印数据"></a>5 遍历链表并打印数据</h4><p>这是最常用的操作之一，用于查看链表中的所有元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印链表所有节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLinkedList</span><span class="params">(Node* head)</span> &#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内容：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-查找节点"><a href="#6-查找节点" class="headerlink" title="6 查找节点"></a>6 查找节点</h4><p>根据数据查找特定节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找链表中是否存在某个值的节点</span></span><br><span class="line">Node* <span class="title function_">findNode</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;data == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> current; <span class="comment">// 找到，返回该节点指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-删除节点"><a href="#7-删除节点" class="headerlink" title="7 删除节点"></a>7 删除节点</h4><p>删除指定值的节点。这里我们处理了三种情况：删除头节点、删除中间节点、删除不存在的节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除链表中指定值的节点</span></span><br><span class="line">Node* <span class="title function_">deleteNode</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 链表为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要删除的是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;data == value) &#123;</span><br><span class="line">        Node* temp = head;</span><br><span class="line">        head = head-&gt;next; <span class="comment">// 新的头节点是原头节点的next</span></span><br><span class="line">        <span class="built_in">free</span>(temp);        <span class="comment">// 释放原头节点内存</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span> &amp;&amp; current-&gt;next-&gt;data != value) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到要删除的节点（current-&gt;next）</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node* temp = current-&gt;next; <span class="comment">// 待删除节点</span></span><br><span class="line">        current-&gt;next = temp-&gt;next; <span class="comment">// current的next指向待删除节点的next</span></span><br><span class="line">        <span class="built_in">free</span>(temp);                 <span class="comment">// 释放待删除节点内存</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 %d 的节点进行删除。\n&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-释放链表内存"><a href="#8-释放链表内存" class="headerlink" title="8 释放链表内存"></a>8 释放链表内存</h4><p>完成链表操作后，务必释放所有节点的内存，避免内存泄漏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放链表所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeLinkedList</span><span class="params">(Node* head)</span> &#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node* temp = current; <span class="comment">// 临时保存当前节点</span></span><br><span class="line">        current = current-&gt;next; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        <span class="built_in">free</span>(temp); <span class="comment">// 释放当前节点内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码"></a>完整示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新节点</span></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头部插入节点</span></span><br><span class="line">Node* <span class="title function_">insertAtHead</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(value);</span><br><span class="line">    newNode-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表尾部插入节点</span></span><br><span class="line">Node* <span class="title function_">insertAtTail</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(value);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = newNode;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表所有节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLinkedList</span><span class="params">(Node* head)</span> &#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内容：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找链表中是否存在某个值的节点</span></span><br><span class="line">Node* <span class="title function_">findNode</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;data == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表中指定值的节点</span></span><br><span class="line">Node* <span class="title function_">deleteNode</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表为空，无法删除。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要删除的是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;data == value) &#123;</span><br><span class="line">        Node* temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功删除头节点 %d。\n&quot;</span>, value);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span> &amp;&amp; current-&gt;next-&gt;data != value) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到要删除的节点（current-&gt;next）</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node* temp = current-&gt;next;</span><br><span class="line">        current-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功删除节点 %d。\n&quot;</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 %d 的节点进行删除。\n&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放链表所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeLinkedList</span><span class="params">(Node* head)</span> &#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* head = <span class="literal">NULL</span>; <span class="comment">// 初始化空链表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 插入操作 ------\n&quot;</span>);</span><br><span class="line">    head = insertAtHead(head, <span class="number">10</span>); <span class="comment">// 10 -&gt; NULL</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    </span><br><span class="line">    head = insertAtTail(head, <span class="number">20</span>); <span class="comment">// 10 -&gt; 20 -&gt; NULL</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    </span><br><span class="line">    head = insertAtHead(head, <span class="number">5</span>);  <span class="comment">// 5 -&gt; 10 -&gt; 20 -&gt; NULL</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line"></span><br><span class="line">    head = insertAtTail(head, <span class="number">30</span>); <span class="comment">// 5 -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 查找操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (findNode(head, <span class="number">10</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了值为 10 的节点。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 10 的节点。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (findNode(head, <span class="number">100</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了值为 100 的节点。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 100 的节点。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 删除操作 ------\n&quot;</span>);</span><br><span class="line">    head = deleteNode(head, <span class="number">5</span>); <span class="comment">// 删除头节点</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    </span><br><span class="line">    head = deleteNode(head, <span class="number">20</span>); <span class="comment">// 删除中间节点</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line"></span><br><span class="line">    head = deleteNode(head, <span class="number">100</span>); <span class="comment">// 删除不存在的节点</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line"></span><br><span class="line">    head = deleteNode(head, <span class="number">30</span>); <span class="comment">// 删除最后一个节点</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    </span><br><span class="line">    head = deleteNode(head, <span class="number">10</span>); <span class="comment">// 删除最后一个节点（现在是头节点）</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 内存释放 ------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 再次插入一些节点用于测试内存释放</span></span><br><span class="line">    head = insertAtTail(head, <span class="number">1</span>);</span><br><span class="line">    head = insertAtTail(head, <span class="number">2</span>);</span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    freeLinkedList(head); <span class="comment">// 释放所有内存</span></span><br><span class="line">    head = <span class="literal">NULL</span>; <span class="comment">// 释放后将头指针设为NULL，避免野指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试打印已释放的链表，会输出NULL</span></span><br><span class="line">    printLinkedList(head); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表的变种"><a href="#链表的变种" class="headerlink" title="链表的变种"></a>链表的变种</h3><p>除了上面介绍的<strong>单向链表</strong>，还有其他几种常见的链表类型：</p>
<ul>
<li><strong>双向链表（Doubly Linked List）：</strong> 每个节点除了指向下一个节点的指针 <code>next</code> 外，还包含一个指向前一个节点的指针 <code>prev</code>。这使得链表可以双向遍历，但需要额外的空间存储 <code>prev</code> 指针。</li>
<li><strong>循环链表（Circular Linked List）：</strong> 链表的最后一个节点的 <code>next</code> 指针不是 <code>NULL</code>，而是指向头节点，形成一个环。</li>
</ul>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><h4 id="什么是双向链表？"><a href="#什么是双向链表？" class="headerlink" title="什么是双向链表？"></a>什么是双向链表？</h4><p>双向链表，顾名思义，就是每个节点不仅知道“下一个”是谁，也知道“上一个”是谁。它在单向链表的基础上，为每个节点额外增加了一个指向前一个节点的指针。</p>
<p><strong>双向链表节点的结构：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义双向链表节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoublyNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;                 <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoublyNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 指向前一个节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoublyNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; DoublyNode;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li><strong>双向遍历：</strong> 可以从头到尾遍历，也可以从尾到头遍历。</li>
<li><strong>插入和删除更灵活：</strong> 在已知待操作节点的情况下，其前驱和后继节点都可以直接访问，从而简化了插入和删除操作（特别是删除指定节点）。</li>
<li><strong>空间开销增加：</strong> 每个节点需要额外存储一个 <code>prev</code> 指针，因此比单向链表占用更多内存。</li>
</ul>
<h4 id="双向链表的基本操作"><a href="#双向链表的基本操作" class="headerlink" title="双向链表的基本操作"></a>双向链表的基本操作</h4><p>我们将重点展示与单向链表不同的或更高效的操作。</p>
<h5 id="创建新节点"><a href="#创建新节点" class="headerlink" title="创建新节点"></a>创建新节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个双向链表新节点</span></span><br><span class="line">DoublyNode* <span class="title function_">createDoublyNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    DoublyNode* newNode = (DoublyNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoublyNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;prev = <span class="literal">NULL</span>; <span class="comment">// 新节点的prev和next初始都为NULL</span></span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在链表头部插入节点"><a href="#在链表头部插入节点" class="headerlink" title="在链表头部插入节点"></a>在链表头部插入节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在双向链表头部插入节点</span></span><br><span class="line">DoublyNode* <span class="title function_">insertDoublyAtHead</span><span class="params">(DoublyNode* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    DoublyNode* newNode = createDoublyNode(value);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果链表为空</span></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;next = head; <span class="comment">// 新节点指向原来的头节点</span></span><br><span class="line">    head-&gt;prev = newNode; <span class="comment">// 原头节点的prev指向新节点</span></span><br><span class="line">    <span class="keyword">return</span> newNode;       <span class="comment">// 返回新节点作为新的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在链表尾部插入节点"><a href="#在链表尾部插入节点" class="headerlink" title="在链表尾部插入节点"></a>在链表尾部插入节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在双向链表尾部插入节点</span></span><br><span class="line">DoublyNode* <span class="title function_">insertDoublyAtTail</span><span class="params">(DoublyNode* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    DoublyNode* newNode = createDoublyNode(value);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果链表为空</span></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    DoublyNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 遍历到链表尾部</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = newNode; <span class="comment">// 尾节点的next指向新节点</span></span><br><span class="line">    newNode-&gt;prev = current; <span class="comment">// 新节点的prev指向原来的尾节点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在指定节点后插入"><a href="#在指定节点后插入" class="headerlink" title="在指定节点后插入"></a>在指定节点后插入</h5><p>这是双向链表的一个便利之处，单向链表需要找到前驱节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在指定节点后面插入新节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertAfterNode</span><span class="params">(DoublyNode* node, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法在空节点后插入。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DoublyNode* newNode = createDoublyNode(value);</span><br><span class="line">    newNode-&gt;next = node-&gt;next; <span class="comment">// 新节点指向node的下一个节点</span></span><br><span class="line">    newNode-&gt;prev = node;       <span class="comment">// 新节点指向node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果node不是最后一个节点</span></span><br><span class="line">        node-&gt;next-&gt;prev = newNode; <span class="comment">// node的下一个节点的prev指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;next = newNode;       <span class="comment">// node的next指向新节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除指定节点（已知节点指针）</p>
<p>这也是双向链表删除操作的优势。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定节点（给定节点指针）</span></span><br><span class="line"><span class="comment">// 注意：如果删除的是头节点，需要更新头指针</span></span><br><span class="line">DoublyNode* <span class="title function_">deleteGivenDoublyNode</span><span class="params">(DoublyNode* head, DoublyNode* nodeToDelete)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || nodeToDelete == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head; <span class="comment">// 链表为空或待删除节点为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodeToDelete == head) &#123; <span class="comment">// 删除头节点</span></span><br><span class="line">        head = nodeToDelete-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nodeToDelete-&gt;prev-&gt;next = nodeToDelete-&gt;next; <span class="comment">// 前驱节点的next指向待删除节点的next</span></span><br><span class="line">        <span class="keyword">if</span> (nodeToDelete-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果不是尾节点</span></span><br><span class="line">            nodeToDelete-&gt;next-&gt;prev = nodeToDelete-&gt;prev; <span class="comment">// 后继节点的prev指向待删除节点的prev</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(nodeToDelete); <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历双向链表（正向和反向）"><a href="#遍历双向链表（正向和反向）" class="headerlink" title="遍历双向链表（正向和反向）"></a>遍历双向链表（正向和反向）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正向打印双向链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printDoublyLinkedListForward</span><span class="params">(DoublyNode* head)</span> &#123;</span><br><span class="line">    DoublyNode* current = head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;双向链表（正向）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &lt;-&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向打印双向链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printDoublyLinkedListBackward</span><span class="params">(DoublyNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;双向链表（反向）：NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DoublyNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 先找到尾节点</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;双向链表（反向）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &lt;-&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放双向链表内存"><a href="#释放双向链表内存" class="headerlink" title="释放双向链表内存"></a>释放双向链表内存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放双向链表所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeDoublyLinkedList</span><span class="params">(DoublyNode* head)</span> &#123;</span><br><span class="line">    DoublyNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DoublyNode* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;双向链表内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环链表（Circular-Linked-List）"><a href="#循环链表（Circular-Linked-List）" class="headerlink" title="循环链表（Circular Linked List）"></a>循环链表（Circular Linked List）</h3><h4 id="什么是循环链表？"><a href="#什么是循环链表？" class="headerlink" title="什么是循环链表？"></a>什么是循环链表？</h4><p>循环链表是一种特殊的单向链表（也可以是双向的）。它的最后一个节点的 <code>next</code> 指针不是指向 <code>NULL</code>，而是指向链表的<strong>头节点</strong>，形成一个环。</p>
<p><strong>循环链表节点的结构（与单向链表相同）：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义循环链表节点结构体 (与单向链表相同)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CircularNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CircularNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; CircularNode;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li><strong>无“尾”概念：</strong> 链表中没有真正的“尾节点”（其 <code>next</code> 指向 <code>NULL</code> 的节点），遍历可以无限进行下去，直到回到起点。</li>
<li><strong>从任何节点开始遍历：</strong> 从链表中的任何一个节点开始，都可以遍历到所有节点。</li>
<li><strong>插入删除无需特殊处理头尾：</strong> 插入和删除操作相对单向链表在处理头尾时更统一。</li>
<li><strong>遍历需要停止条件：</strong> 需要额外的逻辑来判断是否已经遍历了一圈，避免无限循环。</li>
</ul>
<h4 id="2-循环链表的基本操作"><a href="#2-循环链表的基本操作" class="headerlink" title="2 循环链表的基本操作"></a>2 循环链表的基本操作</h4><p>由于循环链表的结构与单向链表相似，许多操作逻辑是类似的，但需要注意“环”的特性。为了简化，我们通常会维护一个指向<strong>尾节点</strong>的指针，而不是头节点。因为通过尾节点，可以 O(1) 时间访问到头节点（<code>tail-&gt;next</code> 就是头节点）。</p>
<h5 id="创建新节点（与单向链表相同）"><a href="#创建新节点（与单向链表相同）" class="headerlink" title="创建新节点（与单向链表相同）"></a>创建新节点（与单向链表相同）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个循环链表新节点</span></span><br><span class="line">CircularNode* <span class="title function_">createCircularNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    CircularNode* newNode = (CircularNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CircularNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 初始时指向NULL</span></span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="循环链表的初始化（返回尾指针）"><a href="#循环链表的初始化（返回尾指针）" class="headerlink" title="循环链表的初始化（返回尾指针）"></a>循环链表的初始化（返回尾指针）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空循环链表（返回尾指针）</span></span><br><span class="line">CircularNode* <span class="title function_">initCircularLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 空循环链表的尾指针指向NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在链表头部插入节点-1"><a href="#在链表头部插入节点-1" class="headerlink" title="在链表头部插入节点"></a>在链表头部插入节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在循环链表头部插入节点 (tail指向尾节点)</span></span><br><span class="line">CircularNode* <span class="title function_">insertCircularAtHead</span><span class="params">(CircularNode* tail, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    CircularNode* newNode = createCircularNode(value);</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) &#123; <span class="comment">// 链表为空时，新节点就是头也是尾</span></span><br><span class="line">        newNode-&gt;next = newNode; <span class="comment">// 自己指向自己</span></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode-&gt;next = tail-&gt;next; <span class="comment">// 新节点指向原来的头节点</span></span><br><span class="line">        tail-&gt;next = newNode;       <span class="comment">// 尾节点指向新节点</span></span><br><span class="line">        <span class="keyword">return</span> tail;                <span class="comment">// 返回尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在链表尾部插入节点-1"><a href="#在链表尾部插入节点-1" class="headerlink" title="在链表尾部插入节点"></a>在链表尾部插入节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在循环链表尾部插入节点 (tail指向尾节点)</span></span><br><span class="line">CircularNode* <span class="title function_">insertCircularAtTail</span><span class="params">(CircularNode* tail, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    CircularNode* newNode = createCircularNode(value);</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) &#123; <span class="comment">// 链表为空时，新节点就是头也是尾</span></span><br><span class="line">        newNode-&gt;next = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode-&gt;next = tail-&gt;next; <span class="comment">// 新节点指向头节点</span></span><br><span class="line">        tail-&gt;next = newNode;       <span class="comment">// 原尾节点指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode; <span class="comment">// 返回新节点作为新的尾节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历循环链表并打印数据"><a href="#遍历循环链表并打印数据" class="headerlink" title="遍历循环链表并打印数据"></a>遍历循环链表并打印数据</h5><p>需要一个额外的条件来判断是否已经回到起点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印循环链表所有节点的数据 (tail指向尾节点)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printCircularLinkedList</span><span class="params">(CircularNode* tail)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;循环链表内容：NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CircularNode* head = tail-&gt;next; <span class="comment">// 头节点</span></span><br><span class="line">    CircularNode* current = head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;循环链表内容：&quot;</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != head); <span class="comment">// 遍历直到回到头节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;... (循环回到 %d)\n&quot;</span>, head-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除节点（已知尾节点和待删除值）"><a href="#删除节点（已知尾节点和待删除值）" class="headerlink" title="删除节点（已知尾节点和待删除值）"></a>删除节点（已知尾节点和待删除值）</h5><p>删除循环链表节点需要更细致的判断，特别是当只剩一个节点或删除头&#x2F;尾节点时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除循环链表中指定值的节点 (tail指向尾节点)</span></span><br><span class="line">CircularNode* <span class="title function_">deleteCircularNode</span><span class="params">(CircularNode* tail, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;循环链表为空，无法删除。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CircularNode* head = tail-&gt;next; <span class="comment">// 获取头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只有一个节点且是待删除节点</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail &amp;&amp; head-&gt;data == value) &#123;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功删除唯一节点 %d。\n&quot;</span>, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 链表变空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;data == value) &#123;</span><br><span class="line">        tail-&gt;next = head-&gt;next; <span class="comment">// 尾节点指向新的头节点</span></span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功删除头节点 %d。\n&quot;</span>, value);</span><br><span class="line">        <span class="keyword">return</span> tail; <span class="comment">// 返回原来的尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除中间或尾部节点</span></span><br><span class="line">    CircularNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != head &amp;&amp; current-&gt;next-&gt;data != value) &#123; <span class="comment">// 遍历直到找到或遍历一圈</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next-&gt;data == value) &#123; <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">        CircularNode* temp = current-&gt;next;</span><br><span class="line">        current-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (temp == tail) &#123; <span class="comment">// 如果删除的是尾节点，更新tail</span></span><br><span class="line">            tail = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功删除节点 %d。\n&quot;</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 %d 的节点进行删除。\n&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放循环链表内存"><a href="#释放循环链表内存" class="headerlink" title="释放循环链表内存"></a>释放循环链表内存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放循环链表所有节点的内存 (tail指向尾节点)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeCircularLinkedList</span><span class="params">(CircularNode* tail)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;循环链表已空，无需释放。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CircularNode* head = tail-&gt;next;</span><br><span class="line">    CircularNode* current = head;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        CircularNode* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != head); <span class="comment">// 遍历直到回到头节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;循环链表内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-二分" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/%E4%BA%8C%E5%88%86/" class="article-date">
      <time datetime="2025-05-30T12:04:33.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/%E4%BA%8C%E5%88%86/">二分</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>思想很容易理解，但是写起来可能就会出现很多问题，下面给出一套完整的模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 upper_bound，返回 &lt;= target 的最大下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_upper_bound</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> r = n;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 lower_bound，返回 &gt;= target 的最小下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_lower_bound</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> r = n;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化有序数组</span></span><br><span class="line">    nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> target = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> lo = <span class="built_in">my_lower_bound</span>(target);</span><br><span class="line">    <span class="type">int</span> up = <span class="built_in">my_upper_bound</span>(target);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Target: &quot;</span> &lt;&lt; target &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lower bound index: &quot;</span> &lt;&lt; lo &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; (lo &lt; n ? nums[lo] : <span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Upper bound index: &quot;</span> &lt;&lt; up &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; (up &gt;= <span class="number">0</span> ? nums[up] : <span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-欧拉质数筛" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/%E6%AC%A7%E6%8B%89%E8%B4%A8%E6%95%B0%E7%AD%9B/" class="article-date">
      <time datetime="2025-05-30T12:04:20.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/%E6%AC%A7%E6%8B%89%E8%B4%A8%E6%95%B0%E7%AD%9B/">欧拉质数筛</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="欧拉质数筛"><a href="#欧拉质数筛" class="headerlink" title="欧拉质数筛"></a>欧拉质数筛</h1><p>欧拉质数筛是一种时间复杂度为O(n)快速找出1~n之间的质数的算法</p>
<p><strong>核心思想是：每个合数制备他的最小质因子筛一次，从而保证时间复杂度为O(n)</strong></p>
<p>详细算法：</p>
<ol>
<li><p>从小到大枚举每个整数 <code>i</code>，如果 <code>is_prime[i] == true</code>，说明它是一个质数，加入质数表。</p>
</li>
<li><p>用所有已知的质数 <code>p</code> 去筛掉 <code>i * p</code>：标记 <code>i * p</code> 为合数（<code>is_prime[i * p] = false</code>）。</p>
</li>
<li><p>一旦 <code>p</code> 是 <code>i</code> 的最小质因子（即 <code>i % p == 0</code>），就<strong>停止筛这个 <code>i</code> 后面的合数</strong>：因为 <code>i * p1</code>（p1 &gt; p）在后面一定会由更小的因子组合构造出来，重复了。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> is_prime[<span class="number">10000</span> + <span class="number">4</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">euler_prime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(is_prime, is_prime + n + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(is_prime[i] == <span class="literal">true</span>)</span><br><span class="line">			primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> p : primes)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i * p &gt; n)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			is_prime[i * p] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % p == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">euler_prime</span>(n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; primes.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    	cout &lt;&lt; primes[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">euler_sieve</span>(<span class="params">n</span>):</span><br><span class="line">    is_prime = [<span class="literal">True</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">    primes = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> is_prime[i]:</span><br><span class="line">            primes.append(i)</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> primes:</span><br><span class="line">            <span class="keyword">if</span> i * p &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            is_prime[i * p] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i % p == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> primes</span><br><span class="line"></span><br><span class="line">n = <span class="number">10000</span></span><br><span class="line">primes = euler_sieve(n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, primes)))</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2025 John Doe
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>