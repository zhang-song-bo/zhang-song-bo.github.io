<!DOCTYPE html>
<html lang="en">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="John Doe" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">



<link rel="stylesheet" href="/css/style.css">



    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Hexo</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        <li>Friends</li>
                        
                        
                        <li>About Me</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                            <li><a href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E8%AE%B0/">生活随记</a></li>
                        
                            <li><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li>
                        
                            <li><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li>
                        
                            <li><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACGAN/" rel="tag">ACGAN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BERT/" rel="tag">BERT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CycleGAN/" rel="tag">CycleGAN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DCGAN/" rel="tag">DCGAN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GAN/" rel="tag">GAN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLM/" rel="tag">LLM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LLM-Evaluation/" rel="tag">LLM Evaluation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LoRA/" rel="tag">LoRA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Multi-Agent/" rel="tag">Multi-Agent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NLP/" rel="tag">NLP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Prompt-Engineering/" rel="tag">Prompt Engineering</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVM/" rel="tag">SVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TF-IDF/" rel="tag">TF-IDF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Transformer/" rel="tag">Transformer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WGAN/" rel="tag">WGAN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WGAN-GP/" rel="tag">WGAN-GP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/agent/" rel="tag">agent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/multi-agent/" rel="tag">multi-agent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/" rel="tag">优化技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E5%8F%96/" rel="tag">关键词提取</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B7%E8%BA%AB%E6%99%BA%E8%83%BD/" rel="tag">具身智能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/" rel="tag">分类模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/" rel="tag">分类算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%83%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/" rel="tag">图像风格迁移</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E9%BD%90/" rel="tag">对齐</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" rel="tag">强化学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E8%B0%83/" rel="tag">微调</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A8%E7%90%86%E4%BC%98%E5%8C%96/" rel="tag">推理优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" rel="tag">支持向量机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/" rel="tag">文本分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9E%8B/" rel="tag">模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%8B%9F%E4%BA%BA%E7%B1%BB%E8%A1%8C%E4%B8%BA/" rel="tag">模拟人类行为</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" rel="tag">线性回归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/" rel="tag">逻辑回归</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/about/">关于我</a></li>
                
                    <li><a href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E8%AE%B0/">生活随记</a></li>
                
                    <li><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li>
                
                    <li><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li>
                
                    <li><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-RLHF" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/06/08/RLHF/" class="article-date">
      <time datetime="2025-06-08T14:42:01.000Z" itemprop="datePublished">2025-06-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/06/08/RLHF/">RLHF</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="RLHF-Reinforcement-Learning-from-Human-Feedback"><a href="#RLHF-Reinforcement-Learning-from-Human-Feedback" class="headerlink" title="RLHF: Reinforcement Learning from Human Feedback"></a>RLHF: Reinforcement Learning from Human Feedback</h1><h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>随着大型语言模型（LLMs）能力的飞速增长，它们在生成文本、回答问题等方面表现出惊人的潜力。然而，这些模型在预训练阶段主要通过预测下一个词来学习，这使得它们在面对人类复杂指令时，可能生成不符合人类意图、不安全、不准确或带有偏见的内容。为了使 LLMs 更好地理解和遵循人类的价值观、偏好和指令，仅仅依赖大规模的文本数据进行预训练是不足够的。RLHF（Reinforcement Learning from Human Feedback）应运而生，旨在通过引入人类的反馈来对齐模型行为，使其更加有用、无害和诚实。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>RLHF 的核心理念是：<strong>通过收集人类对模型生成内容的偏好或质量评分，训练一个奖励模型（Reward Model），然后利用这个奖励模型作为强化学习的奖励信号，对语言模型进行微调，使其生成更符合人类期望的内容。</strong></p>
<p>通过这种方式，RLHF 实现了以下目标：</p>
<ul>
<li><strong>对齐模型行为</strong>：使模型生成的内容更符合人类的偏好、意图和安全准则。</li>
<li><strong>提升用户体验</strong>：提高模型回答的有用性、准确性和自然性。</li>
<li><strong>处理复杂偏好</strong>：能够捕捉并优化人类对语言模型输出的细微、多维度的偏好。</li>
</ul>
<h2 id="方法流程详解"><a href="#方法流程详解" class="headerlink" title="方法流程详解"></a>方法流程详解</h2><p>RLHF 的实现过程通常分为以下三个主要步骤：</p>
<ol>
<li><strong>预训练语言模型（Pre-trained Language Model）</strong>：<ul>
<li>首先，使用大规模文本数据训练一个基础的大型语言模型（例如 GPT-3、PaLM 等）。这个模型是 RLHF 流程的起点，它拥有广泛的语言理解和生成能力。</li>
</ul>
</li>
<li><strong>训练奖励模型（Reward Model - RM）</strong>：<ul>
<li><strong>数据收集</strong>：从预训练的语言模型中抽取一组提示（prompt），并让模型生成多个不同的响应。然后，聘请人类标注员对这些模型生成的响应进行排序或打分，以表达他们对这些响应质量的偏好。例如，对于同一个提示，人类标注员会比较两个或更多个模型响应，并指出哪个更好。</li>
<li><strong>模型训练</strong>：基于这些人类偏好数据，训练一个独立的奖励模型。这个奖励模型是一个特殊的机器学习模型（通常也是一个 Transformer 模型），它的输入是提示和模型响应，输出是一个标量值，代表该响应在人类看来有多“好”或多符合偏好。奖励模型的目标是学习并准确预测人类的偏好。</li>
</ul>
</li>
<li><strong>使用强化学习微调语言模型（Fine-tuning with Reinforcement Learning）</strong>：<ul>
<li><strong>策略定义</strong>：将预训练的语言模型视为一个策略（policy），它在给定提示的情况下生成响应。</li>
<li><strong>PPO 算法</strong>：通常采用近端策略优化（Proximal Policy Optimization, PPO）等强化学习算法。在这个阶段，语言模型在新的提示下生成响应。</li>
<li><strong>奖励信号</strong>：生成的响应被输入到之前训练好的奖励模型中，由奖励模型给出实时的奖励分数。</li>
<li><strong>模型更新</strong>：根据奖励模型的反馈，强化学习算法调整语言模型的参数，使其生成更高奖励分数的响应。为了防止模型在优化奖励时偏离原始预训练模型太远，通常会引入一个 KL 散度惩罚项，限制微调后的模型与原始模型之间的差异，确保模型在学习新行为的同时保持其语言生成能力和泛化性。</li>
</ul>
</li>
</ol>
<h2 id="实验设置与结果"><a href="#实验设置与结果" class="headerlink" title="实验设置与结果"></a>实验设置与结果</h2><p>RLHF 在多个大型语言模型上得到了广泛应用和验证，其中最著名的成功案例是 OpenAI 的 ChatGPT 和 InstructGPT。</p>
<ul>
<li><strong>InstructGPT</strong>：OpenAI 详细介绍了通过 RLHF 训练 InstructGPT 的过程。实验结果表明，与 GPT-3 相比，InstructGPT 在遵循指令和生成有用、无害响应方面表现显著提升，即使模型参数量更小。人类评估员普遍认为 InstructGPT 生成的响应质量更高，更容易遵循指令，且减少了不真实和有害的输出。</li>
<li><strong>ChatGPT</strong>：作为 InstructGPT 的后续工作，ChatGPT 进一步展示了 RLHF 在构建会话式 AI 方面的巨大潜力。它能够进行连贯的多轮对话，回答复杂问题，撰写不同风格的文本，并在很大程度上避免了有害或偏见的回答，这都归功于其背后复杂的 RLHF 对齐过程。</li>
<li><strong>其他应用</strong>：RLHF 也被用于代码生成（如 GitHub Copilot 的某些版本）、安全内容过滤等领域，以提升模型在特定任务上的表现和安全性。</li>
</ul>
<p>总的来说，RLHF 使得大型语言模型能够更好地与人类意图对齐，显著提升了它们的可用性和安全性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RLHF 提供了一种强大的方法，通过融合人类反馈和强化学习，将大型语言模型从单纯的“下一个词预测器”转变为能够更好地理解和响应人类指令的“助手”。它解决了传统预训练模型在对齐人类价值观和偏好方面的不足，是构建负责任和有用 AI 的关键技术。</p>
<h2 id="如何使用-概念性说明"><a href="#如何使用-概念性说明" class="headerlink" title="如何使用 (概念性说明)"></a>如何使用 (概念性说明)</h2><p>RLHF 的实现通常需要大量的计算资源、专业的数据标注团队和复杂的工程实践。对于个人或中小型团队，直接从零开始实现完整的 RLHF 流程非常具有挑战性。然而，我们可以利用现有的开源库和工具，或基于已经过 RLHF 对齐的模型进行进一步的微调。</p>
<h3 id="1-理解-RLHF-流程的组件"><a href="#1-理解-RLHF-流程的组件" class="headerlink" title="1. 理解 RLHF 流程的组件"></a>1. 理解 RLHF 流程的组件</h3><ul>
<li><strong>基础模型</strong>：一个强大的预训练语言模型（例如 <code>llama-2-7b-chat</code>，它已经通过 RLHF 进行了对齐）。</li>
<li><strong>奖励模型</strong>：一个能够评估模型输出质量的模型。这通常需要通过人类偏好数据训练。</li>
<li><strong>强化学习算法</strong>：如 PPO，用于根据奖励信号优化语言模型。</li>
</ul>
<h3 id="2-使用现有工具和框架-概念性代码示例"><a href="#2-使用现有工具和框架-概念性代码示例" class="headerlink" title="2. 使用现有工具和框架 (概念性代码示例)"></a>2. 使用现有工具和框架 (概念性代码示例)</h3><p>虽然完整的 RLHF 流程复杂，但像 Hugging Face 的 <code>trl</code> (Transformer Reinforcement Learning) 库提供了一些模块化的组件和示例，可以帮助研究人员和开发者尝试 RLHF 的某些部分。</p>
<p>以下是一个非常高层的、概念性的代码流程，展示如何使用 <code>trl</code> 库的 PPO 训练器。请注意，这只是一个简化示例，实际应用需要更详细的数据准备和参数配置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设已经安装了必要的库：pip install transformers accelerate trl peft bitsandbytes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer, AutoModelForCausalLM, pipeline</span><br><span class="line"><span class="keyword">from</span> trl <span class="keyword">import</span> PPOTrainer, PPOConfig</span><br><span class="line"><span class="keyword">from</span> trl.core <span class="keyword">import</span> LengthSampler</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 加载一个基础的对齐模型（例如，一个已经过SFT的模型）</span></span><br><span class="line"><span class="comment"># 实际RLHF通常从SFT（监督微调）后的模型开始</span></span><br><span class="line">model_name = <span class="string">&quot;mistralai/Mistral-7B-Instruct-v0.2&quot;</span> <span class="comment"># 示例：一个Instruct模型</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_name)</span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_name, torch_dtype=torch.float16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保tokenizer有pad_token，对于生成任务尤其重要</span></span><br><span class="line"><span class="keyword">if</span> tokenizer.pad_token <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    tokenizer.pad_token = tokenizer.eos_token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 假设我们有一个奖励模型（Reward Model）</span></span><br><span class="line"><span class="comment"># 在实际情况中，奖励模型需要单独训练</span></span><br><span class="line"><span class="comment"># 这里我们创建一个模拟奖励模型，实际中会是一个经过训练的Transformer模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DummyRewardModel</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># 这是一个非常简化的模拟，实际奖励模型会是一个transformer模型</span></span><br><span class="line">        <span class="variable language_">self</span>.dummy_head = torch.nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, input_ids, attention_mask=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># 假设奖励只是一个随机值，实际会根据response的内容计算</span></span><br><span class="line">        <span class="comment"># input_ids 和 attention_mask 实际会被用来计算embedding，然后传递给分类头</span></span><br><span class="line">        <span class="keyword">return</span> torch.randn(input_ids.shape[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">reward_model = DummyRewardModel()</span><br><span class="line"><span class="comment"># 或者加载一个预训练的奖励模型：</span></span><br><span class="line"><span class="comment"># from trl import AutoModelForSequenceClassification</span></span><br><span class="line"><span class="comment"># reward_model = AutoModelForSequenceClassification.from_pretrained(&quot;path_to_reward_model&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 定义PPO配置</span></span><br><span class="line">ppo_config = PPOConfig(</span><br><span class="line">    learning_rate=<span class="number">1e-5</span>,</span><br><span class="line">    ppo_epochs=<span class="number">4</span>,</span><br><span class="line">    mini_batch_size=<span class="number">4</span>,</span><br><span class="line">    batch_size=<span class="number">16</span>,</span><br><span class="line">    target_kl=<span class="number">0.1</span>, <span class="comment"># KL散度惩罚，防止模型偏离原始行为太远</span></span><br><span class="line">    seed=<span class="number">42</span>,</span><br><span class="line">    <span class="comment"># 其他参数...</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 初始化PPOTrainer</span></span><br><span class="line"><span class="comment"># model: 要训练的语言模型</span></span><br><span class="line"><span class="comment"># ref_model: 参考模型，用于计算KL散度，通常是SFT后的模型副本</span></span><br><span class="line"><span class="comment"># tokenizer: 分词器</span></span><br><span class="line"><span class="comment"># reward_model: 奖励模型</span></span><br><span class="line"><span class="comment"># dataset: 训练数据集，包含prompt</span></span><br><span class="line">ppo_trainer = PPOTrainer(</span><br><span class="line">    config=ppo_config,</span><br><span class="line">    model=model,</span><br><span class="line">    ref_model=<span class="literal">None</span>, <span class="comment"># 可以是model的副本，或者一个冻结的SFT模型</span></span><br><span class="line">    tokenizer=tokenizer,</span><br><span class="line">    reward_model=reward_model,</span><br><span class="line">    <span class="comment"># 数据集准备：</span></span><br><span class="line">    <span class="comment"># dataset = dataset.map(lambda x: &#123;&quot;query&quot;: tokenizer(x[&quot;prompt&quot;], return_tensors=&quot;pt&quot;)&#125;)</span></span><br><span class="line">    <span class="comment"># dummy_dataset = [&#123;&quot;query&quot;: tokenizer(&quot;Tell me a story about a dragon.&quot;, return_tensors=&quot;pt&quot;)&#125;]</span></span><br><span class="line">    <span class="comment"># 这里需要实际的prompt数据集</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 定义一个生成函数</span></span><br><span class="line"><span class="comment"># 实际中会使用model.generate，这里是PPOTrainer的示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_response</span>(<span class="params">prompts</span>):</span><br><span class="line">    <span class="comment"># This function would typically generate responses from the current policy model</span></span><br><span class="line">    <span class="comment"># and would be called internally by PPOTrainer.</span></span><br><span class="line">    <span class="comment"># For demonstration, let&#x27;s just make a dummy generation.</span></span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="keyword">for</span> prompt <span class="keyword">in</span> prompts:</span><br><span class="line">        input_ids = tokenizer.encode(prompt, return_tensors=<span class="string">&quot;pt&quot;</span>)</span><br><span class="line">        generated_ids = ppo_trainer.accelerator.unwrap_model(ppo_trainer.model).generate(</span><br><span class="line">            input_ids.to(ppo_trainer.accelerator.device),</span><br><span class="line">            max_new_tokens=<span class="number">50</span>,</span><br><span class="line">            do_sample=<span class="literal">True</span>,</span><br><span class="line">            top_k=<span class="number">0</span>,</span><br><span class="line">            top_p=<span class="number">1.0</span>,</span><br><span class="line">            eos_token_id=tokenizer.eos_token_id,</span><br><span class="line">            pad_token_id=tokenizer.pad_token_id,</span><br><span class="line">        )</span><br><span class="line">        outputs.append(tokenizer.decode(generated_ids[<span class="number">0</span>][<span class="built_in">len</span>(input_ids[<span class="number">0</span>]):], skip_special_tokens=<span class="literal">True</span>))</span><br><span class="line">    <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. PPO 训练循环 (概念性)</span></span><br><span class="line"><span class="comment"># 实际中，PPOTrainer 会自动处理这个循环</span></span><br><span class="line"><span class="comment"># ppo_trainer.learn()</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 以下是一个模拟训练循环的结构，用于说明概念：</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(ppo_config.ppo_epochs):</span><br><span class="line">    <span class="comment"># 模拟数据批次</span></span><br><span class="line">    dummy_prompts = [<span class="string">&quot;Tell me a joke.&quot;</span>, <span class="string">&quot;Write a short poem.&quot;</span>, <span class="string">&quot;Explain quantum physics simply.&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1. 收集批次的提示和模型响应</span></span><br><span class="line">    query_tensors = [tokenizer.encode(q, return_tensors=<span class="string">&quot;pt&quot;</span>).squeeze(<span class="number">0</span>) <span class="keyword">for</span> q <span class="keyword">in</span> dummy_prompts]</span><br><span class="line">    responses = generate_response(dummy_prompts) <span class="comment"># PPOTrainer内部调用</span></span><br><span class="line">    response_tensors = [tokenizer.encode(r, return_tensors=<span class="string">&quot;pt&quot;</span>).squeeze(<span class="number">0</span>) </span><br><span class="line">                        <span class="keyword">for</span> r <span class="keyword">in</span> [<span class="string">&quot;Why did the scarecrow win an award? Because he was outstanding in his field!&quot;</span>, <span class="string">&quot;The moon shines bright, a silvery light.&quot;</span>, <span class="string">&quot;It&#x27;s super small stuff that makes up everything.&quot;</span>]]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 计算奖励</span></span><br><span class="line">    rewards = []</span><br><span class="line">    <span class="keyword">for</span> q_t, r_t <span class="keyword">in</span> <span class="built_in">zip</span>(query_tensors, response_tensors):</span><br><span class="line">        full_text_tensor = torch.cat([q_t, r_t])</span><br><span class="line">        <span class="comment"># reward_score = reward_model(full_text_tensor.unsqueeze(0)).item() # 实际会batch处理</span></span><br><span class="line">        rewards.append(torch.tensor(<span class="variable language_">self</span>.reward_model(torch.randn(<span class="number">1</span>,<span class="number">1</span>)).item())) <span class="comment"># 假设的随机奖励</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. PPO 优化步骤</span></span><br><span class="line">    ppo_trainer.step(query_tensors, response_tensors, rewards)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Epoch <span class="subst">&#123;epoch&#125;</span>: Simulating PPO step with rewards: <span class="subst">&#123;rewards&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 保存模型</span></span><br><span class="line">ppo_trainer.save_pretrained(<span class="string">&quot;my_rlhf_model&quot;</span>)</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLM/" rel="tag">LLM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%B9%E9%BD%90/" rel="tag">对齐</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" rel="tag">强化学习</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-prefix-turning" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/06/08/prefix-turning/" class="article-date">
      <time datetime="2025-06-08T14:18:15.000Z" itemprop="datePublished">2025-06-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/06/08/prefix-turning/">prefix turning</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Prefix-Tuning-Optimizing-Continuous-Prompts-for-Large-Language-Models"><a href="#Prefix-Tuning-Optimizing-Continuous-Prompts-for-Large-Language-Models" class="headerlink" title="Prefix Tuning: Optimizing Continuous Prompts for Large Language Models"></a>Prefix Tuning: Optimizing Continuous Prompts for Large Language Models</h1><p>原论文链接：arXiv:2101.00190</p>
<p>项目主页：GitHub - XiangLi1999&#x2F;PrefixTuning</p>
<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>大型语言模型（LLMs）在自然语言处理任务中展现出强大的能力。然而，为了使这些模型适应特定下游任务，通常需要进行微调。传统的全量微调方法涉及更新模型的所有参数，这不仅计算成本高昂，而且对存储资源的需求也很大。提示工程（Prompt Engineering）作为一种无需修改模型参数即可引导模型行为的方法，虽然可以降低成本，但在复杂任务上表现往往不如微调。为了结合两者的优势，同时避免各自的缺点，Prefix Tuning应运而生，它旨在通过优化少量的“前缀”参数来高效地适配大型模型。</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>Prefix Tuning 的核心思想是：<strong>在不修改大型预训练模型参数的情况下，通过在输入序列前添加一小段可训练的连续向量（即“前缀”），来引导模型执行特定任务</strong>。这些前缀向量可以看作是任务特定的“软提示”或“虚拟token”，它们与原始输入一起输入到模型中，从而在推理过程中影响模型的行为。</p>
<p>通过这种方式，Prefix Tuning 实现了以下目标：</p>
<ul>
<li><strong>参数高效</strong>：只训练前缀参数，模型的主体参数保持冻结，大大减少了可训练参数数量。</li>
<li><strong>性能接近全量微调</strong>：在许多任务上，Prefix Tuning 的性能可以与全量微调相媲美，甚至在某些情况下超越提示工程。</li>
<li><strong>易于任务切换</strong>：不同的任务只需替换不同的前缀，而无需重新加载整个模型。</li>
</ul>
<h2 id="方法流程详解"><a href="#方法流程详解" class="headerlink" title="方法流程详解"></a>方法流程详解</h2><p>Prefix Tuning 的实现过程如下：</p>
<ol>
<li><strong>冻结原始模型参数</strong>：预训练语言模型的原始权重（例如 GPT-2 或 T5）保持不变。</li>
<li><strong>引入可训练前缀</strong>：在模型的每一层或仅在输入层，引入一系列可训练的连续向量，这些向量构成了“前缀”。对于自回归模型（如GPT-2），前缀添加到输入序列的开头；对于编码器-解码器模型（如T5），前缀同时添加到编码器和解码器的输入中。</li>
<li><strong>训练前缀参数</strong>：在特定任务的数据集上，仅训练这些前缀向量的参数，以最小化任务相关的损失函数。模型的主体参数在整个训练过程中保持冻结。</li>
<li><strong>推理阶段</strong>：在推理时，将训练好的前缀向量与新的输入拼接在一起，然后将组合后的序列输入到冻结的预训练模型中进行预测。</li>
</ol>
<p>这种方法的优势在于，它将任务特定的知识编码到一小组连续的前缀向量中，从而实现了参数的高效适配。</p>
<h2 id="实验设置与结果"><a href="#实验设置与结果" class="headerlink" title="实验设置与结果"></a>实验设置与结果</h2><p>研究团队在多个生成式任务上对 Prefix Tuning 进行了评估，包括表格到文本生成（E2E NLG）、摘要（XSum）和问答（WebNLG）。实验结果表明，Prefix Tuning 在以下方面表现出色：</p>
<ul>
<li><strong>参数效率</strong>：在 GPT-2 上，Prefix Tuning 仅需训练0.1%的模型参数，即可达到与全量微调相近的性能。</li>
<li>性能表现：<ul>
<li>在E2E NLG任务上，Prefix Tuning 在数据量较少时优于全量微调，并且在完整数据集上与全量微调性能相当。</li>
<li>在XSum摘要任务上，Prefix Tuning 表现优于全量微调，达到了新的SOTA。</li>
<li>在WebNLG问答任务上，Prefix Tuning 在低数据量和完整数据集设置下都表现出色。</li>
</ul>
</li>
<li><strong>鲁棒性</strong>：Prefix Tuning 在低数据量场景下表现更稳定。</li>
</ul>
<p>此外，Prefix Tuning 在训练和推理阶段都不会引入显著的额外延迟，并且由于参数量极小，可以轻松切换不同任务的前缀。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Prefix Tuning 提供了一种高效且有效的大型语言模型微调方法，它通过优化少量的连续前缀向量来适配模型，从而显著降低了计算资源的需求，同时保持了模型的性能。其核心思想是利用可训练的软提示来引导冻结的预训练模型。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在实践中，使用 Prefix Tuning 对大型语言模型进行高效微调，可以显著减少训练所需的参数和计算资源。以下是一个典型的 Prefix Tuning 微调流程，适用于如 GPT-2、T5 等模型，结合了 Hugging Face Transformers 和 PEFT（Parameter-Efficient Fine-Tuning）库的使用。</p>
<h3 id="1-安装必要的库"><a href="#1-安装必要的库" class="headerlink" title="1. 安装必要的库"></a>1. 安装必要的库</h3><p>确保安装了以下 Python 库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch transformers datasets peft</span><br></pre></td></tr></table></figure>

<h3 id="2-加载预训练模型和分词器"><a href="#2-加载预训练模型和分词器" class="headerlink" title="2. 加载预训练模型和分词器"></a>2. 加载预训练模型和分词器</h3><p>以 GPT-2 模型为例，加载预训练模型和对应的分词器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer, AutoModelForCausalLM</span><br><span class="line"></span><br><span class="line">model_name = <span class="string">&quot;gpt2&quot;</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_name)</span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GPT-2 does not have a padding token by default, which is often needed for batching.</span></span><br><span class="line"><span class="keyword">if</span> tokenizer.pad_token <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    tokenizer.pad_token = tokenizer.eos_token</span><br></pre></td></tr></table></figure>

<h3 id="3-应用-Prefix-Tuning-配置"><a href="#3-应用-Prefix-Tuning-配置" class="headerlink" title="3. 应用 Prefix Tuning 配置"></a>3. 应用 Prefix Tuning 配置</h3><p>使用 PEFT 库配置 Prefix Tuning 参数，并将其应用到模型中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> peft <span class="keyword">import</span> get_peft_model, PrefixTuningConfig, TaskType</span><br><span class="line"></span><br><span class="line">prefix_config = PrefixTuningConfig(</span><br><span class="line">    task_type=TaskType.CAUSAL_LM, <span class="comment"># For causal language modeling tasks</span></span><br><span class="line">    num_virtual_tokens=<span class="number">20</span>,       <span class="comment"># Number of virtual tokens in the prefix</span></span><br><span class="line">    encoder_hidden_size=model.config.hidden_size <span class="comment"># Hidden size of the encoder (for GPT-2, it&#x27;s model.config.n_embd)</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">model = get_peft_model(model, prefix_config)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the number of trainable parameters</span></span><br><span class="line">model.print_trainable_parameters()</span><br></pre></td></tr></table></figure>

<p>在此配置中：</p>
<ul>
<li><code>task_type</code>：指定任务类型，例如 <code>TaskType.CAUSAL_LM</code> 用于自回归语言模型。</li>
<li><code>num_virtual_tokens</code>：前缀中虚拟token的数量，这个值通常需要根据任务和模型进行调整。</li>
<li><code>encoder_hidden_size</code>：模型的隐藏层维度。</li>
</ul>
<h3 id="4-准备训练数据"><a href="#4-准备训练数据" class="headerlink" title="4. 准备训练数据"></a>4. 准备训练数据</h3><p>使用 Hugging Face 的 <code>datasets</code> 库加载和预处理训练数据。对于文本生成任务，你需要将输入和目标文本拼接起来，并进行tokenization。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example: a simple text dataset</span></span><br><span class="line">data_files = &#123;<span class="string">&quot;train&quot;</span>: <span class="string">&quot;train.txt&quot;</span>, <span class="string">&quot;validation&quot;</span>: <span class="string">&quot;validation.txt&quot;</span>&#125;</span><br><span class="line">dataset = load_dataset(<span class="string">&quot;text&quot;</span>, data_files=data_files)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tokenize_function</span>(<span class="params">examples</span>):</span><br><span class="line">    <span class="comment"># This example assumes each line in your text file is a separate example.</span></span><br><span class="line">    <span class="comment"># For actual tasks, you&#x27;d structure your data as input-output pairs.</span></span><br><span class="line">    <span class="keyword">return</span> tokenizer(examples[<span class="string">&quot;text&quot;</span>], truncation=<span class="literal">True</span>, max_length=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">tokenized_dataset = dataset.<span class="built_in">map</span>(tokenize_function, batched=<span class="literal">True</span>, remove_columns=[<span class="string">&quot;text&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Format for PyTorch</span></span><br><span class="line">tokenized_dataset.set_format(<span class="string">&quot;torch&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Data collator for language modeling, which handles padding</span></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> DataCollatorForLanguageModeling</span><br><span class="line">data_collator = DataCollatorForLanguageModeling(tokenizer=tokenizer, mlm=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-定义训练参数和训练器"><a href="#5-定义训练参数和训练器" class="headerlink" title="5. 定义训练参数和训练器"></a>5. 定义训练参数和训练器</h3><p>设置训练参数，并使用 <code>Trainer</code> 进行模型训练：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> Trainer, TrainingArguments</span><br><span class="line"></span><br><span class="line">training_args = TrainingArguments(</span><br><span class="line">    output_dir=<span class="string">&quot;./prefix-tuning-gpt2&quot;</span>,</span><br><span class="line">    per_device_train_batch_size=<span class="number">4</span>,</span><br><span class="line">    num_train_epochs=<span class="number">3</span>,</span><br><span class="line">    learning_rate=<span class="number">5e-5</span>, <span class="comment"># Typically a lower learning rate than full fine-tuning</span></span><br><span class="line">    logging_dir=<span class="string">&quot;./logs&quot;</span>,</span><br><span class="line">    save_total_limit=<span class="number">2</span>,</span><br><span class="line">    save_steps=<span class="number">500</span>,</span><br><span class="line">    evaluation_strategy=<span class="string">&quot;steps&quot;</span>,</span><br><span class="line">    eval_steps=<span class="number">500</span>,</span><br><span class="line">    logging_steps=<span class="number">100</span>,</span><br><span class="line">    load_best_model_at_end=<span class="literal">True</span>,</span><br><span class="line">    report_to=<span class="string">&quot;none&quot;</span> <span class="comment"># Disable reporting to services like Weights &amp; Biases if not needed</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">trainer = Trainer(</span><br><span class="line">    model=model,</span><br><span class="line">    args=training_args,</span><br><span class="line">    train_dataset=tokenized_dataset[<span class="string">&quot;train&quot;</span>],</span><br><span class="line">    eval_dataset=tokenized_dataset[<span class="string">&quot;validation&quot;</span>],</span><br><span class="line">    data_collator=data_collator,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="6-开始训练"><a href="#6-开始训练" class="headerlink" title="6. 开始训练"></a>6. 开始训练</h3><p>启动训练过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainer.train()</span><br></pre></td></tr></table></figure>

<h3 id="7-保存和加载-Prefix-Tuning-模型"><a href="#7-保存和加载-Prefix-Tuning-模型" class="headerlink" title="7. 保存和加载 Prefix Tuning 模型"></a>7. 保存和加载 Prefix Tuning 模型</h3><p>训练完成后，保存 Prefix Tuning 模块的权重：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.save_pretrained(<span class="string">&quot;prefix-tuning-gpt2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在需要时，加载保存的模型进行推理或进一步训练。注意，加载时需要先加载原始预训练模型，然后加载PEFT模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> peft <span class="keyword">import</span> PeftModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the base model first</span></span><br><span class="line">base_model = AutoModelForCausalLM.from_pretrained(model_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the PeftModel (Prefix Tuning weights) on top of the base model</span></span><br><span class="line">peft_model = PeftModel.from_pretrained(base_model, <span class="string">&quot;prefix-tuning-gpt2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now peft_model can be used for inference or further training</span></span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLM/" rel="tag">LLM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Prompt-Engineering/" rel="tag">Prompt Engineering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E8%B0%83/" rel="tag">微调</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-队列-栈" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/06/04/%E9%98%9F%E5%88%97-%E6%A0%88/" class="article-date">
      <time datetime="2025-06-04T07:21:05.000Z" itemprop="datePublished">2025-06-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/06/04/%E9%98%9F%E5%88%97-%E6%A0%88/">队列/栈</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>栈（Stack）和队列（Queue）是两种非常重要且常用的线性数据结构。它们都限制了数据的插入和删除方式，使得它们在特定场景下表现出独特的优势。</p>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈是一种“后进先出”（Last In, First Out - LIFO）的数据结构。你可以把它想象成一叠盘子，你最后放上去的盘子，总是最先被拿走。</p>
<h4 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h4><ul>
<li><strong>栈顶（Top）</strong>: 栈中允许插入和删除元素的一端。</li>
<li><strong>栈底（Bottom）</strong>: 栈中不允许插入和删除元素的另一端。</li>
<li><strong>压栈&#x2F;入栈（Push）</strong>: 向栈中添加元素的操作。</li>
<li><strong>弹栈&#x2F;出栈（Pop）</strong>: 从栈中移除元素的操作。</li>
</ul>
<h4 id="C-语言中栈的实现"><a href="#C-语言中栈的实现" class="headerlink" title="C 语言中栈的实现"></a>C 语言中栈的实现</h4><p>栈可以使用数组或链表来实现。这里我们主要介绍基于<strong>链表</strong>的实现，因为它在动态大小方面更灵活。</p>
<h5 id="栈节点定义"><a href="#栈节点定义" class="headerlink" title="栈节点定义"></a>栈节点定义</h5><p>由于栈的特性，我们只需要单向链表的节点结构即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 包含 malloc 和 free 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义栈节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; StackNode;</span><br></pre></td></tr></table></figure>

<h5 id="栈的初始化"><a href="#栈的初始化" class="headerlink" title="栈的初始化"></a>栈的初始化</h5><p>栈的初始化就是将栈顶指针设为 <code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空栈（栈顶指针）</span></span><br><span class="line">StackNode* <span class="title function_">initStack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 空栈的栈顶指向NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="压栈-入栈操作-Push"><a href="#压栈-入栈操作-Push" class="headerlink" title="压栈&#x2F;入栈操作 (Push)"></a>压栈&#x2F;入栈操作 (Push)</h5><p>新元素总是插入到栈顶。这与链表的头部插入操作类似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压栈操作：向栈中添加元素</span></span><br><span class="line">StackNode* <span class="title function_">push</span><span class="params">(StackNode* top, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    StackNode* newNode = (StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode)); <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value; <span class="comment">// 设置数据</span></span><br><span class="line">    newNode-&gt;next = top;   <span class="comment">// 新节点的next指向原来的栈顶</span></span><br><span class="line">    <span class="keyword">return</span> newNode;        <span class="comment">// 返回新节点作为新的栈顶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="弹栈-出栈操作-Pop"><a href="#弹栈-出栈操作-Pop" class="headerlink" title="弹栈&#x2F;出栈操作 (Pop)"></a>弹栈&#x2F;出栈操作 (Pop)</h5><p>从栈顶移除元素。这与链表的头部删除操作类似，需要处理栈空的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹栈操作：从栈中移除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(StackNode** top)</span> &#123; <span class="comment">// 注意这里使用二级指针，因为需要修改top的值</span></span><br><span class="line">    <span class="keyword">if</span> (*top == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空，无法弹栈！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// 或者返回一个错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    StackNode* temp = *top;     <span class="comment">// 临时保存当前栈顶</span></span><br><span class="line">    <span class="type">int</span> poppedValue = temp-&gt;data; <span class="comment">// 获取栈顶数据</span></span><br><span class="line">    *top = (*top)-&gt;next;       <span class="comment">// 栈顶下移</span></span><br><span class="line">    <span class="built_in">free</span>(temp);                <span class="comment">// 释放原栈顶内存</span></span><br><span class="line">    <span class="keyword">return</span> poppedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查看栈顶元素-Peek-Top"><a href="#查看栈顶元素-Peek-Top" class="headerlink" title="查看栈顶元素 (Peek&#x2F;Top)"></a>查看栈顶元素 (Peek&#x2F;Top)</h5><p>不移除元素，只返回栈顶元素的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看栈顶元素（不移除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空，无法查看栈顶元素！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="判断栈是否为空-isEmpty"><a href="#判断栈是否为空-isEmpty" class="headerlink" title="判断栈是否为空 (isEmpty)"></a>判断栈是否为空 (isEmpty)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isStackEmpty</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历栈并打印数据"><a href="#遍历栈并打印数据" class="headerlink" title="遍历栈并打印数据"></a>遍历栈并打印数据</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印栈所有节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    StackNode* current = top;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈内容（从栈顶到栈底）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放栈内存"><a href="#释放栈内存" class="headerlink" title="释放栈内存"></a>释放栈内存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放栈所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeStack</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    StackNode* current = top;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        StackNode* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整栈示例代码"><a href="#完整栈示例代码" class="headerlink" title="完整栈示例代码"></a>完整栈示例代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义栈节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空栈（栈顶指针）</span></span><br><span class="line">StackNode* <span class="title function_">initStack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压栈操作：向栈中添加元素</span></span><br><span class="line">StackNode* <span class="title function_">push</span><span class="params">(StackNode* top, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    StackNode* newNode = (StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = top;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹栈操作：从栈中移除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(StackNode** top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*top == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空，无法弹栈！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode* temp = *top;</span><br><span class="line">    <span class="type">int</span> poppedValue = temp-&gt;data;</span><br><span class="line">    *top = (*top)-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> poppedValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看栈顶元素（不移除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空，无法查看栈顶元素！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isStackEmpty</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印栈所有节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    StackNode* current = top;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈内容（从栈顶到栈底）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放栈所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeStack</span><span class="params">(StackNode* top)</span> &#123;</span><br><span class="line">    StackNode* current = top;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        StackNode* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    StackNode* myStack = initStack(); <span class="comment">// 初始化空栈</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 栈操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈是否为空：%s\n&quot;</span>, isStackEmpty(myStack) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">    myStack = push(myStack, <span class="number">10</span>);</span><br><span class="line">    printStack(myStack);</span><br><span class="line"></span><br><span class="line">    myStack = push(myStack, <span class="number">20</span>);</span><br><span class="line">    printStack(myStack);</span><br><span class="line"></span><br><span class="line">    myStack = push(myStack, <span class="number">30</span>);</span><br><span class="line">    printStack(myStack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈顶元素：%d\n&quot;</span>, peek(myStack));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹栈元素：%d\n&quot;</span>, pop(&amp;myStack));</span><br><span class="line">    printStack(myStack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹栈元素：%d\n&quot;</span>, pop(&amp;myStack));</span><br><span class="line">    printStack(myStack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈是否为空：%s\n&quot;</span>, isStackEmpty(myStack) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹栈元素：%d\n&quot;</span>, pop(&amp;myStack));</span><br><span class="line">    printStack(myStack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈是否为空：%s\n&quot;</span>, isStackEmpty(myStack) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试在空栈上弹栈或查看栈顶</span></span><br><span class="line">    <span class="comment">// pop(&amp;myStack); // 会导致程序退出</span></span><br><span class="line">    <span class="comment">// peek(myStack); // 会导致程序退出</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 内存释放 ------\n&quot;</span>);</span><br><span class="line">    myStack = push(myStack, <span class="number">5</span>);</span><br><span class="line">    myStack = push(myStack, <span class="number">15</span>);</span><br><span class="line">    printStack(myStack);</span><br><span class="line">    freeStack(myStack);</span><br><span class="line">    myStack = <span class="literal">NULL</span>; <span class="comment">// 释放后将栈顶指针设为NULL</span></span><br><span class="line">    </span><br><span class="line">    printStack(myStack); <span class="comment">// 尝试打印已释放的栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>队列是一种“先进先出”（First In, First Out - FIFO）的数据结构。你可以把它想象成排队等候的队伍，最先排队的人总是最先得到服务。</p>
<h4 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h4><ul>
<li><strong>队头（Front）</strong>: 队列中允许删除元素的一端。</li>
<li><strong>队尾（Rear）</strong>: 队列中允许插入元素的一端。</li>
<li><strong>入队（Enqueue）</strong>: 向队列中添加元素的操作。</li>
<li><strong>出队（Dequeue）</strong>: 从队列中移除元素的操作。</li>
</ul>
<h4 id="C-语言中队列的实现"><a href="#C-语言中队列的实现" class="headerlink" title="C 语言中队列的实现"></a>C 语言中队列的实现</h4><p>队列同样可以使用数组或链表来实现。这里我们主要介绍基于<strong>链表</strong>的实现，因为它能更好地处理队列的动态增长和收缩。</p>
<p>为了高效地进行入队（在队尾插入）和出队（在队头删除），我们通常会维护两个指针：一个指向队头（<code>front</code>），一个指向队尾（<code>rear</code>）。</p>
<h5 id="队列节点定义"><a href="#队列节点定义" class="headerlink" title="队列节点定义"></a>队列节点定义</h5><p>与栈类似，使用单向链表节点即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列结构体，包含队头和队尾指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    QueueNode *front; <span class="comment">// 队头指针</span></span><br><span class="line">    QueueNode *rear;  <span class="comment">// 队尾指针</span></span><br><span class="line">&#125; Queue;</span><br></pre></td></tr></table></figure>

<h5 id="队列的初始化"><a href="#队列的初始化" class="headerlink" title="队列的初始化"></a>队列的初始化</h5><p>初始化时，队头和队尾指针都指向 <code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空队列</span></span><br><span class="line">Queue* <span class="title function_">initQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="入队操作-Enqueue"><a href="#入队操作-Enqueue" class="headerlink" title="入队操作 (Enqueue)"></a>入队操作 (Enqueue)</h5><p>新元素总是添加到队尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队操作：向队列中添加元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* q, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    QueueNode* newNode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 新节点总是队列的最后一个，所以next为NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果队列为空</span></span><br><span class="line">        q-&gt;front = newNode; <span class="comment">// 新节点既是队头也是队尾</span></span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next = newNode; <span class="comment">// 原队尾的next指向新节点</span></span><br><span class="line">        q-&gt;rear = newNode;       <span class="comment">// 更新队尾为新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 入队。\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="出队操作-Dequeue"><a href="#出队操作-Dequeue" class="headerlink" title="出队操作 (Dequeue)"></a>出队操作 (Dequeue)</h5><p>从队头移除元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出队操作：从队列中移除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空，无法出队！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* temp = q-&gt;front; <span class="comment">// 临时保存队头</span></span><br><span class="line">    <span class="type">int</span> dequeuedValue = temp-&gt;data; <span class="comment">// 获取队头数据</span></span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next;   <span class="comment">// 队头下移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果队列出队后变为空</span></span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>;     <span class="comment">// 队尾也设为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp); <span class="comment">// 释放原队头内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 出队。\n&quot;</span>, dequeuedValue);</span><br><span class="line">    <span class="keyword">return</span> dequeuedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查看队头元素-Front"><a href="#查看队头元素-Front" class="headerlink" title="查看队头元素 (Front)"></a>查看队头元素 (Front)</h5><p>不移除元素，只返回队头元素的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队头元素（不移除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">front</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空，无法查看队头元素！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="判断队列是否为空-isEmpty"><a href="#判断队列是否为空-isEmpty" class="headerlink" title="判断队列是否为空 (isEmpty)"></a>判断队列是否为空 (isEmpty)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isQueueEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历队列并打印数据"><a href="#遍历队列并打印数据" class="headerlink" title="遍历队列并打印数据"></a>遍历队列并打印数据</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印队列所有节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    QueueNode* current = q-&gt;front;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列内容（从队头到队尾）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放队列内存"><a href="#释放队列内存" class="headerlink" title="释放队列内存"></a>释放队列内存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放队列所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    QueueNode* current = q-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        QueueNode* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">// 最后释放队列结构体本身</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整队列示例代码"><a href="#完整队列示例代码" class="headerlink" title="完整队列示例代码"></a>完整队列示例代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列结构体，包含队头和队尾指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    QueueNode *front; <span class="comment">// 队头指针</span></span><br><span class="line">    QueueNode *rear;  <span class="comment">// 队尾指针</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空队列</span></span><br><span class="line">Queue* <span class="title function_">initQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队操作：向队列中添加元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* q, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    QueueNode* newNode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果队列为空</span></span><br><span class="line">        q-&gt;front = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 入队。\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队操作：从队列中移除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空，无法出队！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* temp = q-&gt;front;</span><br><span class="line">    <span class="type">int</span> dequeuedValue = temp-&gt;data;</span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果队列出队后变为空</span></span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 出队。\n&quot;</span>, dequeuedValue);</span><br><span class="line">    <span class="keyword">return</span> dequeuedValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看队头元素（不移除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">front</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空，无法查看队头元素！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isQueueEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印队列所有节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    QueueNode* current = q-&gt;front;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列内容（从队头到队尾）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放队列所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    QueueNode* current = q-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        QueueNode* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* myQueue = initQueue(); <span class="comment">// 初始化空队列</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 队列操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列是否为空：%s\n&quot;</span>, isQueueEmpty(myQueue) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">    enqueue(myQueue, <span class="number">100</span>);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line"></span><br><span class="line">    enqueue(myQueue, <span class="number">200</span>);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line"></span><br><span class="line">    enqueue(myQueue, <span class="number">300</span>);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队头元素：%d\n&quot;</span>, front(myQueue));</span><br><span class="line">    dequeue(myQueue);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line"></span><br><span class="line">    dequeue(myQueue);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列是否为空：%s\n&quot;</span>, isQueueEmpty(myQueue) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队头元素：%d\n&quot;</span>, front(myQueue)); <span class="comment">// 此时队列只有一个元素</span></span><br><span class="line">    dequeue(myQueue);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列是否为空：%s\n&quot;</span>, isQueueEmpty(myQueue) ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试在空队列上出队或查看队头</span></span><br><span class="line">    <span class="comment">// dequeue(myQueue); // 会导致程序退出</span></span><br><span class="line">    <span class="comment">// front(myQueue);   // 会导致程序退出</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 内存释放 ------\n&quot;</span>);</span><br><span class="line">    enqueue(myQueue, <span class="number">50</span>); <span class="comment">// 再次入队一些元素</span></span><br><span class="line">    enqueue(myQueue, <span class="number">60</span>);</span><br><span class="line">    printQueue(myQueue);</span><br><span class="line">    freeQueue(myQueue);</span><br><span class="line">    myQueue = <span class="literal">NULL</span>; <span class="comment">// 释放后将队列指针设为NULL</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试打印已释放的队列</span></span><br><span class="line">    <span class="comment">// printQueue(myQueue); // 会导致段错误，因为q已是NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-十字链表" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/" class="article-date">
      <time datetime="2025-05-30T12:54:56.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/">十字链表</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="稀疏矩阵的优雅表示：深入理解“十字链表”"><a href="#稀疏矩阵的优雅表示：深入理解“十字链表”" class="headerlink" title="稀疏矩阵的优雅表示：深入理解“十字链表”"></a>稀疏矩阵的优雅表示：深入理解“十字链表”</h2><h3 id="1-为什么需要十字链表？"><a href="#1-为什么需要十字链表？" class="headerlink" title="1. 为什么需要十字链表？"></a>1. 为什么需要十字链表？</h3><p>考虑一个 1000×1000 的矩阵，如果它只有 100 个非零元素，却要占用 1000×1000×sizeof(int) 字节的内存（假设整型）。这无疑是巨大的浪费。为了解决这个问题，我们需要只存储非零元素。</p>
<p>传统的稀疏矩阵存储方式还有：</p>
<ul>
<li><strong>三元组表（Triplet Form）：</strong> 存储非零元素的 (行，列，值) 三元组，但查找和修改某个元素不方便。</li>
<li><strong>行主序链表：</strong> 每行一个链表，存储该行的非零元素。</li>
<li><strong>列主序链表：</strong> 每列一个链表，存储该列的非零元素。</li>
</ul>
<p>三元组表不利于矩阵的加法、乘法等操作；行主序链表在按列访问时效率低下，反之亦然。<strong>十字链表</strong>则巧妙地解决了这些问题，它允许我们既能按行遍历，也能按列遍历非零元素。</p>
<h3 id="2-十字链表的核心思想与节点结构"><a href="#2-十字链表的核心思想与节点结构" class="headerlink" title="2. 十字链表的核心思想与节点结构"></a>2. 十字链表的核心思想与节点结构</h3><p>十字链表的核心思想是：<strong>每个非零元素都存储在一个节点中，并且这个节点同时连接着它所在行的下一个非零元素和它所在列的下一个非零元素。</strong></p>
<p>它通过在矩阵的行和列方向上分别构建链表，将行链表和列链表“交叉”起来，从而形成一个十字形结构。</p>
<p><strong>十字链表的基本组成部分：</strong></p>
<ol>
<li><strong>行&#x2F;列头节点（Row&#x2F;Column Head Node）：</strong> 用于管理每一行或每一列的非零元素链表。它们通常构成一个头节点数组（或链表），其中每个头节点都包含指向该行&#x2F;列第一个非零元素的指针。<ul>
<li>为了统一表示，我们通常也会把行&#x2F;列头节点看作是特殊类型的节点。</li>
</ul>
</li>
<li><strong>元素节点（Element Node）：</strong> 存储非零元素的信息，并包含四个指针：<ul>
<li><code>row</code>: 非零元素所在的行索引。</li>
<li><code>col</code>: 非零元素所在的列索引。</li>
<li><code>value</code>: 非零元素的值。</li>
<li><code>right</code>: 指向同一行中下一个非零元素的指针。</li>
<li><code>down</code>: 指向同一列中下一个非零元素的指针。</li>
</ul>
</li>
</ol>
<p><strong>节点结构体定义：</strong></p>
<p>为了简化，我们可以将所有节点统一为一种类型，并使用一个标志位来区分是头节点还是元素节点，或者更常见地，使用两种不同的结构体，或者在一个统一的结构体中只在元素节点中存储 <code>value</code>。这里我们采用一种更灵活的定义，它可以表示普通元素节点，也可以表示行&#x2F;列头节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义稀疏矩阵的节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> row;       <span class="comment">// 行索引</span></span><br><span class="line">    <span class="type">int</span> col;       <span class="comment">// 列索引</span></span><br><span class="line">    <span class="type">int</span> value;     <span class="comment">// 存储的非零元素值（仅对元素节点有效）</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">right</span>;</span> <span class="comment">// 指向同一行下一个非零元素的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">down</span>;</span>  <span class="comment">// 指向同一列下一个非零元素的指针</span></span><br><span class="line">&#125; OLNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义稀疏矩阵的十字链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CrossList</span> &#123;</span></span><br><span class="line">    OLNode** row_heads;   <span class="comment">// 行头节点数组</span></span><br><span class="line">    OLNode** col_heads;   <span class="comment">// 列头节点数组</span></span><br><span class="line">    <span class="type">int</span> rows;             <span class="comment">// 矩阵的行数</span></span><br><span class="line">    <span class="type">int</span> cols;             <span class="comment">// 矩阵的列数</span></span><br><span class="line">    <span class="type">int</span> num_elements;     <span class="comment">// 非零元素的数量</span></span><br><span class="line">&#125; CrossList;</span><br></pre></td></tr></table></figure>

<h3 id="3-十字链表的基本操作"><a href="#3-十字链表的基本操作" class="headerlink" title="3. 十字链表的基本操作"></a>3. 十字链表的基本操作</h3><h4 id="3-1-初始化十字链表"><a href="#3-1-初始化十字链表" class="headerlink" title="3.1 初始化十字链表"></a>3.1 初始化十字链表</h4><p>创建矩阵结构，并初始化行头节点数组和列头节点数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空的十字链表</span></span><br><span class="line">CrossList* <span class="title function_">initCrossList</span><span class="params">(<span class="type">int</span> m_rows, <span class="type">int</span> m_cols)</span> &#123;</span><br><span class="line">    CrossList* matrix = (CrossList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CrossList));</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    matrix-&gt;rows = m_rows;</span><br><span class="line">    matrix-&gt;cols = m_cols;</span><br><span class="line">    matrix-&gt;num_elements = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配行头节点数组</span></span><br><span class="line">    matrix-&gt;row_heads = (OLNode**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode*) * m_rows);</span><br><span class="line">    <span class="keyword">if</span> (matrix-&gt;row_heads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_rows; i++) &#123;</span><br><span class="line">        matrix-&gt;row_heads[i] = <span class="literal">NULL</span>; <span class="comment">// 初始化行链表为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配列头节点数组</span></span><br><span class="line">    matrix-&gt;col_heads = (OLNode**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode*) * m_cols);</span><br><span class="line">    <span class="keyword">if</span> (matrix-&gt;col_heads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_cols; i++) &#123;</span><br><span class="line">        matrix-&gt;col_heads[i] = <span class="literal">NULL</span>; <span class="comment">// 初始化列链表为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-插入非零元素"><a href="#3-2-插入非零元素" class="headerlink" title="3.2 插入非零元素"></a>3.2 插入非零元素</h4><p>插入是十字链表的核心操作。每插入一个元素，都需要将其正确地插入到其对应行的链表和列的链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一个非零元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertElement</span><span class="params">(CrossList* matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= matrix-&gt;rows || col &lt; <span class="number">0</span> || col &gt;= matrix-&gt;cols) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入失败：索引越界。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123; <span class="comment">// 零元素不存储</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OLNode* newNode = (OLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;row = row;</span><br><span class="line">    newNode-&gt;col = col;</span><br><span class="line">    newNode-&gt;value = value;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 插入到行链表</span></span><br><span class="line">    <span class="comment">// 找到该行中，比新节点列索引小的最后一个节点，或找到该行链表头</span></span><br><span class="line">    OLNode* p_row = matrix-&gt;row_heads[row];</span><br><span class="line">    <span class="keyword">if</span> (p_row == <span class="literal">NULL</span> || p_row-&gt;col &gt; col) &#123; <span class="comment">// 当前行无节点或新节点应作为第一个</span></span><br><span class="line">        newNode-&gt;right = p_row;</span><br><span class="line">        matrix-&gt;row_heads[row] = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p_row-&gt;right != <span class="literal">NULL</span> &amp;&amp; p_row-&gt;right-&gt;col &lt; col) &#123;</span><br><span class="line">            p_row = p_row-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理重复元素：如果已存在相同位置的元素，则更新值</span></span><br><span class="line">        <span class="keyword">if</span> (p_row-&gt;right != <span class="literal">NULL</span> &amp;&amp; p_row-&gt;right-&gt;col == col) &#123;</span><br><span class="line">            p_row-&gt;right-&gt;value = value; <span class="comment">// 更新值</span></span><br><span class="line">            <span class="built_in">free</span>(newNode); <span class="comment">// 新节点不再需要</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入到正确位置</span></span><br><span class="line">        newNode-&gt;right = p_row-&gt;right;</span><br><span class="line">        p_row-&gt;right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 插入到列链表 (与行链表类似)</span></span><br><span class="line">    OLNode* p_col = matrix-&gt;col_heads[col];</span><br><span class="line">    <span class="keyword">if</span> (p_col == <span class="literal">NULL</span> || p_col-&gt;row &gt; row) &#123; <span class="comment">// 当前列无节点或新节点应作为第一个</span></span><br><span class="line">        newNode-&gt;down = p_col;</span><br><span class="line">        matrix-&gt;col_heads[col] = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p_col-&gt;down != <span class="literal">NULL</span> &amp;&amp; p_col-&gt;down-&gt;row &lt; row) &#123;</span><br><span class="line">            p_col = p_col-&gt;down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意：这里不用处理重复元素了，因为行链表已经处理过了</span></span><br><span class="line">        newNode-&gt;down = p_col-&gt;down;</span><br><span class="line">        p_col-&gt;down = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix-&gt;num_elements++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-打印矩阵（遍历）"><a href="#3-3-打印矩阵（遍历）" class="headerlink" title="3.3 打印矩阵（遍历）"></a>3.3 打印矩阵（遍历）</h4><p>十字链表可以方便地按行或按列遍历非零元素，甚至可以还原出完整的矩阵。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印矩阵（按行遍历非零元素）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMatrixByRow</span><span class="params">(CrossList* matrix)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按行打印稀疏矩阵的非零元素 (row, col, value):\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix-&gt;rows; i++) &#123;</span><br><span class="line">        OLNode* current = matrix-&gt;row_heads[i];</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d, %d) &quot;</span>, current-&gt;row, current-&gt;col, current-&gt;value);</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印矩阵（还原完整矩阵）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printFullMatrix</span><span class="params">(CrossList* matrix)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;完整矩阵：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix-&gt;rows; i++) &#123;</span><br><span class="line">        OLNode* current_row_node = matrix-&gt;row_heads[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix-&gt;cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current_row_node != <span class="literal">NULL</span> &amp;&amp; current_row_node-&gt;col == j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current_row_node-&gt;value);</span><br><span class="line">                current_row_node = current_row_node-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>); <span class="comment">// 没有非零元素，打印0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-查找元素"><a href="#3-4-查找元素" class="headerlink" title="3.4 查找元素"></a>3.4 查找元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找某个位置的元素值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getElement</span><span class="params">(CrossList* matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= matrix-&gt;rows || col &lt; <span class="number">0</span> || col &gt;= matrix-&gt;cols) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败：索引越界。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 假定超出范围是0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OLNode* current = matrix-&gt;row_heads[row]; <span class="comment">// 从行头开始查找</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;col &lt; col) &#123;</span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;col == col) &#123;</span><br><span class="line">        <span class="keyword">return</span> current-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未找到，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-删除元素"><a href="#3-5-删除元素" class="headerlink" title="3.5 删除元素"></a>3.5 删除元素</h4><p>删除元素相对复杂，需要同时更新行链表和列链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除一个非零元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteElement</span><span class="params">(CrossList* matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= matrix-&gt;rows || col &lt; <span class="number">0</span> || col &gt;= matrix-&gt;cols) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败：索引越界。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OLNode* nodeToDelete = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 从行链表中删除</span></span><br><span class="line">    OLNode* prev_row = <span class="literal">NULL</span>;</span><br><span class="line">    OLNode* current_row = matrix-&gt;row_heads[row];</span><br><span class="line">    <span class="keyword">while</span> (current_row != <span class="literal">NULL</span> &amp;&amp; current_row-&gt;col &lt; col) &#123;</span><br><span class="line">        prev_row = current_row;</span><br><span class="line">        current_row = current_row-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current_row != <span class="literal">NULL</span> &amp;&amp; current_row-&gt;col == col) &#123;</span><br><span class="line">        nodeToDelete = current_row; <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev_row == <span class="literal">NULL</span>) &#123; <span class="comment">// 删除的是行头</span></span><br><span class="line">            matrix-&gt;row_heads[row] = current_row-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev_row-&gt;right = current_row-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到 (%d, %d) 处的非零元素。\n&quot;</span>, row, col);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 未找到，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从列链表中删除</span></span><br><span class="line">    OLNode* prev_col = <span class="literal">NULL</span>;</span><br><span class="line">    OLNode* current_col = matrix-&gt;col_heads[col];</span><br><span class="line">    <span class="keyword">while</span> (current_col != <span class="literal">NULL</span> &amp;&amp; current_col-&gt;row &lt; row) &#123;</span><br><span class="line">        prev_col = current_col;</span><br><span class="line">        current_col = current_col-&gt;down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 current_col 应该就是 nodeToDelete (因为行和列都指向同一个节点)</span></span><br><span class="line">    <span class="keyword">if</span> (current_col != <span class="literal">NULL</span> &amp;&amp; current_col-&gt;row == row &amp;&amp; current_col-&gt;col == col) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev_col == <span class="literal">NULL</span>) &#123; <span class="comment">// 删除的是列头</span></span><br><span class="line">            matrix-&gt;col_heads[col] = current_col-&gt;down;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev_col-&gt;down = current_col-&gt;down;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(nodeToDelete); <span class="comment">// 释放节点内存</span></span><br><span class="line">    matrix-&gt;num_elements--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功删除元素 (%d, %d)。\n&quot;</span>, row, col);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-6-释放内存"><a href="#3-6-释放内存" class="headerlink" title="3.6 释放内存"></a>3.6 释放内存</h4><p>释放所有元素节点和头节点数组的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放十字链表占用的所有内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeCrossList</span><span class="params">(CrossList* matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有元素节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix-&gt;rows; i++) &#123;</span><br><span class="line">        OLNode* current = matrix-&gt;row_heads[i];</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            OLNode* temp = current;</span><br><span class="line">            current = current-&gt;right; <span class="comment">// 先移动到下一个，因为当前节点可能被其他行/列引用</span></span><br><span class="line">            <span class="comment">// 如果是双向链表，需要判断是否已经被释放过</span></span><br><span class="line">            <span class="comment">// 对于十字链表，一个节点只被释放一次。我们按行释放即可。</span></span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放行头和列头数组本身</span></span><br><span class="line">    <span class="built_in">free</span>(matrix-&gt;row_heads);</span><br><span class="line">    <span class="built_in">free</span>(matrix-&gt;col_heads);</span><br><span class="line">    <span class="built_in">free</span>(matrix);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十字链表内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-完整示例代码"><a href="#4-完整示例代码" class="headerlink" title="4. 完整示例代码"></a>4. 完整示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义稀疏矩阵的节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> row;       <span class="comment">// 行索引</span></span><br><span class="line">    <span class="type">int</span> col;       <span class="comment">// 列索引</span></span><br><span class="line">    <span class="type">int</span> value;     <span class="comment">// 存储的非零元素值</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">right</span>;</span> <span class="comment">// 指向同一行下一个非零元素的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">down</span>;</span>  <span class="comment">// 指向同一列下一个非零元素的指针</span></span><br><span class="line">&#125; OLNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义稀疏矩阵的十字链表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CrossList</span> &#123;</span></span><br><span class="line">    OLNode** row_heads;   <span class="comment">// 行头节点数组</span></span><br><span class="line">    OLNode** col_heads;   <span class="comment">// 列头节点数组</span></span><br><span class="line">    <span class="type">int</span> rows;             <span class="comment">// 矩阵的行数</span></span><br><span class="line">    <span class="type">int</span> cols;             <span class="comment">// 矩阵的列数</span></span><br><span class="line">    <span class="type">int</span> num_elements;     <span class="comment">// 非零元素的数量</span></span><br><span class="line">&#125; CrossList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空的十字链表</span></span><br><span class="line">CrossList* <span class="title function_">initCrossList</span><span class="params">(<span class="type">int</span> m_rows, <span class="type">int</span> m_cols)</span> &#123;</span><br><span class="line">    CrossList* matrix = (CrossList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CrossList));</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    matrix-&gt;rows = m_rows;</span><br><span class="line">    matrix-&gt;cols = m_cols;</span><br><span class="line">    matrix-&gt;num_elements = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    matrix-&gt;row_heads = (OLNode**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode*) * m_rows);</span><br><span class="line">    <span class="keyword">if</span> (matrix-&gt;row_heads == <span class="literal">NULL</span>) &#123; <span class="comment">/* handle error */</span> &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_rows; i++) &#123;</span><br><span class="line">        matrix-&gt;row_heads[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix-&gt;col_heads = (OLNode**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode*) * m_cols);</span><br><span class="line">    <span class="keyword">if</span> (matrix-&gt;col_heads == <span class="literal">NULL</span>) &#123; <span class="comment">/* handle error */</span> &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_cols; i++) &#123;</span><br><span class="line">        matrix-&gt;col_heads[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个非零元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertElement</span><span class="params">(CrossList* matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= matrix-&gt;rows || col &lt; <span class="number">0</span> || col &gt;= matrix-&gt;cols) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入失败：索引越界 (%d, %d)。\n&quot;</span>, row, col);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果插入0，则尝试删除该位置的现有元素 (如果存在)</span></span><br><span class="line">        <span class="comment">// 简化起见，这里假设用户不会插入0，如果需要，可以调用 deleteElement</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OLNode* newNode = (OLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;row = row;</span><br><span class="line">    newNode-&gt;col = col;</span><br><span class="line">    newNode-&gt;value = value;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 插入到行链表 (保持按列索引升序)</span></span><br><span class="line">    OLNode* p_row = matrix-&gt;row_heads[row];</span><br><span class="line">    OLNode* prev_row = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p_row != <span class="literal">NULL</span> &amp;&amp; p_row-&gt;col &lt; col) &#123;</span><br><span class="line">        prev_row = p_row;</span><br><span class="line">        p_row = p_row-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果该位置已存在元素，则更新其值并释放新节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_row != <span class="literal">NULL</span> &amp;&amp; p_row-&gt;col == col) &#123;</span><br><span class="line">        p_row-&gt;value = value; <span class="comment">// 更新值</span></span><br><span class="line">        <span class="built_in">free</span>(newNode);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点到行链表</span></span><br><span class="line">    <span class="keyword">if</span> (prev_row == <span class="literal">NULL</span>) &#123; <span class="comment">// 插入到行头</span></span><br><span class="line">        newNode-&gt;right = matrix-&gt;row_heads[row];</span><br><span class="line">        matrix-&gt;row_heads[row] = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode-&gt;right = prev_row-&gt;right;</span><br><span class="line">        prev_row-&gt;right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 插入到列链表 (保持按行索引升序)</span></span><br><span class="line">    OLNode* p_col = matrix-&gt;col_heads[col];</span><br><span class="line">    OLNode* prev_col = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p_col != <span class="literal">NULL</span> &amp;&amp; p_col-&gt;row &lt; row) &#123;</span><br><span class="line">        prev_col = p_col;</span><br><span class="line">        p_col = p_col-&gt;down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点到列链表</span></span><br><span class="line">    <span class="keyword">if</span> (prev_col == <span class="literal">NULL</span>) &#123; <span class="comment">// 插入到列头</span></span><br><span class="line">        newNode-&gt;down = matrix-&gt;col_heads[col];</span><br><span class="line">        matrix-&gt;col_heads[col] = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode-&gt;down = prev_col-&gt;down;</span><br><span class="line">        prev_col-&gt;down = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix-&gt;num_elements++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某个位置的元素值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getElement</span><span class="params">(CrossList* matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= matrix-&gt;rows || col &lt; <span class="number">0</span> || col &gt;= matrix-&gt;cols) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败：索引越界。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 假定超出范围是0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OLNode* current = matrix-&gt;row_heads[row]; <span class="comment">// 从行头开始查找</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;col &lt; col) &#123;</span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;col == col) &#123;</span><br><span class="line">        <span class="keyword">return</span> current-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未找到，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个非零元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteElement</span><span class="params">(CrossList* matrix, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= matrix-&gt;rows || col &lt; <span class="number">0</span> || col &gt;= matrix-&gt;cols) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败：索引越界。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OLNode* nodeToDelete = <span class="literal">NULL</span>; <span class="comment">// 用于最终free的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从行链表中删除</span></span><br><span class="line">    OLNode* prev_row = <span class="literal">NULL</span>;</span><br><span class="line">    OLNode* current_row = matrix-&gt;row_heads[row];</span><br><span class="line">    <span class="keyword">while</span> (current_row != <span class="literal">NULL</span> &amp;&amp; current_row-&gt;col &lt; col) &#123;</span><br><span class="line">        prev_row = current_row;</span><br><span class="line">        current_row = current_row-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (current_row != <span class="literal">NULL</span> &amp;&amp; current_row-&gt;col == col) &#123;</span><br><span class="line">        nodeToDelete = current_row; </span><br><span class="line">        <span class="keyword">if</span> (prev_row == <span class="literal">NULL</span>) &#123; <span class="comment">// 删除的是行头</span></span><br><span class="line">            matrix-&gt;row_heads[row] = current_row-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev_row-&gt;right = current_row-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到 (%d, %d) 处的非零元素进行删除。\n&quot;</span>, row, col);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从列链表中删除 (寻找并跳过该节点)</span></span><br><span class="line">    OLNode* prev_col = <span class="literal">NULL</span>;</span><br><span class="line">    OLNode* current_col = matrix-&gt;col_heads[col];</span><br><span class="line">    <span class="keyword">while</span> (current_col != <span class="literal">NULL</span> &amp;&amp; current_col-&gt;row &lt; row) &#123;</span><br><span class="line">        prev_col = current_col;</span><br><span class="line">        current_col = current_col-&gt;down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 current_col 应该就是 nodeToDelete (因为行和列都指向同一个节点)</span></span><br><span class="line">    <span class="keyword">if</span> (current_col != <span class="literal">NULL</span> &amp;&amp; current_col-&gt;row == row &amp;&amp; current_col-&gt;col == col) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev_col == <span class="literal">NULL</span>) &#123; <span class="comment">// 删除的是列头</span></span><br><span class="line">            matrix-&gt;col_heads[col] = current_col-&gt;down;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev_col-&gt;down = current_col-&gt;down;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(nodeToDelete); <span class="comment">// 释放节点内存</span></span><br><span class="line">    matrix-&gt;num_elements--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功删除元素 (%d, %d)。\n&quot;</span>, row, col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印矩阵（还原完整矩阵）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printFullMatrix</span><span class="params">(CrossList* matrix)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n完整矩阵 (%d x %d):\n&quot;</span>, matrix-&gt;rows, matrix-&gt;cols);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix-&gt;rows; i++) &#123;</span><br><span class="line">        OLNode* current_row_node = matrix-&gt;row_heads[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix-&gt;cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current_row_node != <span class="literal">NULL</span> &amp;&amp; current_row_node-&gt;col == j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%3d &quot;</span>, current_row_node-&gt;value); <span class="comment">// 格式化输出</span></span><br><span class="line">                current_row_node = current_row_node-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%3d &quot;</span>, <span class="number">0</span>); <span class="comment">// 没有非零元素，打印0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放十字链表占用的所有内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeCrossList</span><span class="params">(CrossList* matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有元素节点</span></span><br><span class="line">    <span class="comment">// 只需要按行链表释放即可，因为每个节点只在某个行链表和某个列链表中出现一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix-&gt;rows; i++) &#123;</span><br><span class="line">        OLNode* current = matrix-&gt;row_heads[i];</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            OLNode* temp = current;</span><br><span class="line">            current = current-&gt;right; </span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放行头和列头数组本身</span></span><br><span class="line">    <span class="built_in">free</span>(matrix-&gt;row_heads);</span><br><span class="line">    <span class="built_in">free</span>(matrix-&gt;col_heads);</span><br><span class="line">    <span class="built_in">free</span>(matrix);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十字链表内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> rows = <span class="number">4</span>, cols = <span class="number">5</span>;</span><br><span class="line">    CrossList* sparseMatrix = initCrossList(rows, cols);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 插入元素 ------\n&quot;</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入重复位置元素 (更新):\n&quot;</span>);</span><br><span class="line">    insertElement(sparseMatrix, <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 更新 (0,1) 的值</span></span><br><span class="line"></span><br><span class="line">    printFullMatrix(sparseMatrix);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 查找元素 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 (0, 1): %d\n&quot;</span>, getElement(sparseMatrix, <span class="number">0</span>, <span class="number">1</span>)); <span class="comment">// Expected: 100</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 (1, 2): %d\n&quot;</span>, getElement(sparseMatrix, <span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// Expected: 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 (3, 4): %d\n&quot;</span>, getElement(sparseMatrix, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// Expected: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 删除元素 ------\n&quot;</span>);</span><br><span class="line">    deleteElement(sparseMatrix, <span class="number">0</span>, <span class="number">4</span>); <span class="comment">// 删除 (0,4)</span></span><br><span class="line">    printFullMatrix(sparseMatrix);</span><br><span class="line"></span><br><span class="line">    deleteElement(sparseMatrix, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 删除 (1,0)</span></span><br><span class="line">    printFullMatrix(sparseMatrix);</span><br><span class="line"></span><br><span class="line">    deleteElement(sparseMatrix, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 删除不存在的元素</span></span><br><span class="line">    printFullMatrix(sparseMatrix);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 内存释放 ------\n&quot;</span>);</span><br><span class="line">    freeCrossList(sparseMatrix);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-十字链表的优势与应用"><a href="#5-十字链表的优势与应用" class="headerlink" title="5. 十字链表的优势与应用"></a>5. 十字链表的优势与应用</h3><p><strong>优势：</strong></p>
<ul>
<li><strong>空间效率高：</strong> 只存储非零元素，对于稀疏矩阵来说，大大节省了内存空间。</li>
<li><strong>灵活的双向访问：</strong> 既可以高效地按行遍历非零元素，也可以高效地按列遍历非零元素。</li>
<li><strong>插入和删除相对方便：</strong> 相较于三元组表等，插入和删除非零元素（在已知位置时）更为方便，只需调整少数指针。</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>稀疏矩阵的存储和运算：</strong> 矩阵的加法、乘法等运算在十字链表上实现效率更高。</li>
<li><strong>图的邻接多重表表示：</strong> 图的一种特殊存储结构，每个边可以同时存在于两个顶点的邻接链表中，类似于十字链表的思想。</li>
<li><strong>数据挖掘和机器学习：</strong> 处理包含大量零值的矩阵数据，例如协同过滤中的用户-物品评分矩阵。</li>
</ul>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>十字链表是一种为稀疏矩阵量身定制的数据结构。它通过巧妙地将非零元素组织成行链表和列链表的交织结构，实现了空间上的高效利用和访问上的高度灵活性。虽然它的实现比普通链表复杂，但在处理大规模稀疏数据时，其优势显而易见。</p>
<p>理解十字链表的原理和实现，将为你在处理稀疏数据和更复杂的数据结构（如图）时提供强大的工具。</p>
<hr>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-堆" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/%E5%A0%86/" class="article-date">
      <time datetime="2025-05-30T12:52:47.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/%E5%A0%86/">堆</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="揭秘“堆”：高效的优先级队列与排序利器"><a href="#揭秘“堆”：高效的优先级队列与排序利器" class="headerlink" title="揭秘“堆”：高效的优先级队列与排序利器"></a>揭秘“堆”：高效的优先级队列与排序利器</h2><h3 id="1-什么是堆？"><a href="#1-什么是堆？" class="headerlink" title="1. 什么是堆？"></a>1. 什么是堆？</h3><p>堆是一种特殊的<strong>完全二叉树</strong>。它的主要特性是：</p>
<ol>
<li><strong>完全二叉树：</strong> 堆必须是一棵完全二叉树。这意味着除了最后一层，其他层都被完全填满，并且最后一层的节点都尽可能地靠左排列。这种结构使得堆可以用<strong>数组</strong>来高效地表示，无需使用指针，节省了内存空间。<ul>
<li>在一个完全二叉树中，如果一个节点的索引是 i：<ul>
<li>它的左子节点的索引是 2i+1。</li>
<li>它的右子节点的索引是 2i+2。</li>
<li>它的父节点的索引是 (i−1)&#x2F;2（整数除法）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>堆序性（Heap Property）：</strong> 堆中的每个节点都满足特定的顺序关系。根据这个关系，堆可以分为两种：<ul>
<li><strong>最大堆（Max-Heap）：</strong> 每个父节点的值都<strong>大于或等于</strong>其子节点的值。因此，根节点是整个堆中的最大值。</li>
<li><strong>最小堆（Min-Heap）：</strong> 每个父节点的值都<strong>小于或等于</strong>其子节点的值。因此，根节点是整个堆中的最小值。</li>
</ul>
</li>
</ol>
<p>本文后续将以<strong>最小堆</strong>为例进行讲解和实现。</p>
<p><strong>为何用数组表示？</strong></p>
<p>完全二叉树的这种特性使得它的节点可以紧密地存储在一个数组中，而不会有任何空隙。通过简单的数学计算，我们就能找到任何一个节点的父节点或子节点，从而避免了传统树结构中因指针操作带来的额外开销和复杂性。</p>
<h3 id="2-堆的基本操作"><a href="#2-堆的基本操作" class="headerlink" title="2. 堆的基本操作"></a>2. 堆的基本操作</h3><p>堆的核心操作包括：<strong>插入（Insert）</strong> 和 <strong>删除根节点（Extract Min&#x2F;Max）</strong>。这两个操作都通过维护堆的“堆序性”来实现。</p>
<h4 id="2-1-插入操作（Insert）"><a href="#2-1-插入操作（Insert）" class="headerlink" title="2.1 插入操作（Insert）"></a>2.1 插入操作（Insert）</h4><p>向堆中插入一个新元素时，为了保持堆的完全二叉树结构和堆序性，我们通常这样做：</p>
<ol>
<li>将新元素添加到堆的<strong>末尾</strong>（数组的最后一个位置），以保持完全二叉树的特性。</li>
<li>然后，进行**“上浮”（Heapify-up &#x2F; Sift-up &#x2F; Bubble-up）** 操作：将新元素与其父节点进行比较。如果新元素比父节点小（最小堆）或大（最大堆），则交换它们的位置。这个过程重复进行，直到新元素到达正确的位置（满足堆序性）或者到达根节点。</li>
</ol>
<p>这个上浮过程的时间复杂度是 O(logn)，因为每次比较和交换都会使元素向上移动一层。</p>
<h4 id="2-2-删除根节点（Extract-Min-Max）"><a href="#2-2-删除根节点（Extract-Min-Max）" class="headerlink" title="2.2 删除根节点（Extract Min&#x2F;Max）"></a>2.2 删除根节点（Extract Min&#x2F;Max）</h4><p>删除堆中的根节点（例如，从最小堆中取出最小值）是另一个核心操作：</p>
<ol>
<li>取出根节点的值。</li>
<li>为了保持完全二叉树的结构，将堆中的<strong>最后一个元素</strong>移动到根节点的位置。</li>
<li>然后，进行**“下沉”（Heapify-down &#x2F; Sift-down &#x2F; Bubble-down）** 操作：将新根元素与其子节点进行比较。如果它比子节点大（最小堆）或小（最大堆），则与合适的子节点（最小堆选较小的子节点，最大堆选较大的子节点）交换位置。这个过程重复进行，直到元素到达正确的位置（满足堆序性）或者到达叶子节点。</li>
</ol>
<p>这个下沉过程的时间复杂度也是 O(logn)，因为它每次比较和交换都会使元素向下移动一层。</p>
<hr>
<h3 id="3-C-语言实现最小堆"><a href="#3-C-语言实现最小堆" class="headerlink" title="3. C 语言实现最小堆"></a>3. C 语言实现最小堆</h3><p>我们用一个数组来表示堆，并实现其核心操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span> <span class="comment">// for INT_MAX</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_HEAP_SIZE 100 <span class="comment">// 定义堆的最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MinHeap</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>* arr;       <span class="comment">// 存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> capacity;  <span class="comment">// 堆的最大容量</span></span><br><span class="line">    <span class="type">int</span> size;      <span class="comment">// 堆当前元素的数量</span></span><br><span class="line">&#125; MinHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个最小堆</span></span><br><span class="line">MinHeap* <span class="title function_">createMinHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    MinHeap* heap = (MinHeap*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinHeap));</span><br><span class="line">    <span class="keyword">if</span> (heap == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;capacity = capacity;</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * capacity);</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取左子节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取右子节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上浮操作：维护堆的最小堆序性</span></span><br><span class="line"><span class="comment">// 当一个元素被插入到堆的末尾时，需要向上调整它的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapifyUp</span><span class="params">(MinHeap* heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> parentIndex = getParentIndex(index);</span><br><span class="line">    <span class="comment">// 如果当前节点不是根节点，且比父节点小</span></span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; heap-&gt;arr[parentIndex] &gt; heap-&gt;arr[index]) &#123;</span><br><span class="line">        swap(&amp;heap-&gt;arr[index], &amp;heap-&gt;arr[parentIndex]);</span><br><span class="line">        index = parentIndex;</span><br><span class="line">        parentIndex = getParentIndex(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下沉操作：维护堆的最小堆序性</span></span><br><span class="line"><span class="comment">// 当根节点被删除或元素被修改时，需要向下调整它的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapifyDown</span><span class="params">(MinHeap* heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> smallest = index;</span><br><span class="line">    <span class="type">int</span> leftChild = getLeftChildIndex(index);</span><br><span class="line">    <span class="type">int</span> rightChild = getRightChildIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点存在且比当前最小的小</span></span><br><span class="line">    <span class="keyword">if</span> (leftChild &lt; heap-&gt;size &amp;&amp; heap-&gt;arr[leftChild] &lt; heap-&gt;arr[smallest]) &#123;</span><br><span class="line">        smallest = leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点存在且比当前最小的小</span></span><br><span class="line">    <span class="keyword">if</span> (rightChild &lt; heap-&gt;size &amp;&amp; heap-&gt;arr[rightChild] &lt; heap-&gt;arr[smallest]) &#123;</span><br><span class="line">        smallest = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最小的不是当前节点，则交换并继续向下沉</span></span><br><span class="line">    <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">        swap(&amp;heap-&gt;arr[index], &amp;heap-&gt;arr[smallest]);</span><br><span class="line">        heapifyDown(heap, smallest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素到最小堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertMinHeap</span><span class="params">(MinHeap* heap, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size == heap-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆已满，无法插入！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新元素添加到数组末尾</span></span><br><span class="line">    heap-&gt;arr[heap-&gt;size] = value;</span><br><span class="line">    heap-&gt;size++;</span><br><span class="line">    <span class="comment">// 进行上浮操作</span></span><br><span class="line">    heapifyUp(heap, heap-&gt;size - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入 %d 成功。\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取最小元素（根节点）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">extractMin</span><span class="params">(MinHeap* heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆为空，无法提取！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> INT_MAX; <span class="comment">// 返回一个表示错误的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size == <span class="number">1</span>) &#123; <span class="comment">// 只有一个元素</span></span><br><span class="line">        heap-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> heap-&gt;arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存根节点的值</span></span><br><span class="line">    <span class="type">int</span> root = heap-&gt;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 将最后一个元素移动到根节点</span></span><br><span class="line">    heap-&gt;arr[<span class="number">0</span>] = heap-&gt;arr[heap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    heap-&gt;size--;</span><br><span class="line">    <span class="comment">// 进行下沉操作</span></span><br><span class="line">    heapifyDown(heap, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取堆的最小元素（不删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMin</span><span class="params">(MinHeap* heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆为空。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印堆的数组表示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHeap</span><span class="params">(MinHeap* heap)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;堆的数组表示: [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap-&gt;size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, heap-&gt;arr[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; heap-&gt;size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放堆内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeMinHeap</span><span class="params">(MinHeap* heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(heap-&gt;arr);</span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;堆内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MinHeap* myHeap = createMinHeap(MAX_HEAP_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 插入元素 ------\n&quot;</span>);</span><br><span class="line">    insertMinHeap(myHeap, <span class="number">3</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [3]</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">2</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3]</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">15</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3, 15]</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">5</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3, 5, 15]</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">4</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3, 4, 15, 5] (实际为[2, 3, 4, 15, 5]或[2, 5, 4, 15, 3]等，取决于具体路径，但都满足最小堆序性)</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">45</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3, 4, 45, 5, 15]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 提取最小元素 ------\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> minVal = extractMin(myHeap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;提取最小元素: %d\n&quot;</span>, minVal); <span class="comment">// Expected: 2</span></span><br><span class="line">    printHeap(myHeap); <span class="comment">// [3, 5, 4, 45, 15] (根节点变为3，并重新调整)</span></span><br><span class="line"></span><br><span class="line">    minVal = extractMin(myHeap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;提取最小元素: %d\n&quot;</span>, minVal); <span class="comment">// Expected: 3</span></span><br><span class="line">    printHeap(myHeap); <span class="comment">// [4, 5, 15, 45]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 获取最小元素 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前最小元素 (不删除): %d\n&quot;</span>, getMin(myHeap)); <span class="comment">// Expected: 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 释放内存 ------\n&quot;</span>);</span><br><span class="line">    freeMinHeap(myHeap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-堆的应用场景"><a href="#4-堆的应用场景" class="headerlink" title="4. 堆的应用场景"></a>4. 堆的应用场景</h3><p>堆因其高效的插入和删除根节点操作，在许多场景下都非常有用：</p>
<ul>
<li><strong>优先级队列（Priority Queue）：</strong> 这是堆最经典的应用。当需要频繁地获取或处理最高&#x2F;最低优先级的元素时（例如，操作系统的任务调度、事件模拟、图算法中的 Dijkstra 算法和 Prim 算法），堆是最佳选择。</li>
<li><strong>堆排序（Heapsort）：</strong> 一种高效的排序算法，时间复杂度为 O(nlogn)。它通过将待排序元素构建成一个堆，然后重复提取根节点来实现排序。</li>
<li><strong>Top K 问题：</strong> 在大量数据中查找最大&#x2F;最小的 K 个元素。例如，找出成绩最高的 10 个学生，或者找出流量最大的 10 个 IP 地址。可以使用大小为 K 的小顶堆或大顶堆来高效解决。</li>
<li><strong>在线中位数查找：</strong> 结合两个堆（一个最大堆和一个最小堆）可以高效地维护数据流的中位数。</li>
<li><strong>数据压缩（霍夫曼编码）：</strong> 霍夫曼树的构建过程就使用了优先级队列（堆）。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-kmp" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/kmp/" class="article-date">
      <time datetime="2025-05-30T12:50:56.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/kmp/">kmp</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="KMP-算法：字符串匹配的艺术"><a href="#KMP-算法：字符串匹配的艺术" class="headerlink" title="KMP 算法：字符串匹配的艺术"></a>KMP 算法：字符串匹配的艺术</h2><h3 id="1-为什么需要-KMP？暴力匹配的痛点"><a href="#1-为什么需要-KMP？暴力匹配的痛点" class="headerlink" title="1. 为什么需要 KMP？暴力匹配的痛点"></a>1. 为什么需要 KMP？暴力匹配的痛点</h3><p>让我们先回顾一下<strong>暴力匹配</strong>（Brute Force）是如何工作的。假设主串 <code>text = &quot;ABABCABABAB&quot;</code>，模式串 <code>pattern = &quot;ABAB&quot;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">text:    A B A B C A B A B A B</span><br><span class="line">pattern: A B A B</span><br><span class="line">         ^</span><br><span class="line">         (匹配A)</span><br><span class="line"></span><br><span class="line">text:    A B A B C A B A B A B</span><br><span class="line">pattern: A B A B</span><br><span class="line">           ^</span><br><span class="line">           (匹配B)</span><br><span class="line"></span><br><span class="line">text:    A B A B C A B A B A B</span><br><span class="line">pattern: A B A B</span><br><span class="line">             ^</span><br><span class="line">             (匹配A)</span><br><span class="line"></span><br><span class="line">text:    A B A B C A B A B A B</span><br><span class="line">pattern: A B A B</span><br><span class="line">               ^</span><br><span class="line">               (匹配B)</span><br><span class="line"></span><br><span class="line">text:    A B A B C A B A B A B</span><br><span class="line">pattern: A B A B</span><br><span class="line">                 ^</span><br><span class="line">                 (匹配C 与 B 不匹配，模式串整体后移一位，从头开始比较)</span><br><span class="line"></span><br><span class="line">text:    A B A B C A B A B A B</span><br><span class="line">pattern:   A B A B</span><br><span class="line">           ^</span><br><span class="line">           (重新从头开始比较)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当发生不匹配时，暴力匹配会将模式串整体向后移动一位，并重新从模式串的第一个字符开始与主串当前位置的字符进行比较。在最坏情况下（例如 <code>text = &quot;AAAAAAAAB&quot;</code>, <code>pattern = &quot;AAAB&quot;</code>），暴力匹配会进行大量的重复比较，导致时间复杂度高达 O(mn)。</p>
<p>观察上述过程，我们发现一个问题：当 <code>pattern[j]</code> 与 <code>text[i]</code> 不匹配时，我们已经知道 <code>text[i-j ... i-1]</code> 和 <code>pattern[0 ... j-1]</code> 是匹配的。暴力匹配却直接抛弃了这些已匹配的信息，从头再来。KMP 算法正是利用了这些已匹配的信息，避免了主串指针 <code>i</code> 的回溯，从而提高了效率。</p>
<h3 id="2-KMP-算法的核心思想：利用“前缀”和“后缀”"><a href="#2-KMP-算法的核心思想：利用“前缀”和“后缀”" class="headerlink" title="2. KMP 算法的核心思想：利用“前缀”和“后缀”"></a>2. KMP 算法的核心思想：利用“前缀”和“后缀”</h3><p>KMP 算法的关键在于，当模式串与主串发生不匹配时，它不回溯主串的指针，而是根据模式串自身的特点，将模式串向右滑动尽可能远的距离。这个距离的计算依赖于模式串的**“最长公共前后缀”**信息。</p>
<p><strong>什么是“最长公共前后缀”？</strong></p>
<p>对于模式串的任意一个前缀 <code>pattern[0 ... j-1]</code>（即 <code>pattern</code> 的一个子串），我们想找到一个最长的<strong>真前缀</strong>（不包括整个子串本身）和最长的<strong>真后缀</strong>（不包括整个子串本身）是相同的。</p>
<p>例如，模式串 <code>pattern = &quot;ABABA&quot;</code>：</p>
<ul>
<li>当子串是 <code>&quot;A&quot;</code> 时：无公共前后缀。</li>
<li>当子串是 <code>&quot;AB&quot;</code> 时：无公共前后缀。</li>
<li>当子串是 <code>&quot;ABA&quot;</code> 时：前缀 <code>A</code>，后缀 <code>A</code>。最长公共前后缀长度为 1。</li>
<li>当子串是 <code>&quot;ABAB&quot;</code> 时：前缀 <code>A</code>，后缀 <code>B</code>。前缀 <code>AB</code>，后缀 <code>AB</code>。最长公共前后缀长度为 2。</li>
<li>当子串是 <code>&quot;ABABA&quot;</code> 时：前缀 <code>A</code>，后缀 <code>A</code>。前缀 <code>AB</code>，后缀 <code>BA</code>。前缀 <code>ABA</code>，后缀 <code>ABA</code>。最长公共前后缀长度为 3。</li>
</ul>
<p>KMP 算法预处理模式串，生成一个 <code>next</code> 数组（也常被称为 <code>lps</code> 数组，即 Longest Proper Prefix which is also Suffix），这个数组记录了模式串每个前缀的最长公共前后缀的长度。</p>
<h3 id="3-next-数组（或-lps-数组）的构建"><a href="#3-next-数组（或-lps-数组）的构建" class="headerlink" title="3. next 数组（或 lps 数组）的构建"></a>3. <code>next</code> 数组（或 <code>lps</code> 数组）的构建</h3><p>next[j] 表示 pattern[0 … j-1] 这个子串的最长公共前后缀的长度。</p>
<p>约定 next[0] &#x3D; -1 (或 next[0] &#x3D; 0，取决于实现细节)，表示模式串第一个字符失配时，模式串应整体后移一位。</p>
<p>以 <code>pattern = &quot;ABABCABAB&quot;</code> 为例，我们来手动构建 <code>next</code> 数组：</p>
<table>
<thead>
<tr>
<th><strong>索引 j</strong></th>
<th><strong>pattern[j]</strong></th>
<th><strong>pattern[0…j] (子串)</strong></th>
<th><strong>最长公共前后缀 (长度)</strong></th>
<th><strong>next[j+1] (模式串下一个位置的值)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>-</td>
<td>空串</td>
<td>-</td>
<td><code>next[0] = -1</code> (约定)</td>
</tr>
<tr>
<td>0</td>
<td><code>A</code></td>
<td><code>A</code></td>
<td>空串 (0)</td>
<td><code>next[1] = 0</code></td>
</tr>
<tr>
<td>1</td>
<td><code>B</code></td>
<td><code>AB</code></td>
<td>空串 (0)</td>
<td><code>next[2] = 0</code></td>
</tr>
<tr>
<td>2</td>
<td><code>A</code></td>
<td><code>ABA</code></td>
<td><code>A</code> (1)</td>
<td><code>next[3] = 1</code></td>
</tr>
<tr>
<td>3</td>
<td><code>B</code></td>
<td><code>ABAB</code></td>
<td><code>AB</code> (2)</td>
<td><code>next[4] = 2</code></td>
</tr>
<tr>
<td>4</td>
<td><code>C</code></td>
<td><code>ABABC</code></td>
<td>空串 (0)</td>
<td><code>next[5] = 0</code></td>
</tr>
<tr>
<td>5</td>
<td><code>A</code></td>
<td><code>ABabca</code></td>
<td><code>A</code> (1)</td>
<td><code>next[6] = 1</code></td>
</tr>
<tr>
<td>6</td>
<td><code>B</code></td>
<td><code>ABabcAB</code></td>
<td><code>AB</code> (2)</td>
<td><code>next[7] = 2</code></td>
</tr>
<tr>
<td>7</td>
<td><code>A</code></td>
<td><code>ABabcABA</code></td>
<td><code>ABA</code> (3)</td>
<td><code>next[8] = 3</code></td>
</tr>
<tr>
<td>8</td>
<td><code>B</code></td>
<td><code>ABabcABAB</code></td>
<td><code>ABAB</code> (4)</td>
<td><code>next[9] = 4</code></td>
</tr>
</tbody></table>
<p><strong>构建 <code>next</code> 数组的算法：</strong></p>
<p>我们可以使用动态规划的思想来构建 next 数组。</p>
<p>设 next[j] 已经计算好，我们来计算 next[j+1]。</p>
<p>next[j+1] 实际是 pattern[0…j] 这个子串的最长公共前后缀长度。</p>
<ul>
<li>用 <code>k</code> 表示当前已知的最长公共前后缀的长度。初始 <code>k=0</code>。</li>
<li>用 <code>j</code> 遍历模式串的索引。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建 next 数组 (next[i] 表示 pattern[0...i-1] 的最长公共前后缀长度)</span></span><br><span class="line"><span class="comment">// next[0] 通常设为 -1 (或 0)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">computeNextArray</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">int</span> m, <span class="type">int</span>* next)</span> &#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 或 next[0] = 0，取决于后续匹配逻辑</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;   <span class="comment">// k 表示当前已匹配的模式串前缀的长度</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;    <span class="comment">// j 遍历模式串的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m - <span class="number">1</span>) &#123; <span class="comment">// 遍历到 pattern 的倒数第二个字符</span></span><br><span class="line">        <span class="comment">// k == -1 (说明k回溯到-1，或者j=0时) 或 pattern[k] == pattern[j]</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || pattern[k] == pattern[j]) &#123;</span><br><span class="line">            k++; <span class="comment">// 匹配成功，前缀长度增加</span></span><br><span class="line">            j++; <span class="comment">// 模式串的当前字符后移</span></span><br><span class="line">            next[j] = k; <span class="comment">// 更新 next 数组</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配，回溯 k 到 next[k]</span></span><br><span class="line">            <span class="comment">// 这意味着我们尝试用模式串的更短的前缀来匹配</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： 这里的 next 数组定义是 next[j] 表示 pattern[0…j-1] 的最长公共前后缀的长度，即 pattern[j] 失配时，模式串应该移动到 pattern[next[j]] 处继续比较。</p>
<p>或者，更常见的定义是 next[i] 表示 pattern[0…i] 的最长公共前后缀的长度，那么失配时回溯到 next[j-1]。这里我们采用前者，方便后续匹配。</p>
<h3 id="4-KMP-匹配算法"><a href="#4-KMP-匹配算法" class="headerlink" title="4. KMP 匹配算法"></a>4. KMP 匹配算法</h3><p>有了 <code>next</code> 数组，KMP 匹配过程就变得高效了。</p>
<ul>
<li><code>i</code>：主串 <code>text</code> 的当前比较位置。</li>
<li><code>j</code>：模式串 <code>pattern</code> 的当前比较位置。</li>
</ul>
<p><strong>匹配过程：</strong></p>
<ol>
<li><p>当 <code>text[i]</code> 和 <code>pattern[j]</code> 匹配时，<code>i</code> 和 <code>j</code> 同时向后移动一位 (<code>i++</code>, <code>j++</code>)。</p>
</li>
<li><p>当 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text[i]</span><br></pre></td></tr></table></figure>

<p> 和 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern[j]</span><br></pre></td></tr></table></figure>

<p> 不匹配时：</p>
<ul>
<li>如果 <code>j &gt; 0</code>（即不是模式串的第一个字符失配），则将 <code>j</code> 更新为 <code>next[j]</code>。这表示我们将模式串向右滑动，使得 <code>pattern[0 ... next[j]-1]</code> 与 <code>text[i - next[j] ... i-1]</code> 保持对齐，然后从 <code>pattern[next[j]]</code> 处开始重新比较。主串指针 <code>i</code> <strong>不回溯</strong>。</li>
<li>如果 <code>j = 0</code>（即模式串的第一个字符就失配），则只将 <code>i</code> 向后移动一位 (<code>i++</code>)，<code>j</code> 保持为 0（模式串整体后移一位，从头开始比较）。</li>
</ul>
</li>
</ol>
<p>当 <code>j</code> 等于模式串的长度 <code>m</code> 时，表示找到了一个匹配。此时，<code>text</code> 中匹配的起始位置是 <code>i - m</code>。找到后，为了寻找下一个匹配，我们将 <code>j</code> 更新为 <code>next[j]</code> (即 <code>next[m]</code>)，然后继续匹配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP 字符串匹配算法</span></span><br><span class="line"><span class="comment">// 返回模式串在主串中第一次出现的起始索引，未找到则返回 -1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">const</span> <span class="type">char</span>* pattern)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>; <span class="comment">// 主串长度</span></span><br><span class="line">    <span class="keyword">while</span> (text[n] != <span class="string">&#x27;\0&#x27;</span>) n++;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>; <span class="comment">// 模式串长度</span></span><br><span class="line">    <span class="keyword">while</span> (pattern[m] != <span class="string">&#x27;\0&#x27;</span>) m++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 空模式串总是在0位置匹配</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 空主串无法匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* next = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 构建 next 数组</span></span><br><span class="line">    computeNextArray(pattern, m, next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. KMP 匹配过程</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 主串指针</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 模式串指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 当 pattern[j] 和 text[i] 匹配时，或 j 已经回溯到 -1 (模式串整体右移)</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || text[i] == pattern[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配，根据 next 数组移动模式串指针 j</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了一个匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">            <span class="keyword">return</span> i - m; <span class="comment">// 返回匹配的起始位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 未找到匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-完整-C-语言代码示例"><a href="#5-完整-C-语言代码示例" class="headerlink" title="5. 完整 C 语言代码示例"></a>5. 完整 C 语言代码示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// for strlen</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 next 数组 (next[j] 表示 pattern[0...j-1] 的最长公共前后缀长度)</span></span><br><span class="line"><span class="comment">// next[0] 设为 -1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">computeNextArray</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">int</span> m, <span class="type">int</span>* next)</span> &#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 哨兵值，表示模式串第一个字符失配时，主串指针 i 向右移，模式串从头开始</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;   <span class="comment">// k 表示当前已匹配的模式串前缀的长度</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;    <span class="comment">// j 遍历模式串的索引 (pattern[j] 是当前正在考察的字符)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m - <span class="number">1</span>) &#123; <span class="comment">// 遍历到 pattern 的倒数第二个字符</span></span><br><span class="line">        <span class="comment">// 如果 k == -1 (说明模式串已完全回溯，或者 j=0 时)</span></span><br><span class="line">        <span class="comment">// 或者当前考察的字符 pattern[j] 与模式串的第 k 个字符 pattern[k] 相同</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || pattern[k] == pattern[j]) &#123;</span><br><span class="line">            k++; <span class="comment">// 匹配成功，前缀长度 k 增加</span></span><br><span class="line">            j++; <span class="comment">// 模式串的当前字符 j 增加</span></span><br><span class="line">            next[j] = k; <span class="comment">// 更新 next 数组</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配，回溯 k 到 next[k]</span></span><br><span class="line">            <span class="comment">// 尝试用模式串的更短的前缀来匹配</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 字符串匹配算法</span></span><br><span class="line"><span class="comment">// 返回模式串在主串中第一次出现的起始索引，未找到则返回 -1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">const</span> <span class="type">char</span>* pattern)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 空模式串总是在0位置匹配</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 空主串无法匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* next = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 构建 next 数组</span></span><br><span class="line">    computeNextArray(pattern, m, next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. KMP 匹配过程</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 主串指针</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 模式串指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 当 pattern[j] 和 text[i] 匹配时，或 j 已经回溯到 -1 (模式串整体右移)</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || text[i] == pattern[j]) &#123;</span><br><span class="line">            i++; <span class="comment">// 主串指针前进</span></span><br><span class="line">            j++; <span class="comment">// 模式串指针前进</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配，根据 next 数组移动模式串指针 j</span></span><br><span class="line">            <span class="comment">// 主串指针 i 不回溯</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了一个匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">            <span class="keyword">return</span> i - m; <span class="comment">// 返回匹配的起始位置 (i 是匹配结束的后一个位置)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 未找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text1 = <span class="string">&quot;ABABCABABAB&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern1 = <span class="string">&quot;ABAB&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index1 = kmpSearch(text1, pattern1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在 \&quot;%s\&quot; 中查找 \&quot;%s\&quot;，第一次出现位置: %d\n&quot;</span>, text1, pattern1, index1); <span class="comment">// Expected: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text2 = <span class="string">&quot;ABCDEFGH&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern2 = <span class="string">&quot;FGH&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index2 = kmpSearch(text2, pattern2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在 \&quot;%s\&quot; 中查找 \&quot;%s\&quot;，第一次出现位置: %d\n&quot;</span>, text2, pattern2, index2); <span class="comment">// Expected: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text3 = <span class="string">&quot;AAAAAAAAB&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern3 = <span class="string">&quot;AAAB&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index3 = kmpSearch(text3, pattern3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在 \&quot;%s\&quot; 中查找 \&quot;%s\&quot;，第一次出现位置: %d\n&quot;</span>, text3, pattern3, index3); <span class="comment">// Expected: 4</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text4 = <span class="string">&quot;HELLO WORLD&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern4 = <span class="string">&quot;XYZ&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index4 = kmpSearch(text4, pattern4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在 \&quot;%s\&quot; 中查找 \&quot;%s\&quot;，第一次出现位置: %d\n&quot;</span>, text4, pattern4, index4); <span class="comment">// Expected: -1</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text5 = <span class="string">&quot;ABCBABCDABCD&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern5 = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index5 = kmpSearch(text5, pattern5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在 \&quot;%s\&quot; 中查找 \&quot;%s\&quot;，第一次出现位置: %d\n&quot;</span>, text5, pattern5, index5); <span class="comment">// Expected: 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-KMP-算法的优势与复杂度分析"><a href="#6-KMP-算法的优势与复杂度分析" class="headerlink" title="6. KMP 算法的优势与复杂度分析"></a>6. KMP 算法的优势与复杂度分析</h3><ul>
<li><strong>时间复杂度：</strong><ul>
<li>构建 <code>next</code> 数组：O(m)，其中 m 是模式串的长度。</li>
<li>匹配过程：O(n)，其中 n 是主串的长度。主串指针 <code>i</code> 永不回溯，模式串指针 <code>j</code> 最多回溯 m 次（每次回溯都会导致 <code>j</code> 减小），但每次 <code>i</code> 和 <code>j</code> 至少有一个会前进，所以总操作次数是线性的。</li>
<li><strong>总时间复杂度：*<em>O(m+n)*</em></strong>。</li>
</ul>
</li>
<li><strong>空间复杂度：</strong><ul>
<li>O(m)，用于存储 <code>next</code> 数组。</li>
</ul>
</li>
</ul>
<p><strong>与暴力匹配相比，KMP 算法的优势在于：</strong> 它在模式串与主串发生不匹配时，能够利用已匹配的模式串前缀信息，避免主串指针的回溯，从而在最坏情况下也能保持线性时间复杂度。这使得它在处理长文本和重复模式的字符串匹配问题时表现出色。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-DP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/DP/" class="article-date">
      <time datetime="2025-05-30T12:33:08.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/DP/">DP</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="1-爬楼梯"><a href="#1-爬楼梯" class="headerlink" title="1. 爬楼梯"></a>1. 爬楼梯</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<ul>
<li><strong>DP 状态：</strong> <code>dp[i]</code> 表示爬到第 <code>i</code> 阶楼梯的方法数。</li>
<li><strong>状态转移方程：</strong> 爬到第 <code>i</code> 阶，可以从 <code>i-1</code> 阶爬 1 步上来，也可以从 <code>i-2</code> 阶爬 2 步上来。所以 <code>dp[i] = dp[i-1] + dp[i-2]</code>。</li>
<li><strong>初始状态：</strong> <code>dp[0] = 1</code> (到达第 0 阶，视为一种方法)，<code>dp[1] = 1</code> (到达第 1 阶，只有一种方法)。</li>
<li><strong>遍历顺序：</strong> 从 <code>i = 2</code> 到 <code>n</code> 递增。</li>
</ul>
<h4 id="2-最长公共子序列（Longest-Common-Subsequence-LCS）"><a href="#2-最长公共子序列（Longest-Common-Subsequence-LCS）" class="headerlink" title="2. 最长公共子序列（Longest Common Subsequence, LCS）"></a>2. 最长公共子序列（Longest Common Subsequence, LCS）</h4><p>给定两个字符串 S1 和 S2，找到这两个字符串的最长公共子序列的长度。子序列不要求连续。</p>
<ul>
<li><strong>DP 状态：</strong> <code>dp[i][j]</code> 表示字符串 S1 的前 i 个字符和字符串 S2 的前 j 个字符的最长公共子序列的长度。</li>
<li>状态转移方程：<ul>
<li>如果 S1[i−1]&#x3D;&#x3D;S2[j−1] （当前字符相等），那么 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li>
<li>如果 S1[i−1]!&#x3D;S2[j−1] （当前字符不相等），那么 <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code> (取两者中较大的)。</li>
</ul>
</li>
<li><strong>初始状态：</strong> <code>dp[0][j] = 0</code> (S1 为空)，<code>dp[i][0] = 0</code> (S2 为空)。</li>
<li><strong>遍历顺序：</strong> 外层循环 i 从 1 到 len(S1)，内层循环 j 从 1 到 len(S2)。</li>
</ul>
<h3 id="3-0-1-背包问题"><a href="#3-0-1-背包问题" class="headerlink" title="3. 0-1 背包问题"></a>3. 0-1 背包问题</h3><p><strong>特点：</strong> 每件物品<strong>只有一件</strong>，你只能选择<strong>放或不放</strong>（0 或 1）。</p>
<p><strong>场景：</strong> 你要打包旅行，每件衣服只有一件，你决定带哪几件。</p>
<p><strong>动态规划解法：</strong></p>
<ul>
<li><p><strong>DP 状态：</strong> <code>dp[i][j]</code> 表示在前 <code>i</code> 件物品中选择，背包容量为 <code>j</code> 时，能获得的最大价值。</p>
</li>
<li><p><strong>状态转移方程：</strong> 考虑第 <code>i</code> 件物品（假设其重量为 <code>w[i-1]</code>，价值为 <code>v[i-1]</code>）：</p>
<ol>
<li><strong>不选择第 <code>i</code> 件物品：</strong> 此时最大价值等于在前 <code>i-1</code> 件物品中选择，背包容量为 <code>j</code> 时的最大价值，即 <code>dp[i-1][j]</code>。</li>
<li><strong>选择第 <code>i</code> 件物品：</strong> 前提是背包容量 <code>j</code> 足够放下第 <code>i</code> 件物品（即 <code>j &gt;= w[i-1]</code>）。此时，剩余容量为 <code>j - w[i-1]</code>，我们需要在前 <code>i-1</code> 件物品中选择，获得 <code>dp[i-1][j - w[i-1]]</code> 的价值，再加上第 <code>i</code> 件物品的价值 <code>v[i-1]</code>。所以是 <code>dp[i-1][j - w[i-1]] + v[i-1]</code>。</li>
</ol>
<p>综上，当 <code>j &lt; w[i-1]</code> 时，<code>dp[i][j] = dp[i-1][j]</code>。 当 <code>j &gt;= w[i-1]</code> 时，<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i-1]] + v[i-1])</code>。</p>
</li>
<li><p><strong>初始状态：</strong> <code>dp[0][j] = 0</code> (没有物品时，价值为0)，<code>dp[i][0] = 0</code> (背包容量为0时，价值为0)。</p>
</li>
<li><p><strong>遍历顺序：</strong> 外层循环物品 <code>i</code> (从 1 到 <code>N</code>)，内层循环背包容量 <code>j</code> (从 1 到 <code>W</code>)。</p>
</li>
</ul>
<p><strong>空间优化（一维数组）：</strong></p>
<p>由于 <code>dp[i][j]</code> 只依赖于 <code>dp[i-1][...]</code>，我们可以将二维 <code>dp</code> 数组优化为一维 <code>dp</code> 数组。 <code>dp[j]</code> 此时表示背包容量为 <code>j</code> 时的最大价值。</p>
<ul>
<li><strong>状态转移：</strong> <code>dp[j] = max(dp[j], dp[j - w[i]] + v[i])</code></li>
<li><strong>遍历顺序：</strong> <strong>关键在于内层循环 <code>j</code> 必须从 <code>W</code> 到 <code>w[i]</code> 逆序遍历。</strong> 这是为了确保在计算 <code>dp[j]</code> 时，<code>dp[j - w[i]]</code> 还是上一层（即不包含当前物品 <code>i</code>）的值。如果正序遍历，<code>dp[j - w[i]]</code> 可能已经被当前物品 <code>i</code> 更新过，导致物品 <code>i</code> 被重复选择。</li>
</ul>
<p>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def knapsack_01(weights, values, capacity):</span><br><span class="line">    n = len(weights)</span><br><span class="line">    dp = [0] * (capacity + 1)</span><br><span class="line"></span><br><span class="line">    for i in range(n): # 遍历物品</span><br><span class="line">        for j in range(capacity, weights[i] - 1, -1): # 逆序遍历容量</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])</span><br><span class="line">            </span><br><span class="line">    return dp[capacity]</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line"># weights = [2, 1, 3]</span><br><span class="line"># values = [4, 2, 3]</span><br><span class="line"># capacity = 4</span><br><span class="line"># print(knapsack_01(weights, values, capacity)) # Output: 6 (选择物品0和物品1)</span><br></pre></td></tr></table></figure>

<h3 id="4-完全背包问题"><a href="#4-完全背包问题" class="headerlink" title="4. 完全背包问题"></a>4. 完全背包问题</h3><p><strong>特点：</strong> 每件物品有<strong>无限多件</strong>，你可以选择<strong>任意件数</strong>放入背包。</p>
<p><strong>场景：</strong> 你去超市购物，每种商品想买多少就买多少（只要钱够，购物车放得下）。</p>
<p><strong>动态规划解法：</strong></p>
<p>与 0-1 背包的关键区别在于，选择当前物品后，它<strong>仍然可以再次被选择</strong>。</p>
<ul>
<li><strong>DP 状态：</strong> <code>dp[j]</code> 表示背包容量为 <code>j</code> 时，能获得的最大价值。</li>
<li><strong>状态转移方程：</strong> <code>dp[j] = max(dp[j], dp[j - w[i]] + v[i])</code></li>
<li><strong>遍历顺序：</strong> 与 0-1 背包不同的是，<strong>内层循环 <code>j</code> 必须从 <code>w[i]</code> 到 <code>W</code> 正序遍历。</strong> 这是因为在计算 <code>dp[j]</code> 时，如果 <code>j - w[i]</code> 已经包含了当前物品 <code>i</code> 的选择，那么我们就可以继续选择物品 <code>i</code>。正序遍历确保了 <code>dp[j - w[i]]</code> 已经“考虑”过当前物品 <code>i</code> 的选择。</li>
</ul>
<p>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def complete_knapsack(weights, values, capacity):</span><br><span class="line">    n = len(weights)</span><br><span class="line">    dp = [0] * (capacity + 1)</span><br><span class="line"></span><br><span class="line">    for i in range(n): # 遍历物品</span><br><span class="line">        for j in range(weights[i], capacity + 1): # 正序遍历容量</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])</span><br><span class="line">            </span><br><span class="line">    return dp[capacity]</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line"># weights = [2, 1, 3]</span><br><span class="line"># values = [4, 2, 3]</span><br><span class="line"># capacity = 4</span><br><span class="line"># print(complete_knapsack(weights, values, capacity)) # Output: 8 (选择2次物品0，或4次物品1，或2次物品1+1次物品0)</span><br></pre></td></tr></table></figure>

<h3 id="5-多重背包问题"><a href="#5-多重背包问题" class="headerlink" title="5. 多重背包问题"></a>5. 多重背包问题</h3><p><strong>特点：</strong> 每件物品有<strong>固定的数量限制</strong>（例如，第 <code>i</code> 种物品有 <code>count[i]</code> 件）。</p>
<p><strong>场景：</strong> 你去批货，每种商品商家限量供应。</p>
<p><strong>动态规划解法：</strong></p>
<p>多重背包可以看作是 0-1 背包和完全背包的结合。最直接的思路是将其<strong>转化为 0-1 背包问题</strong>。</p>
<p><strong>转化思路：</strong></p>
<p>将每件物品 <code>i</code> 及其数量 <code>count[i]</code> 展开成 <code>count[i]</code> 个独立的 0-1 背包问题中的物品。 例如，物品 A 有 3 件，重量 <code>w_A</code>，价值 <code>v_A</code>。我们可以把它看作 3 个独立的物品：A1 (<code>w_A</code>, <code>v_A</code>), A2 (<code>w_A</code>, <code>v_A</code>), A3 (<code>w_A</code>, <code>v_A</code>)。然后应用 0-1 背包的解法。</p>
<p><strong>优化：二进制拆分</strong></p>
<p>如果物品数量非常大，上述直接展开的方法会导致物品总数剧增，降低效率。更高效的方法是<strong>二进制拆分</strong>。 将每件物品 <code>i</code> 的数量 <code>count[i]</code> 拆分成若干个<strong>幂次为 2</strong> 的物品组合。 例如，如果 <code>count[i] = 13</code>，我们可以拆分成：</p>
<ul>
<li>1 件物品 (价值 <code>1 * v[i]</code>, 重量 <code>1 * w[i]</code>)</li>
<li>2 件物品 (价值 <code>2 * v[i]</code>, 重量 <code>2 * w[i]</code>)</li>
<li>4 件物品 (价值 <code>4 * v[i]</code>, 重量 <code>4 * w[i]</code>)</li>
<li>8 件物品 (价值 <code>8 * v[i]</code>, 重量 <code>8 * w[i]</code>) – 1 + 2 + 4 + 8 &#x3D; 15 &gt; 13，所以最后一个是 <code>13 - (1+2+4) = 6</code> 件物品 (价值 <code>6 * v[i]</code>, 重量 <code>6 * w[i]</code>)。</li>
</ul>
<p>通过这种方式，任何 <code>count[i]</code> 件物品的选择都可以由这些二进制组合的物品来表示，而物品的总数大大减少。然后，对这些“新”物品应用 0-1 背包的解法。</p>
<p>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">def multiple_knapsack(weights, values, counts, capacity):</span><br><span class="line">    # 将多重背包问题转化为0-1背包问题</span><br><span class="line">    # 使用二进制拆分优化</span><br><span class="line">    </span><br><span class="line">    binary_weights = []</span><br><span class="line">    binary_values = []</span><br><span class="line"></span><br><span class="line">    for i in range(len(weights)):</span><br><span class="line">        w, v, c = weights[i], values[i], counts[i]</span><br><span class="line">        k = 1</span><br><span class="line">        while c &gt; 0:</span><br><span class="line">            num = min(k, c)</span><br><span class="line">            binary_weights.append(w * num)</span><br><span class="line">            binary_values.append(v * num)</span><br><span class="line">            c -= num</span><br><span class="line">            k *= 2 # 2的幂次</span><br><span class="line">    </span><br><span class="line">    # 转换为0-1背包问题求解</span><br><span class="line">    n_binary = len(binary_weights)</span><br><span class="line">    dp = [0] * (capacity + 1)</span><br><span class="line"></span><br><span class="line">    for i in range(n_binary):</span><br><span class="line">        for j in range(capacity, binary_weights[i] - 1, -1):</span><br><span class="line">            dp[j] = max(dp[j], dp[j - binary_weights[i]] + binary_values[i])</span><br><span class="line">            </span><br><span class="line">    return dp[capacity]</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line"># weights = [2, 3]</span><br><span class="line"># values = [3, 4]</span><br><span class="line"># counts = [2, 1] # 物品0有2件，物品1有1件</span><br><span class="line"># capacity = 5</span><br><span class="line"># print(multiple_knapsack(weights, values, counts, capacity)) # Output: 7 (选择2件物品0，或1件物品0+1件物品1)</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-图" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/%E5%9B%BE/" class="article-date">
      <time datetime="2025-05-30T12:05:28.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/%E5%9B%BE/">图</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="深入理解“图”"><a href="#深入理解“图”" class="headerlink" title="深入理解“图”"></a>深入理解“图”</h2><h3 id="1-什么是图？"><a href="#1-什么是图？" class="headerlink" title="1. 什么是图？"></a>1. 什么是图？</h3><p>图是由一组<strong>顶点（Vertex &#x2F; Node）</strong> 和连接这些顶点的<strong>边（Edge）</strong> 组成的。简单来说，图 G 可以表示为 G&#x3D;(V,E)，其中 V 是顶点的集合，而 E 是边的集合。</p>
<p><strong>形象比喻：</strong></p>
<ul>
<li><strong>社交网络：</strong> 每个人是一个顶点，朋友关系是连接他们之间的边。</li>
<li><strong>城市交通网络：</strong> 每个城市是一个顶点，连接城市的道路是边。</li>
<li><strong>互联网：</strong> 每个网页是一个顶点，网页之间的链接是边。</li>
</ul>
<h3 id="2-图的基本术语"><a href="#2-图的基本术语" class="headerlink" title="2. 图的基本术语"></a>2. 图的基本术语</h3><p>理解这些术语是掌握图的关键：</p>
<ul>
<li><p><strong>顶点（Vertex &#x2F; Node）：</strong> 图中的基本单元，代表了数据实体。例如，城市、人、网页。</p>
</li>
<li><p><strong>边（Edge）：</strong> 连接两个顶点的线，表示它们之间的关系。例如，道路、朋友关系、网页链接。</p>
</li>
<li><p><strong>邻接（Adjacent）：</strong> 如果两个顶点之间有一条边直接相连，则称它们是邻接的。</p>
</li>
<li><p>度（Degree）：</p>
<p> 对于无向图，一个顶点的度是与它相连的边的数量。</p>
<ul>
<li>对于有向图，分为入度（In-degree）和 出度（Out-degree）。<ul>
<li><strong>入度：</strong> 指向该顶点的边的数量。</li>
<li><strong>出度：</strong> 从该顶点出发的边的数量。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>路径（Path）：</strong> 从一个顶点到另一个顶点所经过的顶点序列（或边序列）。</p>
</li>
<li><p><strong>连通（Connected）：</strong> 在无向图中，如果从顶点 A 到顶点 B 存在一条路径，则称 A 和 B 是连通的。</p>
</li>
<li><p><strong>连通图（Connected Graph）：</strong> 如果图中任意两个顶点都是连通的，则称该图为连通图。</p>
</li>
<li><p><strong>回路&#x2F;环（Cycle）：</strong> 一条起始顶点和结束顶点相同的路径。</p>
</li>
<li><p><strong>权重&#x2F;权值（Weight）：</strong> 边上可以附加一个数值，表示某种成本、距离或强度。这种图称为<strong>带权图（Weighted Graph）</strong>。</p>
</li>
<li><p><strong>子图（Sub-graph）：</strong> 一个图 G′&#x3D;(V′,E′)，其中 V′⊆V 且 E′⊆E。</p>
</li>
</ul>
<h3 id="3-图的分类"><a href="#3-图的分类" class="headerlink" title="3. 图的分类"></a>3. 图的分类</h3><p>图可以根据其边的特性进行分类：</p>
<ul>
<li><strong>无向图（Undirected Graph）：</strong> 边没有方向。如果 A 到 B 有一条边，则意味着 B 到 A 也有相同的连接。例如，朋友关系。</li>
<li><strong>有向图（Directed Graph &#x2F; Digraph）：</strong> 边有方向。如果 A 到 B 有一条边，不代表 B 到 A 也有一条边。例如，单行道，或者 Twitter 上的关注关系（你关注别人，别人不一定关注你）。</li>
</ul>
<hr>
<h3 id="4-图在-C-语言中的表示方法"><a href="#4-图在-C-语言中的表示方法" class="headerlink" title="4. 图在 C 语言中的表示方法"></a>4. 图在 C 语言中的表示方法</h3><p>在 C 语言中，表示图通常有两种主要方式：<strong>邻接矩阵</strong> 和 <strong>邻接表</strong>。选择哪种方式取决于图的特性（顶点数、边数）和具体应用。</p>
<h4 id="4-1-邻接矩阵（Adjacency-Matrix）"><a href="#4-1-邻接矩阵（Adjacency-Matrix）" class="headerlink" title="4.1 邻接矩阵（Adjacency Matrix）"></a>4.1 邻接矩阵（Adjacency Matrix）</h4><p>邻接矩阵是一个 V×V 的二维数组（或矩阵），其中 V 是图中顶点的数量。</p>
<ul>
<li>如果顶点 i 和顶点 j 之间有边相连，则 <code>matrix[i][j] = 1</code> (或表示权重)。</li>
<li>如果无边相连，则 <code>matrix[i][j] = 0</code> (或表示无穷大)。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>优点：<ul>
<li>判断两顶点之间是否存在边非常快速（O(1)）。</li>
<li>实现简单直观。</li>
</ul>
</li>
<li>缺点：<ul>
<li>空间复杂度高：总是 O(V2)，即使图非常稀疏（边很少）。</li>
<li>遍历一个顶点的所有邻居需要 O(V) 的时间。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 顶点数量较少，或者图是稠密的（边很多）的情况。</li>
</ul>
<p><strong>C 语言示例（无向图，不带权）：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 100 <span class="comment">// 最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵表示图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphMatrix</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> numVertices;</span><br><span class="line">    <span class="type">int</span> adjMatrix[MAX_VERTICES][MAX_VERTICES];</span><br><span class="line">&#125; GraphMatrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化图（邻接矩阵）</span></span><br><span class="line">GraphMatrix* <span class="title function_">createGraphMatrix</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">    GraphMatrix* graph = (GraphMatrix*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphMatrix));</span><br><span class="line">    <span class="keyword">if</span> (graph == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    graph-&gt;numVertices = V;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">            graph-&gt;adjMatrix[i][j] = <span class="number">0</span>; <span class="comment">// 初始化为无边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加边（无向图）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdgeMatrix</span><span class="params">(GraphMatrix* graph, <span class="type">int</span> src, <span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (src &gt;= <span class="number">0</span> &amp;&amp; src &lt; graph-&gt;numVertices &amp;&amp; dest &gt;= <span class="number">0</span> &amp;&amp; dest &lt; graph-&gt;numVertices) &#123;</span><br><span class="line">        graph-&gt;adjMatrix[src][dest] = <span class="number">1</span>;</span><br><span class="line">        graph-&gt;adjMatrix[dest][src] = <span class="number">1</span>; <span class="comment">// 无向图，对称</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无效的顶点索引。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印邻接矩阵</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraphMatrix</span><span class="params">(GraphMatrix* graph)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;邻接矩阵：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;numVertices; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; graph-&gt;numVertices; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, graph-&gt;adjMatrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-邻接表（Adjacency-List）"><a href="#4-2-邻接表（Adjacency-List）" class="headerlink" title="4.2 邻接表（Adjacency List）"></a>4.2 邻接表（Adjacency List）</h4><p>邻接表是更常用的一种表示方法，特别适用于稀疏图。它是一个由<strong>链表（或动态数组）</strong> 组成的数组，数组的每个索引代表一个顶点，其对应的链表存储了所有与该顶点邻接的顶点。</p>
<p><strong>特点：</strong></p>
<ul>
<li>优点：<ul>
<li>空间复杂度低：O(V+E)，更适合稀疏图。</li>
<li>遍历一个顶点的所有邻居非常高效（O(degree)）。</li>
</ul>
</li>
<li>缺点：<ul>
<li>判断两顶点之间是否存在边需要遍历链表（最坏 O(degree)）。</li>
<li>实现相对复杂一点。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 顶点数量很大，或者图是稀疏的（边很少）的情况。</li>
</ul>
<p><strong>C 语言示例（无向图，不带权）：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表节点 (表示邻接顶点)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjListNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> dest;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AdjListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; AdjListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义邻接表数组中的每个头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjList</span> &#123;</span></span><br><span class="line">    AdjListNode *head;</span><br><span class="line">&#125; AdjList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表表示图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GraphList</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> numVertices;</span><br><span class="line">    AdjList* <span class="built_in">array</span>; <span class="comment">// 存储 AdjList 结构的数组</span></span><br><span class="line">&#125; GraphList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建邻接列表的新节点</span></span><br><span class="line">AdjListNode* <span class="title function_">newAdjListNode</span><span class="params">(<span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    AdjListNode* newNode = (AdjListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjListNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;dest = dest;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化图（邻接表）</span></span><br><span class="line">GraphList* <span class="title function_">createGraphList</span><span class="params">(<span class="type">int</span> V)</span> &#123;</span><br><span class="line">    GraphList* graph = (GraphList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphList));</span><br><span class="line">    <span class="keyword">if</span> (graph == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    graph-&gt;numVertices = V;</span><br><span class="line"></span><br><span class="line">    graph-&gt;<span class="built_in">array</span> = (AdjList*)<span class="built_in">malloc</span>(V * <span class="keyword">sizeof</span>(AdjList));</span><br><span class="line">    <span class="keyword">if</span> (graph-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        graph-&gt;<span class="built_in">array</span>[i].head = <span class="literal">NULL</span>; <span class="comment">// 初始化所有链表头为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加边（无向图）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdgeList</span><span class="params">(GraphList* graph, <span class="type">int</span> src, <span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (src &gt;= <span class="number">0</span> &amp;&amp; src &lt; graph-&gt;numVertices &amp;&amp; dest &gt;= <span class="number">0</span> &amp;&amp; dest &lt; graph-&gt;numVertices) &#123;</span><br><span class="line">        <span class="comment">// 添加 dest 到 src 的链表</span></span><br><span class="line">        AdjListNode* newNode = newAdjListNode(dest);</span><br><span class="line">        newNode-&gt;next = graph-&gt;<span class="built_in">array</span>[src].head;</span><br><span class="line">        graph-&gt;<span class="built_in">array</span>[src].head = newNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 src 到 dest 的链表 (无向图)</span></span><br><span class="line">        newNode = newAdjListNode(src);</span><br><span class="line">        newNode-&gt;next = graph-&gt;<span class="built_in">array</span>[dest].head;</span><br><span class="line">        graph-&gt;<span class="built_in">array</span>[dest].head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无效的顶点索引。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印邻接表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printGraphList</span><span class="params">(GraphList* graph)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;邻接表：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; graph-&gt;numVertices; v++) &#123;</span><br><span class="line">        AdjListNode* current = graph-&gt;<span class="built_in">array</span>[v].head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顶点 %d 的邻居: &quot;</span>, v);</span><br><span class="line">        <span class="keyword">while</span> (current) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d &quot;</span>, current-&gt;dest);</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&gt; NULL\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放邻接表内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeGraphList</span><span class="params">(GraphList* graph)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;numVertices; i++) &#123;</span><br><span class="line">        AdjListNode* current = graph-&gt;<span class="built_in">array</span>[i].head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            AdjListNode* temp = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(graph-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(graph);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;图的内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-综合示例-main-函数"><a href="#4-3-综合示例-main-函数" class="headerlink" title="4.3 综合示例 main 函数"></a>4.3 综合示例 <code>main</code> 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 示例：邻接矩阵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--- 邻接矩阵示例 ---\n&quot;</span>);</span><br><span class="line">    GraphMatrix* g_matrix = createGraphMatrix(<span class="number">5</span>); <span class="comment">// 创建 5 个顶点的图</span></span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    addEdgeMatrix(g_matrix, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    printGraphMatrix(g_matrix);</span><br><span class="line">    <span class="built_in">free</span>(g_matrix); <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n--- 邻接表示例 ---\n&quot;</span>);</span><br><span class="line">    GraphList* g_list = createGraphList(<span class="number">5</span>); <span class="comment">// 创建 5 个顶点的图</span></span><br><span class="line">    addEdgeList(g_list, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    addEdgeList(g_list, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    addEdgeList(g_list, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    addEdgeList(g_list, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    addEdgeList(g_list, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    addEdgeList(g_list, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    addEdgeList(g_list, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    printGraphList(g_list);</span><br><span class="line">    freeGraphList(g_list); <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-图的遍历"><a href="#5-图的遍历" class="headerlink" title="5. 图的遍历"></a>5. 图的遍历</h3><p>理解图的表示后，如何访问图中的所有顶点和边是另一个核心问题。图的遍历主要有两种方法：</p>
<ul>
<li><strong>广度优先搜索（BFS）：</strong> 从一个顶点开始，逐层访问其所有邻居，然后是邻居的邻居，以此类推。通常使用<strong>队列</strong>实现。</li>
<li><strong>深度优先搜索（DFS）：</strong> 从一个顶点开始，尽可能深地探索其分支，直到无法继续深入，然后回溯。通常使用<strong>栈</strong>（或递归）实现。</li>
</ul>
<p>这两种遍历方法是解决许多图算法的基础，例如查找最短路径、判断连通性等。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
      <time datetime="2025-05-30T12:05:21.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h3><p><strong>树</strong>是一种非线性的数据结构，它由节点（Node）和边（Edge）组成，并且具有层级关系。每个节点可以有零个或多个子节点。</p>
<p>而<strong>二叉树（Binary Tree）</strong> 是一种特殊的树，它的每个节点最多只有<strong>两个</strong>子节点，分别称为<strong>左子节点（Left Child）</strong> 和 <strong>右子节点（Right Child）</strong>。</p>
<p><strong>基本概念：</strong></p>
<ul>
<li><strong>根节点（Root Node）：</strong> 树的顶端节点，没有父节点。</li>
<li><strong>父节点（Parent Node）：</strong> 拥有子节点的节点。</li>
<li><strong>子节点（Child Node）：</strong> 依附于父节点的节点。</li>
<li><strong>兄弟节点（Sibling Node）：</strong> 拥有同一个父节点的节点。</li>
<li><strong>叶子节点（Leaf Node）：</strong> 没有子节点的节点。</li>
<li><strong>路径（Path）：</strong> 从一个节点到另一个节点所经过的节点序列。</li>
<li><strong>深度（Depth）：</strong> 从根节点到某个节点的路径上的边数。根节点的深度为 0。</li>
<li><strong>高度（Height）：</strong> 从某个节点到其最远叶子节点的路径上的边数。叶子节点的高度为 0。树的高度是根节点的高度。</li>
<li><strong>层（Level）：</strong> 节点的深度加 1。根节点在第 1 层。</li>
</ul>
<h3 id="2-C-语言中的二叉树节点定义"><a href="#2-C-语言中的二叉树节点定义" class="headerlink" title="2. C 语言中的二叉树节点定义"></a>2. C 语言中的二叉树节点定义</h3><p>与链表类似，二叉树的节点也可以通过结构体来定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 包含 malloc 和 free</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;               <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span>  <span class="comment">// 指向左子节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span> <span class="comment">// 指向右子节点的指针</span></span><br><span class="line">&#125; TreeNode;</span><br></pre></td></tr></table></figure>

<h3 id="3-二叉树的类型"><a href="#3-二叉树的类型" class="headerlink" title="3. 二叉树的类型"></a>3. 二叉树的类型</h3><p>二叉树有很多种类型，理解它们有助于我们更好地应用：</p>
<ul>
<li><p><strong>满二叉树（Full Binary Tree）：</strong> 除了叶子节点外，所有节点都有两个子节点。</p>
</li>
<li><p><strong>完全二叉树（Complete Binary Tree）：</strong> 除了最后一层，其他层都被完全填满，并且最后一层的所有节点都尽可能地靠左排列。</p>
</li>
<li><p><strong>平衡二叉树（Balanced Binary Tree）：</strong> 左右子树的高度差不超过 1，并且左右子树都是平衡二叉树。常见的有 AVL 树和红黑树。</p>
</li>
<li><p>二叉搜索树（Binary Search Tree, BST）：</p>
<p> 对所有节点都满足以下条件：</p>
<ul>
<li>左子树中所有节点的值都小于当前节点的值。</li>
<li>右子树中所有节点的值都大于当前节点的值。</li>
<li>左右子树也都是二叉搜索树。</li>
</ul>
</li>
</ul>
<h3 id="4-二叉树的遍历方式"><a href="#4-二叉树的遍历方式" class="headerlink" title="4. 二叉树的遍历方式"></a>4. 二叉树的遍历方式</h3><p>遍历二叉树是指按照某种顺序访问树中的所有节点。二叉树的遍历是面试常考点，也是理解树结构的关键。主要有四种基本遍历方式：</p>
<h4 id="4-1-深度优先遍历（Depth-First-Search-DFS）"><a href="#4-1-深度优先遍历（Depth-First-Search-DFS）" class="headerlink" title="4.1 深度优先遍历（Depth-First Search, DFS）"></a>4.1 深度优先遍历（Depth-First Search, DFS）</h4><p>深度优先遍历沿着树的深度方向进行，直到无法继续深入，然后回溯。主要有三种：</p>
<ul>
<li><p><strong>前序遍历（Pre-order Traversal）：</strong> 访问顺序为：<strong>根节点 -&gt; 左子树 -&gt; 右子树</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);      <span class="comment">// 访问根节点</span></span><br><span class="line">    preOrderTraversal(root-&gt;left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    preOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历（In-order Traversal）： 访问顺序为：左子树 -&gt; 根节点 -&gt; 右子树。</p>
<p>对于二叉搜索树，中序遍历会得到一个有序的序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraversal(root-&gt;left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);      <span class="comment">// 访问根节点</span></span><br><span class="line">    inOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历（Post-order Traversal）： 访问顺序为：左子树 -&gt; 右子树 -&gt; 根节点。</p>
<p>通常用于在删除节点前先删除子节点，或计算表达式树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrderTraversal(root-&gt;left);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    postOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);      <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-2-广度优先遍历（Breadth-First-Search-BFS）-层序遍历（Level-order-Traversal）"><a href="#4-2-广度优先遍历（Breadth-First-Search-BFS）-层序遍历（Level-order-Traversal）" class="headerlink" title="4.2 广度优先遍历（Breadth-First Search, BFS）&#x2F; 层序遍历（Level-order Traversal）"></a>4.2 广度优先遍历（Breadth-First Search, BFS）&#x2F; 层序遍历（Level-order Traversal）</h4><p>广度优先遍历逐层访问树的节点，从上到下，从左到右。通常需要借助队列（Queue）来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列结构（用于层序遍历）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    TreeNode* treeNode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    QueueNode* front;</span><br><span class="line">    QueueNode* rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line">Queue* <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* q, TreeNode* treeNode)</span> &#123;</span><br><span class="line">    QueueNode* newNode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    newNode-&gt;treeNode = treeNode;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;front = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* <span class="title function_">dequeue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* temp = q-&gt;front;</span><br><span class="line">    TreeNode* treeNode = temp-&gt;treeNode;</span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> treeNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isQueueEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历 (需要队列辅助)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue* q = createQueue();</span><br><span class="line">    enqueue(q, root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;层序遍历：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isQueueEmpty(q)) &#123;</span><br><span class="line">        TreeNode* current = dequeue(q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            enqueue(q, current-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            enqueue(q, current-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 释放队列内存（这里省略了详细的队列内存释放，实际应用中需要确保释放）</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-二叉搜索树（BST）的实现"><a href="#5-二叉搜索树（BST）的实现" class="headerlink" title="5. 二叉搜索树（BST）的实现"></a>5. 二叉搜索树（BST）的实现</h3><p>BST 是一种非常实用的二叉树，它能高效地进行查找、插入和删除操作。</p>
<h4 id="5-1-插入节点"><a href="#5-1-插入节点" class="headerlink" title="5.1 插入节点"></a>5.1 插入节点</h4><p>插入新节点时，从根节点开始比较，如果新节点的值小于当前节点，则进入左子树；如果大于当前节点，则进入右子树。直到找到一个空位置插入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入节点到二叉搜索树</span></span><br><span class="line">TreeNode* <span class="title function_">insertNode</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        TreeNode* newNode = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;data = value;</span><br><span class="line">        newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = insertNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;right = insertNode(root-&gt;right, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果值相等，通常不插入重复值，或者根据需求决定</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-查找节点"><a href="#5-2-查找节点" class="headerlink" title="5.2 查找节点"></a>5.2 查找节点</h4><p>查找节点与插入类似，通过比较值来决定向左还是向右查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在二叉搜索树中查找节点</span></span><br><span class="line">TreeNode* <span class="title function_">searchNode</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;data == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-删除节点"><a href="#5-3-删除节点" class="headerlink" title="5.3 删除节点"></a>5.3 删除节点</h4><p>删除节点是 BST 操作中最复杂的一个，需要处理以下几种情况：</p>
<ol>
<li><strong>待删除节点是叶子节点：</strong> 直接删除，并将其父节点对应的指针置为 <code>NULL</code>。</li>
<li><strong>待删除节点只有一个子节点：</strong> 用其子节点替换待删除节点。</li>
<li><strong>待删除节点有两个子节点：</strong> 找到其右子树中的最小节点（或左子树中的最大节点）来替换它，然后删除那个最小（或最大）节点。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找二叉搜索树中最小值的节点 (用于删除操作)</span></span><br><span class="line">TreeNode* <span class="title function_">findMinNode</span><span class="params">(TreeNode* node)</span> &#123;</span><br><span class="line">    TreeNode* current = node;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从二叉搜索树中删除节点</span></span><br><span class="line">TreeNode* <span class="title function_">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">        <span class="comment">// 情况1: 没有子节点或只有一个子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* temp = root-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* temp = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况2: 有两个子节点</span></span><br><span class="line">        TreeNode* temp = findMinNode(root-&gt;right); <span class="comment">// 找到右子树中最小的节点</span></span><br><span class="line">        root-&gt;data = temp-&gt;data; <span class="comment">// 将最小节点的数据复制到当前节点</span></span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, temp-&gt;data); <span class="comment">// 在右子树中删除那个最小节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-释放二叉树内存"><a href="#5-4-释放二叉树内存" class="headerlink" title="5.4 释放二叉树内存"></a>5.4 释放二叉树内存</h4><p>递归地释放所有节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放二叉树所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeTree</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    freeTree(root-&gt;left);</span><br><span class="line">    freeTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-完整示例代码"><a href="#6-完整示例代码" class="headerlink" title="6. 完整示例代码"></a>6. 完整示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列结构（用于层序遍历）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    TreeNode* treeNode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    QueueNode* front;</span><br><span class="line">    QueueNode* rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue辅助函数</span></span><br><span class="line">Queue* <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* q, TreeNode* treeNode)</span> &#123;</span><br><span class="line">    QueueNode* newNode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    newNode-&gt;treeNode = treeNode;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;front = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* <span class="title function_">dequeue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* temp = q-&gt;front;</span><br><span class="line">    TreeNode* treeNode = temp-&gt;treeNode;</span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> treeNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isQueueEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!isQueueEmpty(q)) &#123;</span><br><span class="line">        dequeue(q); <span class="comment">// 只是为了清空节点，TreeNode*已经被返回并处理了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新节点（辅助函数）</span></span><br><span class="line">TreeNode* <span class="title function_">createNewNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    TreeNode* newNode = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 二叉树遍历 ----</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">    preOrderTraversal(root-&gt;left);</span><br><span class="line">    preOrderTraversal(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrderTraversal(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">    inOrderTraversal(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrderTraversal(root-&gt;left);</span><br><span class="line">    postOrderTraversal(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue* q = createQueue();</span><br><span class="line">    enqueue(q, root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;层序遍历：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isQueueEmpty(q)) &#123;</span><br><span class="line">        TreeNode* current = dequeue(q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left != <span class="literal">NULL</span>) enqueue(q, current-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right != <span class="literal">NULL</span>) enqueue(q, current-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">// 释放队列本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 二叉搜索树操作 ----</span></span><br><span class="line">TreeNode* <span class="title function_">insertNode</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNewNode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = insertNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;right = insertNode(root-&gt;right, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* <span class="title function_">searchNode</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;data == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* <span class="title function_">findMinNode</span><span class="params">(TreeNode* node)</span> &#123;</span><br><span class="line">    TreeNode* current = node;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* <span class="title function_">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123; <span class="comment">// 没有左子或没有子节点</span></span><br><span class="line">            TreeNode* temp = root-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 只有左子</span></span><br><span class="line">            TreeNode* temp = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有两个子节点</span></span><br><span class="line">        TreeNode* temp = findMinNode(root-&gt;right); <span class="comment">// 找到右子树中最小的节点</span></span><br><span class="line">        root-&gt;data = temp-&gt;data;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放二叉树所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeTree</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    freeTree(root-&gt;left);</span><br><span class="line">    freeTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    TreeNode* root = <span class="literal">NULL</span>; <span class="comment">// 初始化空二叉搜索树</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 插入节点 ------\n&quot;</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">50</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">30</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">70</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">20</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">40</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">60</span>);</span><br><span class="line">    root = insertNode(root, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 遍历操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">    preOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">    inOrderTraversal(root); <span class="comment">// 对于BST，中序遍历是升序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;后序遍历：&quot;</span>);</span><br><span class="line">    postOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    levelOrderTraversal(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 查找操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (searchNode(root, <span class="number">40</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了值为 40 的节点。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 40 的节点。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (searchNode(root, <span class="number">90</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了值为 90 的节点。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 90 的节点。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 删除操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除节点 20 (叶子节点):\n&quot;</span>);</span><br><span class="line">    root = deleteNode(root, <span class="number">20</span>);</span><br><span class="line">    levelOrderTraversal(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除节点 70 (有一个子节点):\n&quot;</span>);</span><br><span class="line">    root = deleteNode(root, <span class="number">70</span>); <span class="comment">// 80会上移</span></span><br><span class="line">    levelOrderTraversal(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除节点 50 (有两个子节点):\n&quot;</span>);</span><br><span class="line">    root = deleteNode(root, <span class="number">50</span>); <span class="comment">// 60会上移</span></span><br><span class="line">    levelOrderTraversal(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 内存释放 ------\n&quot;</span>);</span><br><span class="line">    freeTree(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二叉树内存已释放。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-链式二叉树的变种"><a href="#7-链式二叉树的变种" class="headerlink" title="7. 链式二叉树的变种"></a>7. 链式二叉树的变种</h3><p>除了前面介绍的几种标准二叉树类型，还有一些重要的变种，它们通过改变节点结构或利用空指针来优化某些操作。</p>
<h4 id="7-1-线索二叉树（Threaded-Binary-Tree）"><a href="#7-1-线索二叉树（Threaded-Binary-Tree）" class="headerlink" title="7.1 线索二叉树（Threaded Binary Tree）"></a>7.1 线索二叉树（Threaded Binary Tree）</h4><p><strong>什么是线索二叉树？</strong></p>
<p>在标准的二叉链表表示中，一个含有 n 个节点的二叉树会有 2n 个指针域，其中有 n+1 个空指针域。这些空指针域可以被利用起来，存储节点在中序遍历下的前驱（Predecessor）和后继（Successor）信息，从而方便进行中序遍历而无需使用栈。这种利用空指针域来存储前驱和后继信息的二叉树就称为<strong>线索二叉树</strong>。</p>
<p><strong>线索二叉树节点结构：</strong></p>
<p>为了区分指针是指向子节点还是指向前驱&#x2F;后继，我们通常会在节点中增加两个标志位（<code>ltag</code> 和 <code>rtag</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义线索二叉树节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadedTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadedTreeNode</span> *<span class="title">left</span>;</span>  <span class="comment">// 左子节点指针或前驱线索</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadedTreeNode</span> *<span class="title">right</span>;</span> <span class="comment">// 右子节点指针或后继线索</span></span><br><span class="line">    <span class="type">int</span> ltag; <span class="comment">// 左标志位：0表示left指向左子，1表示left指向前驱</span></span><br><span class="line">    <span class="type">int</span> rtag; <span class="comment">// 右标志位：0表示right指向右子，1表示right指向后继</span></span><br><span class="line">&#125; ThreadedTreeNode;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li><strong>方便遍历：</strong> 特别是中序遍历，可以不使用栈或递归，直接通过线索实现。</li>
<li><strong>空间利用：</strong> 充分利用了二叉树中大量的空指针域。</li>
<li><strong>实现复杂：</strong> 构建线索二叉树和进行插入删除操作比普通二叉树复杂。</li>
</ul>
<p><strong>构建与遍历概述：</strong></p>
<p>线索化过程通常在中序遍历的基础上进行。在遍历过程中，遇到左子节点为空的节点，其 <code>left</code> 指针就指向其前驱；遇到右子节点为空的节点，其 <code>right</code> 指针就指向其后继。</p>
<p>例如，中序线索化：</p>
<p>在遍历到当前节点 p 时，如果 p-&gt;left 为 NULL，则将其设置为指向 p 的前驱节点 pre，并将 p-&gt;ltag 设为 1。如果 pre-&gt;right 为 NULL，则将其设置为指向 p，并将 pre-&gt;rtag 设为 1。pre 始终指向当前节点的前一个访问过的节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线索二叉树节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadedTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadedTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadedTreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag; <span class="comment">// 左标志位：0表示left指向左子，1表示left指向前驱</span></span><br><span class="line">    <span class="type">int</span> rtag; <span class="comment">// 右标志位：0表示right指向右子，1表示right指向后继</span></span><br><span class="line">&#125; ThreadedTreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于中序线索化的前驱指针</span></span><br><span class="line"><span class="type">static</span> ThreadedTreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建一个新的线索二叉树节点。</span></span><br><span class="line"><span class="comment"> * @param value 节点数据。</span></span><br><span class="line"><span class="comment"> * @return 新创建的节点指针。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadedTreeNode* <span class="title function_">createThreadedNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    ThreadedTreeNode* newNode = (ThreadedTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadedTreeNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;ltag = <span class="number">0</span>; <span class="comment">// 初始都设置为指向子节点</span></span><br><span class="line">    newNode-&gt;rtag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 对二叉树进行中序线索化。</span></span><br><span class="line"><span class="comment"> * 递归函数，通过遍历修改空指针域为线索。</span></span><br><span class="line"><span class="comment"> * @param root 当前要线索化的子树的根节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderThreading</span><span class="params">(ThreadedTreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inOrderThreading(root-&gt;left); <span class="comment">// 递归线索化左子树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理当前节点 root</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点的左指针为空，则将其指向前驱 (pre)</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root-&gt;ltag = <span class="number">1</span>;      <span class="comment">// 设置左标志位为线索</span></span><br><span class="line">        root-&gt;left = pre;    <span class="comment">// 左指针指向前驱</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前驱节点的右指针为空，则将其指向当前节点 (root)</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;       <span class="comment">// 设置右标志位为线索</span></span><br><span class="line">        pre-&gt;right = root;   <span class="comment">// 右指针指向后继</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre = root; <span class="comment">// 更新前驱指针为当前节点</span></span><br><span class="line"></span><br><span class="line">    inOrderThreading(root-&gt;right); <span class="comment">// 递归线索化右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化并进行中序线索化。</span></span><br><span class="line"><span class="comment"> * 用于外部调用的入口函数。</span></span><br><span class="line"><span class="comment"> * @param root 二叉树的根节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildThreadedTree</span><span class="params">(ThreadedTreeNode* root)</span> &#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>; <span class="comment">// 每次线索化前重置 pre 指针</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        inOrderThreading(root);</span><br><span class="line">        <span class="comment">// 处理中序遍历的最后一个节点（它的后继应该为NULL）</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">            pre-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在线索二叉树中查找中序遍历的第一个节点。</span></span><br><span class="line"><span class="comment"> * @param root 线索二叉树的根节点。</span></span><br><span class="line"><span class="comment"> * @return 中序遍历的第一个节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadedTreeNode* <span class="title function_">getFirstNode</span><span class="params">(ThreadedTreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadedTreeNode* current = root;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;ltag == <span class="number">0</span> &amp;&amp; current-&gt;left != <span class="literal">NULL</span>) &#123; <span class="comment">// 沿着左子树一直向下</span></span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在线索二叉树中查找节点 node 的中序后继。</span></span><br><span class="line"><span class="comment"> * @param node 要查找后继的节点。</span></span><br><span class="line"><span class="comment"> * @return 节点 node 的中序后继。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadedTreeNode* <span class="title function_">getNextNode</span><span class="params">(ThreadedTreeNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果右标志位为1，说明right指向后继</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rtag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果右标志位为0，说明right指向右子树，需要找到右子树的最左下角节点</span></span><br><span class="line">        ThreadedTreeNode* current = node-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;ltag == <span class="number">0</span>) &#123;</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 对线索二叉树进行中序非递归遍历。</span></span><br><span class="line"><span class="comment"> * 利用线索进行遍历，无需栈或递归。</span></span><br><span class="line"><span class="comment"> * @param root 线索二叉树的根节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraverseThreadedTree</span><span class="params">(ThreadedTreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空树，无法遍历。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThreadedTreeNode* current = getFirstNode(root); <span class="comment">// 从中序遍历的第一个节点开始</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线索二叉树中序遍历结果：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line">        current = getNextNode(current); <span class="comment">// 获取下一个中序节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：将线索指针设为NULL，以方便后续安全释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeThreads</span><span class="params">(ThreadedTreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;ltag == <span class="number">1</span>) &#123; <span class="comment">// 如果是前驱线索，置为NULL</span></span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;ltag = <span class="number">0</span>; <span class="comment">// 可选：将tag还原</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rtag == <span class="number">1</span>) &#123; <span class="comment">// 如果是后继线索，置为NULL</span></span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;rtag = <span class="number">0</span>; <span class="comment">// 可选：将tag还原</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理子节点 (确保只在是真正子节点时递归)</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;ltag == <span class="number">0</span> &amp;&amp; root-&gt;left != <span class="literal">NULL</span>) &#123; <span class="comment">// 再次检查tag是否为0，避免循环</span></span><br><span class="line">        removeThreads(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rtag == <span class="number">0</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>) &#123; <span class="comment">// 再次检查tag是否为0，避免循环</span></span><br><span class="line">        removeThreads(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放线索二叉树所有节点的内存 (需要先移除线索)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeRecursive</span><span class="params">(ThreadedTreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    freeRecursive(root-&gt;left);</span><br><span class="line">    freeRecursive(root-&gt;right);</span><br><span class="line">    <span class="comment">// printf(&quot;释放节点: %d\n&quot;, root-&gt;data); // 可以打印释放的节点</span></span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的释放函数入口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">safeFreeThreadedTree</span><span class="params">(ThreadedTreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 复制一份根节点指针，因为removeThreads可能会修改其子节点的指针，</span></span><br><span class="line">    <span class="comment">// 但不会修改根节点本身的指针，所以直接传入root即可。</span></span><br><span class="line">    <span class="comment">// 但是，为了确保在freeRecursive中不会因为线索而误操作，</span></span><br><span class="line">    <span class="comment">// 最安全的做法是在进行freeRecursive之前，确保所有线索都被置为NULL且tag恢复。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果直接在主函数中调用此函数，且此函数只在最后调用一次，</span></span><br><span class="line">    <span class="comment">// 那么可以先移除线索，再进行普通二叉树的递归释放。</span></span><br><span class="line">    <span class="comment">// 注意：removeThreads会改变树结构，所以一旦调用，就不能再进行线索遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始移除线索...\n&quot;</span>);</span><br><span class="line">    removeThreads(root); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线索已移除，开始释放内存...\n&quot;</span>);</span><br><span class="line">    freeRecursive(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线索二叉树内存已安全释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构建一棵普通的二叉树</span></span><br><span class="line">    ThreadedTreeNode* root = createThreadedNode(<span class="number">50</span>);</span><br><span class="line">    root-&gt;left = createThreadedNode(<span class="number">30</span>);</span><br><span class="line">    root-&gt;right = createThreadedNode(<span class="number">70</span>);</span><br><span class="line">    root-&gt;left-&gt;left = createThreadedNode(<span class="number">20</span>);</span><br><span class="line">    root-&gt;left-&gt;right = createThreadedNode(<span class="number">40</span>);</span><br><span class="line">    root-&gt;right-&gt;left = createThreadedNode(<span class="number">60</span>);</span><br><span class="line">    root-&gt;right-&gt;right = createThreadedNode(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始二叉树（中序遍历验证）：&quot;</span>);</span><br><span class="line">    <span class="comment">// 可以用普通的递归中序遍历验证一下原始树</span></span><br><span class="line">    <span class="comment">// (需要一个临时的非线索中序遍历函数，这里省略，但其输出应与线索化后相同)</span></span><br><span class="line">    <span class="comment">// 预期输出：20 30 40 50 60 70 80</span></span><br><span class="line">    <span class="comment">// 为了简化，我们直接展示线索化后的遍历</span></span><br><span class="line">    ThreadedTreeNode* temp_pre = <span class="literal">NULL</span>; <span class="comment">// 临时的pre指针，用于普通中序遍历</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">simpleInorder</span><span class="params">(ThreadedTreeNode* node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        simpleInorder(node-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);</span><br><span class="line">        simpleInorder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    simpleInorder(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 中序线索化二叉树 ------\n&quot;</span>);</span><br><span class="line">    buildThreadedTree(root); <span class="comment">// 进行中序线索化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线索化完成。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 线索二叉树遍历 ------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用线索二叉树的非递归中序遍历函数</span></span><br><span class="line">    inOrderTraverseThreadedTree(root); <span class="comment">// 预期输出：20 30 40 50 60 70 80</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 验证线索（部分节点） ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节点 20 (叶子节点): 左tag=%d (应为1), 左指针指向 %p (应指向NULL或前驱)\n&quot;</span>, root-&gt;left-&gt;left-&gt;ltag, (<span class="type">void</span>*)root-&gt;left-&gt;left-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节点 20 (叶子节点): 右tag=%d (应为1), 右指针指向 %p (应指向30)\n&quot;</span>, root-&gt;left-&gt;left-&gt;rtag, (<span class="type">void</span>*)root-&gt;left-&gt;left-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left-&gt;left-&gt;rtag == <span class="number">1</span> &amp;&amp; root-&gt;left-&gt;left-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  验证：节点20的后继是 %d\n&quot;</span>, root-&gt;left-&gt;left-&gt;right-&gt;data); <span class="comment">// 应该是30</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节点 30: 左tag=%d (应为0), 左指针指向 %p (应指向20)\n&quot;</span>, root-&gt;left-&gt;ltag, (<span class="type">void</span>*)root-&gt;left-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节点 30: 右tag=%d (应为0), 右指针指向 %p (应指向40)\n&quot;</span>, root-&gt;left-&gt;rtag, (<span class="type">void</span>*)root-&gt;left-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节点 40 (叶子节点): 左tag=%d (应为1), 左指针指向 %p (应指向30)\n&quot;</span>, root-&gt;left-&gt;right-&gt;ltag, (<span class="type">void</span>*)root-&gt;left-&gt;right-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节点 40 (叶子节点): 右tag=%d (应为1), 右指针指向 %p (应指向50)\n&quot;</span>, root-&gt;left-&gt;right-&gt;rtag, (<span class="type">void</span>*)root-&gt;left-&gt;right-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left-&gt;right-&gt;rtag == <span class="number">1</span> &amp;&amp; root-&gt;left-&gt;right-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  验证：节点40的后继是 %d\n&quot;</span>, root-&gt;left-&gt;right-&gt;right-&gt;data); <span class="comment">// 应该是50</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 释放线索二叉树内存 ------\n&quot;</span>);</span><br><span class="line">    safeFreeThreadedTree(root);</span><br><span class="line">    root = <span class="literal">NULL</span>; <span class="comment">// 释放后将根指针设为NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-哈夫曼树（Huffman-Tree-Optimal-Binary-Tree）"><a href="#7-2-哈夫曼树（Huffman-Tree-Optimal-Binary-Tree）" class="headerlink" title="7.2 哈夫曼树（Huffman Tree &#x2F; Optimal Binary Tree）"></a>7.2 哈夫曼树（Huffman Tree &#x2F; Optimal Binary Tree）</h4><p><strong>什么是哈夫曼树？</strong></p>
<p>哈夫曼树是一种带权路径长度最短的二叉树，也称为<strong>最优二叉树</strong>。它的主要应用是在数据压缩领域，即<strong>哈夫曼编码（Huffman Coding）</strong>。</p>
<p><strong>基本概念：</strong></p>
<ul>
<li><strong>路径长度：</strong> 从根节点到某一节点的路径上的边数。</li>
<li><strong>节点权值：</strong> 节点所带的数值。在哈夫曼树中，通常代表字符出现的频率。</li>
<li><strong>带权路径长度：</strong> 节点权值乘以其路径长度。</li>
<li><strong>树的带权路径长度（WPL）：</strong> 树中所有叶子节点的带权路径长度之和。</li>
</ul>
<p><strong>哈夫曼树的构建过程（哈夫曼算法）：</strong></p>
<ol>
<li>将每个带有权值的节点（如字符及其频率）都视为一个独立的树，放入一个集合中。</li>
<li>从集合中选择权值最小的两个树。</li>
<li>构建一个新的父节点，其权值为这两个树的权值之和，并将这两个树作为新父节点的左右子树。</li>
<li>将新生成的树放回集合中。</li>
<li>重复步骤2-4，直到集合中只剩下一棵树，这棵树就是哈夫曼树。</li>
</ol>
<p><strong>哈夫曼编码：</strong></p>
<p>通过哈夫曼树可以生成变长编码。从根节点到每个叶子节点的路径，左分支约定为 ‘0’，右分支约定为 ‘1’。这样，每个字符都对应一个二进制编码。由于哈夫曼树的特性，任何一个字符的编码都不会是另一个字符编码的前缀（即，哈夫曼编码是一种<strong>前缀码</strong>），这使得解码过程非常简单。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>最优性：</strong> 在给定字符频率的情况下，哈夫曼编码是平均编码长度最短的二进制编码。</li>
<li><strong>无歧义解码：</strong> 前缀码特性保证了唯一解码。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// 用于 memset 和 strcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义哈夫曼树节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;                 <span class="comment">// 叶子节点存储字符，非叶子节点可不存储或为特殊值</span></span><br><span class="line">    <span class="type">int</span> weight;                <span class="comment">// 权值（频率）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> *<span class="title">left</span>;</span>  <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> *<span class="title">right</span>;</span> <span class="comment">// 右子节点</span></span><br><span class="line">&#125; HuffmanNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存储哈夫曼编码的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanCode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">char</span> code[<span class="number">256</span>]; <span class="comment">// 假设编码长度不超过255位</span></span><br><span class="line">&#125; HuffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 最小堆实现 ---</span></span><br><span class="line">HuffmanNode* heap[<span class="number">256</span>]; <span class="comment">// 假设最多有256个不同的字符（ASCII）</span></span><br><span class="line"><span class="type">int</span> heapSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swapHuffmanNodes</span><span class="params">(HuffmanNode** a, HuffmanNode** b)</span> &#123;</span><br><span class="line">    HuffmanNode* temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">minHeapify</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="type">int</span> smallest = idx;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * idx + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * idx + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; heap[left]-&gt;weight &lt; heap[smallest]-&gt;weight) &#123;</span><br><span class="line">        smallest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; heap[right]-&gt;weight &lt; heap[smallest]-&gt;weight) &#123;</span><br><span class="line">        smallest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (smallest != idx) &#123;</span><br><span class="line">        swapHuffmanNodes(&amp;heap[idx], &amp;heap[smallest]);</span><br><span class="line">        minHeapify(smallest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertMinHeap</span><span class="params">(HuffmanNode* node)</span> &#123;</span><br><span class="line">    heap[heapSize++] = node;</span><br><span class="line">    <span class="type">int</span> current = heapSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> parent = (current - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &gt; <span class="number">0</span> &amp;&amp; heap[parent]-&gt;weight &gt; heap[current]-&gt;weight) &#123;</span><br><span class="line">        swapHuffmanNodes(&amp;heap[parent], &amp;heap[current]);</span><br><span class="line">        current = parent;</span><br><span class="line">        parent = (current - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuffmanNode* <span class="title function_">extractMin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heapSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (heapSize == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> heap[--heapSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HuffmanNode* root = heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = heap[--heapSize];</span><br><span class="line">    minHeapify(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 哈夫曼树构建 ---</span></span><br><span class="line">HuffmanNode* <span class="title function_">createNode</span><span class="params">(<span class="type">char</span> data, <span class="type">int</span> weight, HuffmanNode* left, HuffmanNode* right)</span> &#123;</span><br><span class="line">    HuffmanNode* newNode = (HuffmanNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HuffmanNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;weight = weight;</span><br><span class="line">    newNode-&gt;left = left;</span><br><span class="line">    newNode-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuffmanNode* <span class="title function_">buildHuffmanTree</span><span class="params">(<span class="type">char</span> data[], <span class="type">int</span> freq[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保堆是空的</span></span><br><span class="line">    heapSize = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        insertMinHeap(createNode(data[i], freq[i], <span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        HuffmanNode* left = extractMin();</span><br><span class="line">        HuffmanNode* right = extractMin();</span><br><span class="line">        HuffmanNode* parent = createNode(<span class="string">&#x27;\0&#x27;</span>, left-&gt;weight + right-&gt;weight, left, right);</span><br><span class="line">        insertMinHeap(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extractMin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 哈夫曼编码生成 ---</span></span><br><span class="line">HuffmanCode huffmanCodes[<span class="number">256</span>];</span><br><span class="line"><span class="type">int</span> codeCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">generateHuffmanCodes</span><span class="params">(HuffmanNode* root, <span class="type">char</span> code[], <span class="type">int</span> top)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历左子树，路径加 &#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">        code[top] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        generateHuffmanCodes(root-&gt;left, code, top + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历右子树，路径加 &#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">        code[top] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        generateHuffmanCodes(root-&gt;right, code, top + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是叶子节点，则找到了一个字符的编码</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        code[top] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 字符串结束符</span></span><br><span class="line">        huffmanCodes[codeCount].data = root-&gt;data;</span><br><span class="line">        <span class="built_in">strcpy</span>(huffmanCodes[codeCount].code, code);</span><br><span class="line">        codeCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHuffmanCodes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;哈夫曼编码列表：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; codeCount; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  &#x27;%c&#x27;: %s\n&quot;</span>, huffmanCodes[i].data, huffmanCodes[i].code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 内存释放 ---</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeHuffmanTree</span><span class="params">(HuffmanNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    freeHuffmanTree(root-&gt;left);</span><br><span class="line">    freeHuffmanTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--- 哈夫曼树与编码示例 ---\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例数据：字符及其频率</span></span><br><span class="line">    <span class="type">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> freq[] = &#123;<span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">45</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始字符及其频率：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  &#x27;%c&#x27;: %d\n&quot;</span>, data[i], freq[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建哈夫曼树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始构建哈夫曼树...\n&quot;</span>);</span><br><span class="line">    HuffmanNode* huffmanRoot = buildHuffmanTree(data, freq, size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;哈夫曼树构建完成。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成哈夫曼编码</span></span><br><span class="line">    <span class="type">char</span> codeBuffer[<span class="number">256</span>];</span><br><span class="line">    codeCount = <span class="number">0</span>; <span class="comment">// 重置编码计数器</span></span><br><span class="line">    generateHuffmanCodes(huffmanRoot, codeBuffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印哈夫曼编码</span></span><br><span class="line">    printHuffmanCodes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放哈夫曼树内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n释放哈夫曼树内存...\n&quot;</span>);</span><br><span class="line">    freeHuffmanTree(huffmanRoot);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;哈夫曼树内存已释放。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="8-并查集（Disjoint-Set-Union-Union-Find-Set）"><a href="#8-并查集（Disjoint-Set-Union-Union-Find-Set）" class="headerlink" title="8. 并查集（Disjoint Set Union &#x2F; Union-Find Set）"></a>8. 并查集（Disjoint Set Union &#x2F; Union-Find Set）</h3><p><strong>什么是并查集？</strong></p>
<p>并查集（Disjoint Set Union，D.S.U.）是一种用于管理元素分组的数据结构。它主要支持两种操作：<strong>合并（Union）</strong> 和 <strong>查找（Find）</strong>。它的核心思想是：每个集合用一棵树来表示，树的根节点就是这个集合的代表元素。</p>
<p><strong>基本概念：</strong></p>
<ul>
<li><strong>集合（Set）：</strong> 一组不相交的元素。</li>
<li><strong>代表元素（Representative）：</strong> 每个集合中都有一个唯一的元素作为该集合的代表。</li>
<li><strong>查找（Find）操作：</strong> 给定一个元素，查找它所属集合的代表元素。这个操作可以用来判断两个元素是否属于同一个集合。</li>
<li><strong>合并（Union）操作：</strong> 将两个不相交的集合合并为一个集合。</li>
</ul>
<p><strong>C 语言中并查集的实现：</strong></p>
<p>通常使用数组来表示每个元素的父节点。<code>parent[i]</code> 存储元素 <code>i</code> 的父节点。如果 <code>parent[i] == i</code>，则 <code>i</code> 是其所在集合的根（代表元素）。</p>
<p>为了优化并查集的性能，通常会结合两种技术：</p>
<ol>
<li><strong>路径压缩（Path Compression）：</strong> 在执行 <code>Find</code> 操作时，将路径上的所有节点直接连接到根节点。这能显著降低后续 <code>Find</code> 操作的复杂度。</li>
<li><strong>按秩合并（Union by Rank）&#x2F; 按大小合并（Union by Size）：</strong> 在执行 <code>Union</code> 操作时，将较小的树连接到较大的树的根上。这样可以保持树的高度尽可能小，从而降低 <code>Find</code> 操作的复杂度。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ELEMENTS 10 <span class="comment">// 定义并查集中元素的最大数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储父节点，parent[i] 表示元素 i 的父节点</span></span><br><span class="line"><span class="comment">// 如果 parent[i] == i，则 i 是其所在集合的根节点</span></span><br><span class="line"><span class="type">int</span> parent[MAX_ELEMENTS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储树的高度或大小，用于优化合并操作（这里使用秩/高度）</span></span><br><span class="line"><span class="type">int</span> ranks[MAX_ELEMENTS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化并查集。</span></span><br><span class="line"><span class="comment"> * 每个元素最初都属于一个独立的集合。</span></span><br><span class="line"><span class="comment"> * @param n 并查集中元素的数量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initDisjointSet</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        parent[i] = i; <span class="comment">// 每个元素的父节点是它自己，表示各自是一个集合</span></span><br><span class="line">        ranks[i] = <span class="number">0</span>;  <span class="comment">// 初始秩为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;并查集已初始化，包含 %d 个元素。\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 查找元素 i 所属集合的代表元素（根节点）。</span></span><br><span class="line"><span class="comment"> * 实现了路径压缩优化。</span></span><br><span class="line"><span class="comment"> * @param i 要查找的元素。</span></span><br><span class="line"><span class="comment"> * @return 元素 i 所属集合的代表元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 i 的父节点就是它自己，说明 i 是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent[i] == i) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归地查找根节点，并进行路径压缩</span></span><br><span class="line">    <span class="comment">// 将路径上的所有节点的父节点直接指向根节点</span></span><br><span class="line">    <span class="keyword">return</span> parent[i] = find(parent[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 合并元素 i 和元素 j 所在的集合。</span></span><br><span class="line"><span class="comment"> * 实现了按秩合并优化。</span></span><br><span class="line"><span class="comment"> * @param i 第一个元素。</span></span><br><span class="line"><span class="comment"> * @param j 第二个元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unite</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> root_i = find(i); <span class="comment">// 查找 i 的代表元素</span></span><br><span class="line">    <span class="type">int</span> root_j = find(j); <span class="comment">// 查找 j 的代表元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两个元素的代表元素不同，说明它们不在同一个集合中，可以合并</span></span><br><span class="line">    <span class="keyword">if</span> (root_i != root_j) &#123;</span><br><span class="line">        <span class="comment">// 按秩合并：将秩较小的树连接到秩较大的树的根上</span></span><br><span class="line">        <span class="keyword">if</span> (ranks[root_i] &lt; ranks[root_j]) &#123;</span><br><span class="line">            parent[root_i] = root_j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[root_j] &lt; ranks[root_i]) &#123;</span><br><span class="line">            parent[root_j] = root_i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 秩相等时，任意一个作为另一个的父节点，并将新根的秩加1</span></span><br><span class="line">            parent[root_j] = root_i;</span><br><span class="line">            ranks[root_i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;合并集合 %d (代表元素 %d) 和 %d (代表元素 %d)。\n&quot;</span>, i, root_i, j, root_j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 和 %d 已经在同一个集合中，无需合并。\n&quot;</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印当前并查集的集合状态。</span></span><br><span class="line"><span class="comment"> * 显示每个元素及其所属集合的代表元素。</span></span><br><span class="line"><span class="comment"> * @param n 并查集中元素的数量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printDisjointSet</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前集合状态 (元素(代表元素)): &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d(%d) &quot;</span>, i, find(i)); <span class="comment">// 打印元素及其代表元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--- 并查集操作示例 ---\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个包含 5 个元素的并查集 (元素编号 0 到 4)</span></span><br><span class="line">    initDisjointSet(<span class="number">5</span>);</span><br><span class="line">    printDisjointSet(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并操作示例</span></span><br><span class="line">    unite(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 合并 0 和 1</span></span><br><span class="line">    printDisjointSet(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    unite(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 合并 2 和 3</span></span><br><span class="line">    printDisjointSet(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    unite(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 合并 0 所在的集合 (包含 0, 1) 和 2 所在的集合 (包含 2, 3)</span></span><br><span class="line">    printDisjointSet(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    unite(<span class="number">0</span>, <span class="number">4</span>); <span class="comment">// 合并 4 到 0 所在的集合</span></span><br><span class="line">    printDisjointSet(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次尝试合并已在同一集合的元素</span></span><br><span class="line">    unite(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    printDisjointSet(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作示例</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n--- 查找操作 ---\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 1 的代表元素是：%d\n&quot;</span>, find(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 3 的代表元素是：%d\n&quot;</span>, find(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 4 的代表元素是：%d\n&quot;</span>, find(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两个元素是否在同一个集合</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n--- 判断集合关系 ---\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (find(<span class="number">1</span>) == find(<span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 1 和 3 在同一个集合中。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 1 和 3 不在同一个集合中。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (find(<span class="number">0</span>) == find(<span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 0 和 4 在同一个集合中。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 0 和 4 不在同一个集合中。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (find(<span class="number">0</span>) == find(MAX_ELEMENTS - <span class="number">1</span>)) &#123; <span class="comment">// 假设 MAX_ELEMENTS 足够大</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 0 和 %d 在同一个集合中。\n&quot;</span>, MAX_ELEMENTS - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 0 和 %d 不在同一个集合中。\n&quot;</span>, MAX_ELEMENTS - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong></p>
<p>并查集在解决以下问题时非常高效：</p>
<ul>
<li>判断图中的连通分量。</li>
<li>判断图中是否存在环（通过 <code>Union</code> 操作）。</li>
<li>最小生成树算法（如 Kruskal 算法）。</li>
<li>社交网络中朋友关系的查询与合并。</li>
<li>游戏中的地图连通性判断。</li>
</ul>
<hr>
<h3 id="9-堆"><a href="#9-堆" class="headerlink" title="9. 堆"></a>9. 堆</h3><p>堆是一种特殊的<strong>完全二叉树</strong>。它的主要特性是：</p>
<ol>
<li><strong>完全二叉树：</strong> 堆必须是一棵完全二叉树。这意味着除了最后一层，其他层都被完全填满，并且最后一层的节点都尽可能地靠左排列。这种结构使得堆可以用<strong>数组</strong>来高效地表示，无需使用指针，节省了内存空间。<ul>
<li>在一个完全二叉树中，如果一个节点的索引是 i：<ul>
<li>它的左子节点的索引是 2i+1。</li>
<li>它的右子节点的索引是 2i+2。</li>
<li>它的父节点的索引是 (i−1)&#x2F;2（整数除法）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>堆序性（Heap Property）：</strong> 堆中的每个节点都满足特定的顺序关系。根据这个关系，堆可以分为两种：<ul>
<li><strong>最大堆（Max-Heap）：</strong> 每个父节点的值都<strong>大于或等于</strong>其子节点的值。因此，根节点是整个堆中的最大值。</li>
<li><strong>最小堆（Min-Heap）：</strong> 每个父节点的值都<strong>小于或等于</strong>其子节点的值。因此，根节点是整个堆中的最小值。</li>
</ul>
</li>
</ol>
<p>本文后续将以<strong>最小堆</strong>为例进行讲解和实现。</p>
<p><strong>为何用数组表示？</strong></p>
<p>完全二叉树的这种特性使得它的节点可以紧密地存储在一个数组中，而不会有任何空隙。通过简单的数学计算，我们就能找到任何一个节点的父节点或子节点，从而避免了传统树结构中因指针操作带来的额外开销和复杂性。</p>
<p>堆的核心操作包括：<strong>插入（Insert）</strong> 和 <strong>删除根节点（Extract Min&#x2F;Max）</strong>。这两个操作都通过维护堆的“堆序性”来实现。</p>
<h4 id="9-1-插入操作（Insert）"><a href="#9-1-插入操作（Insert）" class="headerlink" title="9.1 插入操作（Insert）"></a>9.1 插入操作（Insert）</h4><p>向堆中插入一个新元素时，为了保持堆的完全二叉树结构和堆序性，我们通常这样做：</p>
<ol>
<li>将新元素添加到堆的<strong>末尾</strong>（数组的最后一个位置），以保持完全二叉树的特性。</li>
<li>然后，进行**“上浮”（Heapify-up &#x2F; Sift-up &#x2F; Bubble-up）** 操作：将新元素与其父节点进行比较。如果新元素比父节点小（最小堆）或大（最大堆），则交换它们的位置。这个过程重复进行，直到新元素到达正确的位置（满足堆序性）或者到达根节点。</li>
</ol>
<p>这个上浮过程的时间复杂度是 O(logn)，因为每次比较和交换都会使元素向上移动一层。</p>
<h4 id="9-2-删除根节点（Extract-Min-Max）"><a href="#9-2-删除根节点（Extract-Min-Max）" class="headerlink" title="9.2 删除根节点（Extract Min&#x2F;Max）"></a>9.2 删除根节点（Extract Min&#x2F;Max）</h4><p>删除堆中的根节点（例如，从最小堆中取出最小值）是另一个核心操作：</p>
<ol>
<li>取出根节点的值。</li>
<li>为了保持完全二叉树的结构，将堆中的<strong>最后一个元素</strong>移动到根节点的位置。</li>
<li>然后，进行**“下沉”（Heapify-down &#x2F; Sift-down &#x2F; Bubble-down）** 操作：将新根元素与其子节点进行比较。如果它比子节点大（最小堆）或小（最大堆），则与合适的子节点（最小堆选较小的子节点，最大堆选较大的子节点）交换位置。这个过程重复进行，直到元素到达正确的位置（满足堆序性）或者到达叶子节点。</li>
</ol>
<p>这个下沉过程的时间复杂度也是 O(logn)，因为它每次比较和交换都会使元素向下移动一层。</p>
<h4 id="C语言实现最小堆"><a href="#C语言实现最小堆" class="headerlink" title="C语言实现最小堆"></a>C语言实现最小堆</h4><p>我们用一个数组来表示堆，并实现其核心操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span> <span class="comment">// for INT_MAX</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_HEAP_SIZE 100 <span class="comment">// 定义堆的最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MinHeap</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>* arr;       <span class="comment">// 存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> capacity;  <span class="comment">// 堆的最大容量</span></span><br><span class="line">    <span class="type">int</span> size;      <span class="comment">// 堆当前元素的数量</span></span><br><span class="line">&#125; MinHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个最小堆</span></span><br><span class="line">MinHeap* <span class="title function_">createMinHeap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    MinHeap* heap = (MinHeap*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinHeap));</span><br><span class="line">    <span class="keyword">if</span> (heap == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;capacity = capacity;</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * capacity);</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取左子节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取右子节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上浮操作：维护堆的最小堆序性</span></span><br><span class="line"><span class="comment">// 当一个元素被插入到堆的末尾时，需要向上调整它的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapifyUp</span><span class="params">(MinHeap* heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> parentIndex = getParentIndex(index);</span><br><span class="line">    <span class="comment">// 如果当前节点不是根节点，且比父节点小</span></span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; heap-&gt;arr[parentIndex] &gt; heap-&gt;arr[index]) &#123;</span><br><span class="line">        swap(&amp;heap-&gt;arr[index], &amp;heap-&gt;arr[parentIndex]);</span><br><span class="line">        index = parentIndex;</span><br><span class="line">        parentIndex = getParentIndex(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下沉操作：维护堆的最小堆序性</span></span><br><span class="line"><span class="comment">// 当根节点被删除或元素被修改时，需要向下调整它的位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapifyDown</span><span class="params">(MinHeap* heap, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> smallest = index;</span><br><span class="line">    <span class="type">int</span> leftChild = getLeftChildIndex(index);</span><br><span class="line">    <span class="type">int</span> rightChild = getRightChildIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点存在且比当前最小的小</span></span><br><span class="line">    <span class="keyword">if</span> (leftChild &lt; heap-&gt;size &amp;&amp; heap-&gt;arr[leftChild] &lt; heap-&gt;arr[smallest]) &#123;</span><br><span class="line">        smallest = leftChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点存在且比当前最小的小</span></span><br><span class="line">    <span class="keyword">if</span> (rightChild &lt; heap-&gt;size &amp;&amp; heap-&gt;arr[rightChild] &lt; heap-&gt;arr[smallest]) &#123;</span><br><span class="line">        smallest = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最小的不是当前节点，则交换并继续向下沉</span></span><br><span class="line">    <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">        swap(&amp;heap-&gt;arr[index], &amp;heap-&gt;arr[smallest]);</span><br><span class="line">        heapifyDown(heap, smallest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素到最小堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertMinHeap</span><span class="params">(MinHeap* heap, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size == heap-&gt;capacity) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆已满，无法插入！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新元素添加到数组末尾</span></span><br><span class="line">    heap-&gt;arr[heap-&gt;size] = value;</span><br><span class="line">    heap-&gt;size++;</span><br><span class="line">    <span class="comment">// 进行上浮操作</span></span><br><span class="line">    heapifyUp(heap, heap-&gt;size - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入 %d 成功。\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取最小元素（根节点）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">extractMin</span><span class="params">(MinHeap* heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆为空，无法提取！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> INT_MAX; <span class="comment">// 返回一个表示错误的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size == <span class="number">1</span>) &#123; <span class="comment">// 只有一个元素</span></span><br><span class="line">        heap-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> heap-&gt;arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存根节点的值</span></span><br><span class="line">    <span class="type">int</span> root = heap-&gt;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 将最后一个元素移动到根节点</span></span><br><span class="line">    heap-&gt;arr[<span class="number">0</span>] = heap-&gt;arr[heap-&gt;size - <span class="number">1</span>];</span><br><span class="line">    heap-&gt;size--;</span><br><span class="line">    <span class="comment">// 进行下沉操作</span></span><br><span class="line">    heapifyDown(heap, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取堆的最小元素（不删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMin</span><span class="params">(MinHeap* heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆为空。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印堆的数组表示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHeap</span><span class="params">(MinHeap* heap)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;堆的数组表示: [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heap-&gt;size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, heap-&gt;arr[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; heap-&gt;size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放堆内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeMinHeap</span><span class="params">(MinHeap* heap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(heap-&gt;arr);</span><br><span class="line">    <span class="built_in">free</span>(heap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;堆内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MinHeap* myHeap = createMinHeap(MAX_HEAP_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 插入元素 ------\n&quot;</span>);</span><br><span class="line">    insertMinHeap(myHeap, <span class="number">3</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [3]</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">2</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3]</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">15</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3, 15]</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">5</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3, 5, 15]</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">4</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3, 4, 15, 5] (实际为[2, 3, 4, 15, 5]或[2, 5, 4, 15, 3]等，取决于具体路径，但都满足最小堆序性)</span></span><br><span class="line">    insertMinHeap(myHeap, <span class="number">45</span>);</span><br><span class="line">    printHeap(myHeap); <span class="comment">// [2, 3, 4, 45, 5, 15]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 提取最小元素 ------\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> minVal = extractMin(myHeap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;提取最小元素: %d\n&quot;</span>, minVal); <span class="comment">// Expected: 2</span></span><br><span class="line">    printHeap(myHeap); <span class="comment">// [3, 5, 4, 45, 15] (根节点变为3，并重新调整)</span></span><br><span class="line"></span><br><span class="line">    minVal = extractMin(myHeap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;提取最小元素: %d\n&quot;</span>, minVal); <span class="comment">// Expected: 3</span></span><br><span class="line">    printHeap(myHeap); <span class="comment">// [4, 5, 15, 45]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 获取最小元素 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前最小元素 (不删除): %d\n&quot;</span>, getMin(myHeap)); <span class="comment">// Expected: 4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 释放内存 ------\n&quot;</span>);</span><br><span class="line">    freeMinHeap(myHeap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆的应用场景"><a href="#堆的应用场景" class="headerlink" title="堆的应用场景"></a>堆的应用场景</h4><p>堆因其高效的插入和删除根节点操作，在许多场景下都非常有用：</p>
<ul>
<li><strong>优先级队列（Priority Queue）：</strong> 这是堆最经典的应用。当需要频繁地获取或处理最高&#x2F;最低优先级的元素时（例如，操作系统的任务调度、事件模拟、图算法中的 Dijkstra 算法和 Prim 算法），堆是最佳选择。</li>
<li><strong>堆排序（Heapsort）：</strong> 一种高效的排序算法，时间复杂度为 O(nlogn)。它通过将待排序元素构建成一个堆，然后重复提取根节点来实现排序。</li>
<li><strong>Top K 问题：</strong> 在大量数据中查找最大&#x2F;最小的 K 个元素。例如，找出成绩最高的 10 个学生，或者找出流量最大的 10 个 IP 地址。可以使用大小为 K 的小顶堆或大顶堆来高效解决。</li>
<li><strong>在线中位数查找：</strong> 结合两个堆（一个最大堆和一个最小堆）可以高效地维护数据流的中位数。</li>
<li><strong>数据压缩（霍夫曼编码）：</strong> 霍夫曼树的构建过程就使用了优先级队列（堆）。</li>
</ul>
<hr>
<h3 id="10-AVL树"><a href="#10-AVL树" class="headerlink" title="10. AVL树"></a>10. AVL树</h3><p>在之前的文章中，我们介绍了二叉搜索树（BST），它能提供高效的查找、插入和删除操作。然而，BST 的性能高度依赖于树的结构。在最坏的情况下，如果插入的元素是有序的，BST 可能会退化成一个链表，导致所有操作的时间复杂度退化到 O(n)。</p>
<p>为了解决这个问题，需要一种能够自我平衡的二叉搜索树。<strong>AVL树</strong>就是最先发明的自平衡二叉搜索树。它保证了树的高度差不超过1，从而确保了 O(logn) 的操作时间复杂度。</p>
<p><strong>AVL树</strong>是一种特殊的二叉搜索树，它具有以下特性：</p>
<ol>
<li><p>它首先是一棵<strong>二叉搜索树</strong>。</p>
</li>
<li><p>对于任意一个节点，其</p>
<p>左子树的高度与右子树的高度之差的绝对值不超过 1</p>
<p>。这个高度差被称为</p>
<p>平衡因子（Balance Factor）</p>
<p>。</p>
<ul>
<li>平衡因子 &#x3D; 左子树高度 - 右子树高度</li>
<li>平衡因子只可能为 -1、0 或 1。</li>
</ul>
</li>
</ol>
<p>如果一个节点的平衡因子超出这个范围（例如 -2 或 2），那么这棵树就失去了平衡，需要通过<strong>旋转</strong>操作来重新恢复平衡。</p>
<h4 id="AVL树节点定义"><a href="#AVL树节点定义" class="headerlink" title="AVL树节点定义"></a>AVL树节点定义</h4><p>除了数据和左右子节点指针外，AVL树的节点还需要存储其<strong>高度（height）或平衡因子（balance factor）</strong>。通常存储高度更方便，因为平衡因子可以通过子节点高度计算出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 包含 malloc 和 free 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义AVL树节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;                 <span class="comment">// 节点存储的数据</span></span><br><span class="line">    <span class="type">int</span> height;               <span class="comment">// 当前节点的高度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">left</span>;</span>     <span class="comment">// 左子节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">right</span>;</span>    <span class="comment">// 右子节点指针</span></span><br><span class="line">&#125; AVLNode;</span><br></pre></td></tr></table></figure>

<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>AVL树的所有操作（查找、插入、删除）都首先遵循二叉搜索树的规则，但在每次修改树结构（插入或删除节点）后，都需要检查是否破坏了AVL树的平衡特性，如果失衡，则需要进行平衡操作（旋转）。</p>
<h5 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h5><p>在实现AVL树操作之前，我们需要一些辅助函数：</p>
<ul>
<li><p><strong>获取节点高度：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取节点高度，空节点高度为-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(AVLNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>计算平衡因子：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算节点的平衡因子</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(AVLNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getHeight(node-&gt;left) - getHeight(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新节点高度：</p>
<p>在进行插入、删除或旋转操作后，节点的子树结构可能会改变，需要更新节点的高度。节点的高度为其左右子树最大高度加 1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新节点高度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateHeight</span><span class="params">(AVLNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">int</span> leftHeight = getHeight(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight = getHeight(node-&gt;right);</span><br><span class="line">        node-&gt;height = (leftHeight &gt; rightHeight ? leftHeight : rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建新节点：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的AVL节点</span></span><br><span class="line">AVLNode* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    AVLNode* newNode = (AVLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVLNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;height = <span class="number">0</span>; <span class="comment">// 新叶子节点的高度为0</span></span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h5><p>当AVL树失衡时（平衡因子为 -2 或 2），需要通过旋转操作来恢复平衡。旋转操作有四种基本类型：</p>
<ol>
<li><p><strong>LL型（右旋）：</strong> 当左子树的左子树过高导致失衡时。</p>
<ul>
<li>失衡情况：<code>root</code> 的平衡因子为 2，且 <code>root-&gt;left</code> 的平衡因子为 1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右旋 (LL型)</span></span><br><span class="line"><span class="comment">// p 节点为根，q 节点为 p 的左子节点</span></span><br><span class="line"><span class="comment">// 旋转后 q 变为新的根</span></span><br><span class="line">AVLNode* <span class="title function_">rightRotate</span><span class="params">(AVLNode* p)</span> &#123;</span><br><span class="line">    AVLNode* q = p-&gt;left;</span><br><span class="line">    AVLNode* T2 = q-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行旋转</span></span><br><span class="line">    q-&gt;right = p;</span><br><span class="line">    p-&gt;left = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    updateHeight(p);</span><br><span class="line">    updateHeight(q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q; <span class="comment">// 返回新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>RR型（左旋）：</strong> 当右子树的右子树过高导致失衡时。</p>
<ul>
<li>失衡情况：<code>root</code> 的平衡因子为 -2，且 <code>root-&gt;right</code> 的平衡因子为 -1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左旋 (RR型)</span></span><br><span class="line"><span class="comment">// p 节点为根，q 节点为 p 的右子节点</span></span><br><span class="line"><span class="comment">// 旋转后 q 变为新的根</span></span><br><span class="line">AVLNode* <span class="title function_">leftRotate</span><span class="params">(AVLNode* p)</span> &#123;</span><br><span class="line">    AVLNode* q = p-&gt;right;</span><br><span class="line">    AVLNode* T2 = q-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行旋转</span></span><br><span class="line">    q-&gt;left = p;</span><br><span class="line">    p-&gt;right = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    updateHeight(p);</span><br><span class="line">    updateHeight(q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q; <span class="comment">// 返回新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LR型（先左旋后右旋）：</strong> 当左子树的右子树过高导致失衡时。</p>
<ul>
<li>失衡情况：<code>root</code> 的平衡因子为 2，且 <code>root-&gt;left</code> 的平衡因子为 -1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LR型 (先左旋后右旋)</span></span><br><span class="line">AVLNode* <span class="title function_">leftRightRotate</span><span class="params">(AVLNode* node)</span> &#123;</span><br><span class="line">    node-&gt;left = leftRotate(node-&gt;left); <span class="comment">// 对左子节点进行左旋</span></span><br><span class="line">    <span class="keyword">return</span> rightRotate(node);            <span class="comment">// 对当前节点进行右旋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>RL型（先右旋后左旋）：</strong> 当右子树的左子树过高导致失衡时。</p>
<ul>
<li>失衡情况：<code>root</code> 的平衡因子为 -2，且 <code>root-&gt;right</code> 的平衡因子为 1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RL型 (先右旋后左旋)</span></span><br><span class="line">AVLNode* <span class="title function_">rightLeftRotate</span><span class="params">(AVLNode* node)</span> &#123;</span><br><span class="line">    node-&gt;right = rightRotate(node-&gt;right); <span class="comment">// 对右子节点进行右旋</span></span><br><span class="line">    <span class="keyword">return</span> leftRotate(node);             <span class="comment">// 对当前节点进行左旋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h5><p>插入操作是递归进行的。在递归回溯的过程中，会检查每个节点的平衡因子，如果失衡，则进行相应的旋转操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入节点到AVL树</span></span><br><span class="line">AVLNode* <span class="title function_">insert</span><span class="params">(AVLNode* node, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 执行普通的BST插入</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; node-&gt;data) &#123;</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node-&gt;data) &#123;</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 值相等，不允许插入重复值（或根据需求处理）</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新当前节点的高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 检查平衡因子并进行旋转</span></span><br><span class="line">    <span class="type">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LL 型：左子树的左子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; value &lt; node-&gt;left-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RR 型：右子树的右子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; <span class="number">-1</span> &amp;&amp; value &gt; node-&gt;right-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LR 型：左子树的右子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; value &gt; node-&gt;left-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RL 型：右子树的左子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; <span class="number">-1</span> &amp;&amp; value &lt; node-&gt;right-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightLeftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node; <span class="comment">// 返回（可能已旋转的）子树的根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><p>删除操作比插入更复杂，因为它也需要处理BST删除的三种情况（叶子节点、单子节点、双子节点），并在每次递归回溯时检查平衡并进行旋转。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找二叉搜索树中最小值的节点 (用于删除操作)</span></span><br><span class="line">AVLNode* <span class="title function_">findMinNode</span><span class="params">(AVLNode* node)</span> &#123;</span><br><span class="line">    AVLNode* current = node;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从AVL树中删除节点</span></span><br><span class="line">AVLNode* <span class="title function_">deleteNode</span><span class="params">(AVLNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 执行普通的BST删除</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">        <span class="comment">// 情况1: 没有子节点或只有一个子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> || root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            AVLNode* temp = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123; <span class="comment">// 没有子节点 (叶子节点)</span></span><br><span class="line">                temp = root;</span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 有一个子节点</span></span><br><span class="line">                *root = *temp; <span class="comment">// 将子节点的内容复制到当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(temp); <span class="comment">// 释放子节点或原叶子节点内存</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况2: 有两个子节点</span></span><br><span class="line">            AVLNode* temp = findMinNode(root-&gt;right); <span class="comment">// 找到右子树中最小的节点 (中序后继)</span></span><br><span class="line">            root-&gt;data = temp-&gt;data;                 <span class="comment">// 将最小节点的数据复制到当前节点</span></span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;data); <span class="comment">// 在右子树中删除那个最小节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果树为空，直接返回 (可能删除的是最后一个节点)</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新当前节点的高度</span></span><br><span class="line">    updateHeight(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 检查平衡因子并进行旋转</span></span><br><span class="line">    <span class="type">int</span> balanceFactor = getBalanceFactor(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LL 型：左子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(root-&gt;left) &gt;= <span class="number">0</span>) &#123; <span class="comment">// &gt;=0 包含了LL和LR的root-&gt;left-&gt;left</span></span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LR 型：左子树的右子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(root-&gt;left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RR 型：右子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; <span class="number">-1</span> &amp;&amp; getBalanceFactor(root-&gt;right) &lt;= <span class="number">0</span>) &#123; <span class="comment">// &lt;=0 包含了RR和RL的root-&gt;right-&gt;right</span></span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RL 型：右子树的左子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; <span class="number">-1</span> &amp;&amp; getBalanceFactor(root-&gt;right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightLeftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 返回（可能已旋转的）子树的根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查找结点"><a href="#查找结点" class="headerlink" title="查找结点"></a>查找结点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在AVL树中查找节点 (与BST查找相同)</span></span><br><span class="line">AVLNode* <span class="title function_">searchNode</span><span class="params">(AVLNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;data == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h5><p>AVL树的遍历方式与普通二叉树相同（前序、中序、后序、层序）。中序遍历依然会得到有序序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历 (用于验证有序性)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(AVLNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraversal(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d(H:%d) &quot;</span>, root-&gt;data, root-&gt;height); <span class="comment">// 打印数据和高度</span></span><br><span class="line">    inOrderTraversal(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(AVLNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d(H:%d, BF:%d) &quot;</span>, root-&gt;data, root-&gt;height, getBalanceFactor(root)); <span class="comment">// 打印数据、高度和平衡因子</span></span><br><span class="line">    preOrderTraversal(root-&gt;left);</span><br><span class="line">    preOrderTraversal(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放AVL树所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeAVLTree</span><span class="params">(AVLNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    freeAVLTree(root-&gt;left);</span><br><span class="line">    freeAVLTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义AVL树节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;                 <span class="comment">// 节点存储的数据</span></span><br><span class="line">    <span class="type">int</span> height;               <span class="comment">// 当前节点的高度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">left</span>;</span>     <span class="comment">// 左子节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">right</span>;</span>    <span class="comment">// 右子节点指针</span></span><br><span class="line">&#125; AVLNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 辅助函数 ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点高度，空节点高度为-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(AVLNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算节点的平衡因子</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(AVLNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getHeight(node-&gt;left) - getHeight(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新节点高度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateHeight</span><span class="params">(AVLNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">int</span> leftHeight = getHeight(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight = getHeight(node-&gt;right);</span><br><span class="line">        node-&gt;height = (leftHeight &gt; rightHeight ? leftHeight : rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的AVL节点</span></span><br><span class="line">AVLNode* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    AVLNode* newNode = (AVLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AVLNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;height = <span class="number">0</span>; <span class="comment">// 新叶子节点的高度为0</span></span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 旋转操作 ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋 (LL型)</span></span><br><span class="line">AVLNode* <span class="title function_">rightRotate</span><span class="params">(AVLNode* p)</span> &#123;</span><br><span class="line">    AVLNode* q = p-&gt;left;</span><br><span class="line">    AVLNode* T2 = q-&gt;right;</span><br><span class="line"></span><br><span class="line">    q-&gt;right = p;</span><br><span class="line">    p-&gt;left = T2;</span><br><span class="line"></span><br><span class="line">    updateHeight(p);</span><br><span class="line">    updateHeight(q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋 (RR型)</span></span><br><span class="line">AVLNode* <span class="title function_">leftRotate</span><span class="params">(AVLNode* p)</span> &#123;</span><br><span class="line">    AVLNode* q = p-&gt;right;</span><br><span class="line">    AVLNode* T2 = q-&gt;left;</span><br><span class="line"></span><br><span class="line">    q-&gt;left = p;</span><br><span class="line">    p-&gt;right = T2;</span><br><span class="line"></span><br><span class="line">    updateHeight(p);</span><br><span class="line">    updateHeight(q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LR型 (先左旋后右旋)</span></span><br><span class="line">AVLNode* <span class="title function_">leftRightRotate</span><span class="params">(AVLNode* node)</span> &#123;</span><br><span class="line">    node-&gt;left = leftRotate(node-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RL型 (先右旋后左旋)</span></span><br><span class="line">AVLNode* <span class="title function_">rightLeftRotate</span><span class="params">(AVLNode* node)</span> &#123;</span><br><span class="line">    node-&gt;right = rightRotate(node-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- AVL树操作 ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点到AVL树</span></span><br><span class="line">AVLNode* <span class="title function_">insert</span><span class="params">(AVLNode* node, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; node-&gt;data) &#123;</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node-&gt;data) &#123;</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 值相等，不允许插入重复值</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateHeight(node); <span class="comment">// 更新当前节点的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查平衡因子并进行旋转</span></span><br><span class="line">    <span class="type">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LL 型：左子树的左子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; value &lt; node-&gt;left-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RR 型：右子树的右子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; <span class="number">-1</span> &amp;&amp; value &gt; node-&gt;right-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LR 型：左子树的右子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; value &gt; node-&gt;left-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RL 型：右子树的左子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; <span class="number">-1</span> &amp;&amp; value &lt; node-&gt;right-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightLeftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找二叉搜索树中最小值的节点 (用于删除操作)</span></span><br><span class="line">AVLNode* <span class="title function_">findMinNode</span><span class="params">(AVLNode* node)</span> &#123;</span><br><span class="line">    AVLNode* current = node;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从AVL树中删除节点</span></span><br><span class="line">AVLNode* <span class="title function_">deleteNode</span><span class="params">(AVLNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">        <span class="comment">// 情况1: 没有子节点或只有一个子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> || root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            AVLNode* temp = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123; <span class="comment">// 没有子节点 (叶子节点)</span></span><br><span class="line">                temp = root;</span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 有一个子节点</span></span><br><span class="line">                *root = *temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况2: 有两个子节点</span></span><br><span class="line">            AVLNode* temp = findMinNode(root-&gt;right);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果树为空，直接返回 (可能删除的是最后一个节点)</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateHeight(root); <span class="comment">// 更新当前节点的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查平衡因子并进行旋转</span></span><br><span class="line">    <span class="type">int</span> balanceFactor = getBalanceFactor(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LL 型：左子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(root-&gt;left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LR 型：左子树的右子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(root-&gt;left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RR 型：右子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; <span class="number">-1</span> &amp;&amp; getBalanceFactor(root-&gt;right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RL 型：右子树的左子树过高</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; <span class="number">-1</span> &amp;&amp; getBalanceFactor(root-&gt;right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightLeftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在AVL树中查找节点</span></span><br><span class="line">AVLNode* <span class="title function_">searchNode</span><span class="params">(AVLNode* root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;data == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; root-&gt;data) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 遍历操作 ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历 (用于验证有序性)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(AVLNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraversal(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d(H:%d) &quot;</span>, root-&gt;data, root-&gt;height);</span><br><span class="line">    inOrderTraversal(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历 (用于查看结构)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(AVLNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d(H:%d, BF:%d) &quot;</span>, root-&gt;data, root-&gt;height, getBalanceFactor(root));</span><br><span class="line">    preOrderTraversal(root-&gt;left);</span><br><span class="line">    preOrderTraversal(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 内存释放 ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放AVL树所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeAVLTree</span><span class="params">(AVLNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    freeAVLTree(root-&gt;left);</span><br><span class="line">    freeAVLTree(root-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    AVLNode* root = <span class="literal">NULL</span>; <span class="comment">// 初始化空AVL树</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 插入节点 ------\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> elements[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">35</span>&#125;;</span><br><span class="line">    <span class="type">int</span> numElements = <span class="keyword">sizeof</span>(elements) / <span class="keyword">sizeof</span>(elements[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numElements; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入 %d...\n&quot;</span>, elements[i]);</span><br><span class="line">        root = insert(root, elements[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  当前树前序遍历: &quot;</span>);</span><br><span class="line">        preOrderTraversal(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  当前树中序遍历: &quot;</span>);</span><br><span class="line">        inOrderTraversal(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n--- 最终AVL树结构 ---\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前序遍历 (Data(Height, BF)): &quot;</span>);</span><br><span class="line">    preOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中序遍历 (Data(Height)): &quot;</span>);</span><br><span class="line">    inOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 查找操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (searchNode(root, <span class="number">30</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了值为 30 的节点。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 30 的节点。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (searchNode(root, <span class="number">100</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了值为 100 的节点。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 100 的节点。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 删除操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除节点 20...\n&quot;</span>);</span><br><span class="line">    root = deleteNode(root, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  删除后前序遍历: &quot;</span>);</span><br><span class="line">    preOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  删除后中序遍历: &quot;</span>);</span><br><span class="line">    inOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除节点 30...\n&quot;</span>);</span><br><span class="line">    root = deleteNode(root, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  删除后前序遍历: &quot;</span>);</span><br><span class="line">    preOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  删除后中序遍历: &quot;</span>);</span><br><span class="line">    inOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除节点 10 (根节点)...\n&quot;</span>);</span><br><span class="line">    root = deleteNode(root, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  删除后前序遍历: &quot;</span>);</span><br><span class="line">    preOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  删除后中序遍历: &quot;</span>);</span><br><span class="line">    inOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 内存释放 ------\n&quot;</span>);</span><br><span class="line">    freeAVLTree(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AVL树内存已释放。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AVL树作为最早的自平衡二叉搜索树，通过严格的平衡因子限制和巧妙的旋转操作，保证了树的高度维持在 O(logn) 级别。这使得其在查找、插入和删除操作上都达到了 O(logn) 的时间复杂度，显著优于普通二叉搜索树在最坏情况下的表现。尽管实现相对复杂，但AVL树在需要高效动态维护有序数据的场景中，仍然是一种非常重要且实用的数据结构。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-链表" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2025/05/30/%E9%93%BE%E8%A1%A8/" class="article-date">
      <time datetime="2025-05-30T12:04:51.000Z" itemprop="datePublished">2025-05-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/05/30/%E9%93%BE%E8%A1%A8/">链表</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="C-语言中的链表节点定义"><a href="#C-语言中的链表节点定义" class="headerlink" title="C 语言中的链表节点定义"></a>C 语言中的链表节点定义</h3><p>在 C 语言中，我们通常使用结构体（<code>struct</code>）来定义链表的节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 包含 malloc 和 free 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;          <span class="comment">// 数据域，这里以整型为例，也可以是其他类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域，指向下一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了方便，我们经常定义一个指向 Node 的指针类型</span></span><br><span class="line"><span class="comment">// typedef struct Node* LinkList; // 另一种定义方式</span></span><br></pre></td></tr></table></figure>

<h3 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><h4 id="1-创建新节点"><a href="#1-创建新节点" class="headerlink" title="1 创建新节点"></a>1 创建新节点</h4><p>创建新节点是链表操作的基础。我们需要使用 <code>malloc</code> 为新节点分配内存，并初始化其数据和指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新节点</span></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value; <span class="comment">// 设置数据</span></span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 新节点的next指针初始为NULL</span></span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-链表的初始化（创建空链表）"><a href="#2-链表的初始化（创建空链表）" class="headerlink" title="2 链表的初始化（创建空链表）"></a>2 链表的初始化（创建空链表）</h4><p>空链表通常用一个 <code>NULL</code> 指针表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空链表（头指针）</span></span><br><span class="line">Node* <span class="title function_">initLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 空链表的头指针指向NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-在链表头部插入节点"><a href="#3-在链表头部插入节点" class="headerlink" title="3 在链表头部插入节点"></a>3 在链表头部插入节点</h4><p>这是最简单的插入操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表头部插入节点</span></span><br><span class="line">Node* <span class="title function_">insertAtHead</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(value);</span><br><span class="line">    newNode-&gt;next = head; <span class="comment">// 新节点的next指向原来的头节点</span></span><br><span class="line">    <span class="keyword">return</span> newNode;        <span class="comment">// 返回新节点作为新的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-在链表尾部插入节点"><a href="#4-在链表尾部插入节点" class="headerlink" title="4 在链表尾部插入节点"></a>4 在链表尾部插入节点</h4><p>需要遍历链表找到尾节点，然后将其 <code>next</code> 指针指向新节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表尾部插入节点</span></span><br><span class="line">Node* <span class="title function_">insertAtTail</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(value);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果链表为空，新节点就是头节点</span></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 遍历到链表尾部</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = newNode; <span class="comment">// 尾节点的next指向新节点</span></span><br><span class="line">    <span class="keyword">return</span> head;             <span class="comment">// 返回原来的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-遍历链表并打印数据"><a href="#5-遍历链表并打印数据" class="headerlink" title="5 遍历链表并打印数据"></a>5 遍历链表并打印数据</h4><p>这是最常用的操作之一，用于查看链表中的所有元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印链表所有节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLinkedList</span><span class="params">(Node* head)</span> &#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内容：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-查找节点"><a href="#6-查找节点" class="headerlink" title="6 查找节点"></a>6 查找节点</h4><p>根据数据查找特定节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找链表中是否存在某个值的节点</span></span><br><span class="line">Node* <span class="title function_">findNode</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;data == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> current; <span class="comment">// 找到，返回该节点指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-删除节点"><a href="#7-删除节点" class="headerlink" title="7 删除节点"></a>7 删除节点</h4><p>删除指定值的节点。这里我们处理了三种情况：删除头节点、删除中间节点、删除不存在的节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除链表中指定值的节点</span></span><br><span class="line">Node* <span class="title function_">deleteNode</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 链表为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要删除的是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;data == value) &#123;</span><br><span class="line">        Node* temp = head;</span><br><span class="line">        head = head-&gt;next; <span class="comment">// 新的头节点是原头节点的next</span></span><br><span class="line">        <span class="built_in">free</span>(temp);        <span class="comment">// 释放原头节点内存</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span> &amp;&amp; current-&gt;next-&gt;data != value) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到要删除的节点（current-&gt;next）</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node* temp = current-&gt;next; <span class="comment">// 待删除节点</span></span><br><span class="line">        current-&gt;next = temp-&gt;next; <span class="comment">// current的next指向待删除节点的next</span></span><br><span class="line">        <span class="built_in">free</span>(temp);                 <span class="comment">// 释放待删除节点内存</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 %d 的节点进行删除。\n&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-释放链表内存"><a href="#8-释放链表内存" class="headerlink" title="8 释放链表内存"></a>8 释放链表内存</h4><p>完成链表操作后，务必释放所有节点的内存，避免内存泄漏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放链表所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeLinkedList</span><span class="params">(Node* head)</span> &#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node* temp = current; <span class="comment">// 临时保存当前节点</span></span><br><span class="line">        current = current-&gt;next; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        <span class="built_in">free</span>(temp); <span class="comment">// 释放当前节点内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码"></a>完整示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新节点</span></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头部插入节点</span></span><br><span class="line">Node* <span class="title function_">insertAtHead</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(value);</span><br><span class="line">    newNode-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表尾部插入节点</span></span><br><span class="line">Node* <span class="title function_">insertAtTail</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(value);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = newNode;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表所有节点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printLinkedList</span><span class="params">(Node* head)</span> &#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内容：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找链表中是否存在某个值的节点</span></span><br><span class="line">Node* <span class="title function_">findNode</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;data == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表中指定值的节点</span></span><br><span class="line">Node* <span class="title function_">deleteNode</span><span class="params">(Node* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表为空，无法删除。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要删除的是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;data == value) &#123;</span><br><span class="line">        Node* temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功删除头节点 %d。\n&quot;</span>, value);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span> &amp;&amp; current-&gt;next-&gt;data != value) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到要删除的节点（current-&gt;next）</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node* temp = current-&gt;next;</span><br><span class="line">        current-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功删除节点 %d。\n&quot;</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 %d 的节点进行删除。\n&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放链表所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeLinkedList</span><span class="params">(Node* head)</span> &#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* head = <span class="literal">NULL</span>; <span class="comment">// 初始化空链表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------ 插入操作 ------\n&quot;</span>);</span><br><span class="line">    head = insertAtHead(head, <span class="number">10</span>); <span class="comment">// 10 -&gt; NULL</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    </span><br><span class="line">    head = insertAtTail(head, <span class="number">20</span>); <span class="comment">// 10 -&gt; 20 -&gt; NULL</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    </span><br><span class="line">    head = insertAtHead(head, <span class="number">5</span>);  <span class="comment">// 5 -&gt; 10 -&gt; 20 -&gt; NULL</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line"></span><br><span class="line">    head = insertAtTail(head, <span class="number">30</span>); <span class="comment">// 5 -&gt; 10 -&gt; 20 -&gt; 30 -&gt; NULL</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 查找操作 ------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (findNode(head, <span class="number">10</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了值为 10 的节点。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 10 的节点。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (findNode(head, <span class="number">100</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了值为 100 的节点。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 100 的节点。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 删除操作 ------\n&quot;</span>);</span><br><span class="line">    head = deleteNode(head, <span class="number">5</span>); <span class="comment">// 删除头节点</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    </span><br><span class="line">    head = deleteNode(head, <span class="number">20</span>); <span class="comment">// 删除中间节点</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line"></span><br><span class="line">    head = deleteNode(head, <span class="number">100</span>); <span class="comment">// 删除不存在的节点</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line"></span><br><span class="line">    head = deleteNode(head, <span class="number">30</span>); <span class="comment">// 删除最后一个节点</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    </span><br><span class="line">    head = deleteNode(head, <span class="number">10</span>); <span class="comment">// 删除最后一个节点（现在是头节点）</span></span><br><span class="line">    printLinkedList(head);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n------ 内存释放 ------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 再次插入一些节点用于测试内存释放</span></span><br><span class="line">    head = insertAtTail(head, <span class="number">1</span>);</span><br><span class="line">    head = insertAtTail(head, <span class="number">2</span>);</span><br><span class="line">    printLinkedList(head);</span><br><span class="line">    freeLinkedList(head); <span class="comment">// 释放所有内存</span></span><br><span class="line">    head = <span class="literal">NULL</span>; <span class="comment">// 释放后将头指针设为NULL，避免野指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试打印已释放的链表，会输出NULL</span></span><br><span class="line">    printLinkedList(head); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表的变种"><a href="#链表的变种" class="headerlink" title="链表的变种"></a>链表的变种</h3><p>除了上面介绍的<strong>单向链表</strong>，还有其他几种常见的链表类型：</p>
<ul>
<li><strong>双向链表（Doubly Linked List）：</strong> 每个节点除了指向下一个节点的指针 <code>next</code> 外，还包含一个指向前一个节点的指针 <code>prev</code>。这使得链表可以双向遍历，但需要额外的空间存储 <code>prev</code> 指针。</li>
<li><strong>循环链表（Circular Linked List）：</strong> 链表的最后一个节点的 <code>next</code> 指针不是 <code>NULL</code>，而是指向头节点，形成一个环。</li>
</ul>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><h4 id="什么是双向链表？"><a href="#什么是双向链表？" class="headerlink" title="什么是双向链表？"></a>什么是双向链表？</h4><p>双向链表，顾名思义，就是每个节点不仅知道“下一个”是谁，也知道“上一个”是谁。它在单向链表的基础上，为每个节点额外增加了一个指向前一个节点的指针。</p>
<p><strong>双向链表节点的结构：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义双向链表节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoublyNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;                 <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoublyNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 指向前一个节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DoublyNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; DoublyNode;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li><strong>双向遍历：</strong> 可以从头到尾遍历，也可以从尾到头遍历。</li>
<li><strong>插入和删除更灵活：</strong> 在已知待操作节点的情况下，其前驱和后继节点都可以直接访问，从而简化了插入和删除操作（特别是删除指定节点）。</li>
<li><strong>空间开销增加：</strong> 每个节点需要额外存储一个 <code>prev</code> 指针，因此比单向链表占用更多内存。</li>
</ul>
<h4 id="双向链表的基本操作"><a href="#双向链表的基本操作" class="headerlink" title="双向链表的基本操作"></a>双向链表的基本操作</h4><p>我们将重点展示与单向链表不同的或更高效的操作。</p>
<h5 id="创建新节点"><a href="#创建新节点" class="headerlink" title="创建新节点"></a>创建新节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个双向链表新节点</span></span><br><span class="line">DoublyNode* <span class="title function_">createDoublyNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    DoublyNode* newNode = (DoublyNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DoublyNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;prev = <span class="literal">NULL</span>; <span class="comment">// 新节点的prev和next初始都为NULL</span></span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在链表头部插入节点"><a href="#在链表头部插入节点" class="headerlink" title="在链表头部插入节点"></a>在链表头部插入节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在双向链表头部插入节点</span></span><br><span class="line">DoublyNode* <span class="title function_">insertDoublyAtHead</span><span class="params">(DoublyNode* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    DoublyNode* newNode = createDoublyNode(value);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果链表为空</span></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;next = head; <span class="comment">// 新节点指向原来的头节点</span></span><br><span class="line">    head-&gt;prev = newNode; <span class="comment">// 原头节点的prev指向新节点</span></span><br><span class="line">    <span class="keyword">return</span> newNode;       <span class="comment">// 返回新节点作为新的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在链表尾部插入节点"><a href="#在链表尾部插入节点" class="headerlink" title="在链表尾部插入节点"></a>在链表尾部插入节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在双向链表尾部插入节点</span></span><br><span class="line">DoublyNode* <span class="title function_">insertDoublyAtTail</span><span class="params">(DoublyNode* head, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    DoublyNode* newNode = createDoublyNode(value);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果链表为空</span></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    DoublyNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 遍历到链表尾部</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = newNode; <span class="comment">// 尾节点的next指向新节点</span></span><br><span class="line">    newNode-&gt;prev = current; <span class="comment">// 新节点的prev指向原来的尾节点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在指定节点后插入"><a href="#在指定节点后插入" class="headerlink" title="在指定节点后插入"></a>在指定节点后插入</h5><p>这是双向链表的一个便利之处，单向链表需要找到前驱节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在指定节点后面插入新节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertAfterNode</span><span class="params">(DoublyNode* node, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法在空节点后插入。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DoublyNode* newNode = createDoublyNode(value);</span><br><span class="line">    newNode-&gt;next = node-&gt;next; <span class="comment">// 新节点指向node的下一个节点</span></span><br><span class="line">    newNode-&gt;prev = node;       <span class="comment">// 新节点指向node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果node不是最后一个节点</span></span><br><span class="line">        node-&gt;next-&gt;prev = newNode; <span class="comment">// node的下一个节点的prev指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;next = newNode;       <span class="comment">// node的next指向新节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除指定节点（已知节点指针）</p>
<p>这也是双向链表删除操作的优势。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定节点（给定节点指针）</span></span><br><span class="line"><span class="comment">// 注意：如果删除的是头节点，需要更新头指针</span></span><br><span class="line">DoublyNode* <span class="title function_">deleteGivenDoublyNode</span><span class="params">(DoublyNode* head, DoublyNode* nodeToDelete)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || nodeToDelete == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head; <span class="comment">// 链表为空或待删除节点为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodeToDelete == head) &#123; <span class="comment">// 删除头节点</span></span><br><span class="line">        head = nodeToDelete-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nodeToDelete-&gt;prev-&gt;next = nodeToDelete-&gt;next; <span class="comment">// 前驱节点的next指向待删除节点的next</span></span><br><span class="line">        <span class="keyword">if</span> (nodeToDelete-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果不是尾节点</span></span><br><span class="line">            nodeToDelete-&gt;next-&gt;prev = nodeToDelete-&gt;prev; <span class="comment">// 后继节点的prev指向待删除节点的prev</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(nodeToDelete); <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历双向链表（正向和反向）"><a href="#遍历双向链表（正向和反向）" class="headerlink" title="遍历双向链表（正向和反向）"></a>遍历双向链表（正向和反向）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正向打印双向链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printDoublyLinkedListForward</span><span class="params">(DoublyNode* head)</span> &#123;</span><br><span class="line">    DoublyNode* current = head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;双向链表（正向）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &lt;-&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向打印双向链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printDoublyLinkedListBackward</span><span class="params">(DoublyNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;双向链表（反向）：NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DoublyNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 先找到尾节点</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;双向链表（反向）：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &lt;-&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放双向链表内存"><a href="#释放双向链表内存" class="headerlink" title="释放双向链表内存"></a>释放双向链表内存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放双向链表所有节点的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeDoublyLinkedList</span><span class="params">(DoublyNode* head)</span> &#123;</span><br><span class="line">    DoublyNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DoublyNode* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;双向链表内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环链表（Circular-Linked-List）"><a href="#循环链表（Circular-Linked-List）" class="headerlink" title="循环链表（Circular Linked List）"></a>循环链表（Circular Linked List）</h3><h4 id="什么是循环链表？"><a href="#什么是循环链表？" class="headerlink" title="什么是循环链表？"></a>什么是循环链表？</h4><p>循环链表是一种特殊的单向链表（也可以是双向的）。它的最后一个节点的 <code>next</code> 指针不是指向 <code>NULL</code>，而是指向链表的<strong>头节点</strong>，形成一个环。</p>
<p><strong>循环链表节点的结构（与单向链表相同）：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义循环链表节点结构体 (与单向链表相同)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CircularNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CircularNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; CircularNode;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li><strong>无“尾”概念：</strong> 链表中没有真正的“尾节点”（其 <code>next</code> 指向 <code>NULL</code> 的节点），遍历可以无限进行下去，直到回到起点。</li>
<li><strong>从任何节点开始遍历：</strong> 从链表中的任何一个节点开始，都可以遍历到所有节点。</li>
<li><strong>插入删除无需特殊处理头尾：</strong> 插入和删除操作相对单向链表在处理头尾时更统一。</li>
<li><strong>遍历需要停止条件：</strong> 需要额外的逻辑来判断是否已经遍历了一圈，避免无限循环。</li>
</ul>
<h4 id="2-循环链表的基本操作"><a href="#2-循环链表的基本操作" class="headerlink" title="2 循环链表的基本操作"></a>2 循环链表的基本操作</h4><p>由于循环链表的结构与单向链表相似，许多操作逻辑是类似的，但需要注意“环”的特性。为了简化，我们通常会维护一个指向<strong>尾节点</strong>的指针，而不是头节点。因为通过尾节点，可以 O(1) 时间访问到头节点（<code>tail-&gt;next</code> 就是头节点）。</p>
<h5 id="创建新节点（与单向链表相同）"><a href="#创建新节点（与单向链表相同）" class="headerlink" title="创建新节点（与单向链表相同）"></a>创建新节点（与单向链表相同）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个循环链表新节点</span></span><br><span class="line">CircularNode* <span class="title function_">createCircularNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    CircularNode* newNode = (CircularNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CircularNode));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 初始时指向NULL</span></span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="循环链表的初始化（返回尾指针）"><a href="#循环链表的初始化（返回尾指针）" class="headerlink" title="循环链表的初始化（返回尾指针）"></a>循环链表的初始化（返回尾指针）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空循环链表（返回尾指针）</span></span><br><span class="line">CircularNode* <span class="title function_">initCircularLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 空循环链表的尾指针指向NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在链表头部插入节点-1"><a href="#在链表头部插入节点-1" class="headerlink" title="在链表头部插入节点"></a>在链表头部插入节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在循环链表头部插入节点 (tail指向尾节点)</span></span><br><span class="line">CircularNode* <span class="title function_">insertCircularAtHead</span><span class="params">(CircularNode* tail, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    CircularNode* newNode = createCircularNode(value);</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) &#123; <span class="comment">// 链表为空时，新节点就是头也是尾</span></span><br><span class="line">        newNode-&gt;next = newNode; <span class="comment">// 自己指向自己</span></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode-&gt;next = tail-&gt;next; <span class="comment">// 新节点指向原来的头节点</span></span><br><span class="line">        tail-&gt;next = newNode;       <span class="comment">// 尾节点指向新节点</span></span><br><span class="line">        <span class="keyword">return</span> tail;                <span class="comment">// 返回尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在链表尾部插入节点-1"><a href="#在链表尾部插入节点-1" class="headerlink" title="在链表尾部插入节点"></a>在链表尾部插入节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在循环链表尾部插入节点 (tail指向尾节点)</span></span><br><span class="line">CircularNode* <span class="title function_">insertCircularAtTail</span><span class="params">(CircularNode* tail, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    CircularNode* newNode = createCircularNode(value);</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) &#123; <span class="comment">// 链表为空时，新节点就是头也是尾</span></span><br><span class="line">        newNode-&gt;next = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode-&gt;next = tail-&gt;next; <span class="comment">// 新节点指向头节点</span></span><br><span class="line">        tail-&gt;next = newNode;       <span class="comment">// 原尾节点指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode; <span class="comment">// 返回新节点作为新的尾节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="遍历循环链表并打印数据"><a href="#遍历循环链表并打印数据" class="headerlink" title="遍历循环链表并打印数据"></a>遍历循环链表并打印数据</h5><p>需要一个额外的条件来判断是否已经回到起点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印循环链表所有节点的数据 (tail指向尾节点)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printCircularLinkedList</span><span class="params">(CircularNode* tail)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;循环链表内容：NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CircularNode* head = tail-&gt;next; <span class="comment">// 头节点</span></span><br><span class="line">    CircularNode* current = head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;循环链表内容：&quot;</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != head); <span class="comment">// 遍历直到回到头节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;... (循环回到 %d)\n&quot;</span>, head-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除节点（已知尾节点和待删除值）"><a href="#删除节点（已知尾节点和待删除值）" class="headerlink" title="删除节点（已知尾节点和待删除值）"></a>删除节点（已知尾节点和待删除值）</h5><p>删除循环链表节点需要更细致的判断，特别是当只剩一个节点或删除头&#x2F;尾节点时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除循环链表中指定值的节点 (tail指向尾节点)</span></span><br><span class="line">CircularNode* <span class="title function_">deleteCircularNode</span><span class="params">(CircularNode* tail, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;循环链表为空，无法删除。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CircularNode* head = tail-&gt;next; <span class="comment">// 获取头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只有一个节点且是待删除节点</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail &amp;&amp; head-&gt;data == value) &#123;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功删除唯一节点 %d。\n&quot;</span>, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 链表变空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;data == value) &#123;</span><br><span class="line">        tail-&gt;next = head-&gt;next; <span class="comment">// 尾节点指向新的头节点</span></span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功删除头节点 %d。\n&quot;</span>, value);</span><br><span class="line">        <span class="keyword">return</span> tail; <span class="comment">// 返回原来的尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除中间或尾部节点</span></span><br><span class="line">    CircularNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != head &amp;&amp; current-&gt;next-&gt;data != value) &#123; <span class="comment">// 遍历直到找到或遍历一圈</span></span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next-&gt;data == value) &#123; <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">        CircularNode* temp = current-&gt;next;</span><br><span class="line">        current-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (temp == tail) &#123; <span class="comment">// 如果删除的是尾节点，更新tail</span></span><br><span class="line">            tail = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功删除节点 %d。\n&quot;</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 %d 的节点进行删除。\n&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放循环链表内存"><a href="#释放循环链表内存" class="headerlink" title="释放循环链表内存"></a>释放循环链表内存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放循环链表所有节点的内存 (tail指向尾节点)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeCircularLinkedList</span><span class="params">(CircularNode* tail)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;循环链表已空，无需释放。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CircularNode* head = tail-&gt;next;</span><br><span class="line">    CircularNode* current = head;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        CircularNode* temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != head); <span class="comment">// 遍历直到回到头节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;循环链表内存已释放。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2025 John Doe
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>